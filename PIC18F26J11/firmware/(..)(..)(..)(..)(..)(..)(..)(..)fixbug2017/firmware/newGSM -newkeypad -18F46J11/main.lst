CCS PCH C Compiler, Version 5.025, 20635               24-Sep-21 13:12

               Filename:   C:\Users\quangnt\Desktop\gitworks\PIC18F26J11\firmware\(..)(..)(..)(..)(..)(..)(..)(..)fixbug2017\firmware\newGSM -newkeypad -18F46J11\main.lst

               ROM used:   39304 bytes (60%)
                           Largest free fragment is 26220
               RAM used:   2706 (72%) at main() level
                           2801 (74%) worst case
               Stack used: 8 locations (4 in main + 4 for interrupts)
               Stack size: 31

*
0000:  GOTO   6BDC
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   4720
0060:  BTFSS  F9D.0
0062:  GOTO   006C
0066:  BTFSC  F9E.0
0068:  GOTO   23A8
006C:  BTFSS  FF0.3
006E:  GOTO   0078
0072:  BTFSC  FF0.0
0074:  GOTO   1CC0
0078:  BTFSS  F9D.5
007A:  GOTO   0084
007E:  BTFSC  F9E.5
0080:  GOTO   22D6
0084:  MOVFF  0E,00
0088:  MOVFF  0F,01
008C:  MOVFF  10,02
0090:  MOVFF  11,03
0094:  MOVFF  0C,FE9
0098:  MOVFF  07,FEA
009C:  BSF    07.7
009E:  MOVFF  08,FE1
00A2:  MOVFF  09,FE2
00A6:  MOVFF  0A,FD9
00AA:  MOVFF  0B,FDA
00AE:  MOVFF  12,FF3
00B2:  MOVFF  13,FF4
00B6:  MOVFF  14,FFA
00BA:  MOVFF  15,FF5
00BE:  MOVFF  16,FF6
00C2:  MOVFF  17,FF7
00C6:  MOVF   04,W
00C8:  MOVFF  06,FE0
00CC:  MOVFF  05,FD8
00D0:  RETFIE 0
....................  
.................... #define LED   PIN_A6 
.................... #include "main.h" 
.................... //FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST//#include <18F4431.h> 
.................... //#include <16F877a.h> 
.................... //#include <18F4455.h> 
.................... //#priority INT_EXT1,RDA,INT_TIMER0 
.................... #define dis_rev #ASM BCF    0xF94.7 #ENDASM 
.................... #define debug 
.................... #define debugkb 
.................... //#define PIC24 
.................... #define PIC26 
.................... #define SIM900 
.................... #define twonumber 
.................... //#define rst_pwd 
.................... //========================= 
.................... #if defined(PIC24) 
....................    #include <18F24j11.h> 
.................... #else 
....................    #include <18F26j11.h> 
.................... //////////// Standard Header file for the PIC18F26J11 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F26J11 
00D2:  CLRF   FF7
00D4:  ADDLW  E2
00D6:  MOVWF  FF6
00D8:  MOVLW  00
00DA:  ADDWFC FF7,F
00DC:  TBLRD*+
00DE:  MOVF   FF5,W
00E0:  RETURN 0
00E2:  DATA 61,64
00E4:  DATA 6D,69
00E6:  DATA 6E,00
00E8:  CLRF   FF7
00EA:  ADDLW  F8
00EC:  MOVWF  FF6
00EE:  MOVLW  00
00F0:  ADDWFC FF7,F
00F2:  TBLRD*+
00F4:  MOVF   FF5,W
00F6:  RETURN 0
00F8:  DATA 31,32
00FA:  DATA 33,41
00FC:  DATA 42,34
00FE:  DATA 35,36
0100:  DATA 43,44
0102:  DATA 37,38
0104:  DATA 39,45
0106:  DATA 46,2A
0108:  DATA 30,23
010A:  DATA 47,48
010C:  CLRF   FF7
010E:  ADDLW  1C
0110:  MOVWF  FF6
0112:  MOVLW  01
0114:  ADDWFC FF7,F
0116:  TBLRD*+
0118:  MOVF   FF5,W
011A:  RETURN 0
011C:  DATA 31,32
011E:  DATA 33,41
0120:  DATA 42,43
0122:  DATA 34,35
0124:  DATA 36,44
0126:  DATA 45,46
0128:  DATA 37,38
012A:  DATA 39,47
012C:  DATA 48,49
012E:  DATA 2A,30
0130:  DATA 23,4A
0132:  DATA 4B,4D
0134:  CLRF   FF7
0136:  ADDLW  44
0138:  MOVWF  FF6
013A:  MOVLW  01
013C:  ADDWFC FF7,F
013E:  TBLRD*+
0140:  MOVF   FF5,W
0142:  RETURN 0
0144:  DATA 64,6F
0146:  DATA 6E,65
0148:  DATA 00,00
014A:  CLRF   FF7
014C:  ADDLW  5A
014E:  MOVWF  FF6
0150:  MOVLW  01
0152:  ADDWFC FF7,F
0154:  TBLRD*+
0156:  MOVF   FF5,W
0158:  RETURN 0
015A:  DATA 72,73
015C:  DATA 66,61
015E:  DATA 63,74
0160:  DATA 00,00
0162:  CLRF   FF7
0164:  ADDLW  72
0166:  MOVWF  FF6
0168:  MOVLW  01
016A:  ADDWFC FF7,F
016C:  TBLRD*+
016E:  MOVF   FF5,W
0170:  RETURN 0
0172:  DATA 70,61
0174:  DATA 73,73
0176:  DATA 77,6F
0178:  DATA 72,64
017A:  DATA 00,00
017C:  CLRF   FF7
017E:  ADDLW  8C
0180:  MOVWF  FF6
0182:  MOVLW  01
0184:  ADDWFC FF7,F
0186:  TBLRD*+
0188:  MOVF   FF5,W
018A:  RETURN 0
018C:  DATA 46,75
018E:  DATA 6C,6C
0190:  DATA 20,6D
0192:  DATA 65,6D
0194:  DATA 6F,72
0196:  DATA 79,2C
0198:  DATA 20,70
019A:  DATA 6C,65
019C:  DATA 61,73
019E:  DATA 65,20
01A0:  DATA 66,6F
01A2:  DATA 72,6D
01A4:  DATA 61,74
01A6:  DATA 20,6D
01A8:  DATA 65,6D
01AA:  DATA 6F,72
01AC:  DATA 79,00
01AE:  CLRF   FF7
01B0:  ADDLW  BE
01B2:  MOVWF  FF6
01B4:  MOVLW  01
01B6:  ADDWFC FF7,F
01B8:  TBLRD*+
01BA:  MOVF   FF5,W
01BC:  RETURN 0
01BE:  DATA 72,65
01C0:  DATA 64,6F
01C2:  DATA 6F,00
01C4:  CLRF   FF7
01C6:  ADDLW  D4
01C8:  MOVWF  FF6
01CA:  MOVLW  01
01CC:  ADDWFC FF7,F
01CE:  TBLRD*+
01D0:  MOVF   FF5,W
01D2:  RETURN 0
01D4:  DATA 67,6F
01D6:  DATA 6F,64
01D8:  DATA 62,79
01DA:  DATA 65,00
01DC:  CLRF   FF7
01DE:  ADDLW  EC
01E0:  MOVWF  FF6
01E2:  MOVLW  01
01E4:  ADDWFC FF7,F
01E6:  TBLRD*+
01E8:  MOVF   FF5,W
01EA:  RETURN 0
01EC:  DATA 77,72
01EE:  DATA 6F,6E
01F0:  DATA 67,20
01F2:  DATA 70,61
01F4:  DATA 73,73
01F6:  DATA 77,6F
01F8:  DATA 72,64
01FA:  DATA 00,00
01FC:  CLRF   FF7
01FE:  ADDLW  0C
0200:  MOVWF  FF6
0202:  MOVLW  02
0204:  ADDWFC FF7,F
0206:  TBLRD*+
0208:  MOVF   FF5,W
020A:  RETURN 0
020C:  DATA 68,65
020E:  DATA 6C,6C
0210:  DATA 6F,00
0212:  CLRF   FF7
0214:  ADDLW  22
0216:  MOVWF  FF6
0218:  MOVLW  02
021A:  ADDWFC FF7,F
021C:  TBLRD*+
021E:  MOVF   FF5,W
0220:  RETURN 0
0222:  DATA 6B,65
0224:  DATA 79,70
0226:  DATA 72,65
0228:  DATA 73,73
022A:  DATA 00,00
022C:  CLRF   FF7
022E:  ADDLW  3C
0230:  MOVWF  FF6
0232:  MOVLW  02
0234:  ADDWFC FF7,F
0236:  TBLRD*+
0238:  MOVF   FF5,W
023A:  RETURN 0
023C:  DATA 6F,6E
023E:  DATA 00,00
0240:  CLRF   FF7
0242:  ADDLW  50
0244:  MOVWF  FF6
0246:  MOVLW  02
0248:  ADDWFC FF7,F
024A:  TBLRD*+
024C:  MOVF   FF5,W
024E:  RETURN 0
0250:  DATA 6F,66
0252:  DATA 66,00
0254:  CLRF   FF7
0256:  ADDLW  64
0258:  MOVWF  FF6
025A:  MOVLW  02
025C:  ADDWFC FF7,F
025E:  TBLRD*+
0260:  MOVF   FF5,W
0262:  RETURN 0
0264:  DATA 70,6C
0266:  DATA 65,61
0268:  DATA 73,65
026A:  DATA 20,63
026C:  DATA 68,65
026E:  DATA 63,6B
0270:  DATA 20,79
0272:  DATA 6F,75
0274:  DATA 72,20
0276:  DATA 73,79
0278:  DATA 6E,74
027A:  DATA 61,78
027C:  DATA 00,00
027E:  CLRF   FF7
0280:  ADDLW  8E
0282:  MOVWF  FF6
0284:  MOVLW  02
0286:  ADDWFC FF7,F
0288:  TBLRD*+
028A:  MOVF   FF5,W
028C:  RETURN 0
028E:  DATA 6D,61
0290:  DATA 73,74
0292:  DATA 65,72
0294:  DATA 00,00
0296:  CLRF   FF7
0298:  ADDLW  A6
029A:  MOVWF  FF6
029C:  MOVLW  02
029E:  ADDWFC FF7,F
02A0:  TBLRD*+
02A2:  MOVF   FF5,W
02A4:  RETURN 0
02A6:  DATA 6B,6F
02A8:  DATA 66,6B
02AA:  DATA 62,20
02AC:  DATA 6E,65
02AE:  DATA 77,00
02B0:  CLRF   FF7
02B2:  ADDLW  C0
02B4:  MOVWF  FF6
02B6:  MOVLW  02
02B8:  ADDWFC FF7,F
02BA:  TBLRD*+
02BC:  MOVF   FF5,W
02BE:  RETURN 0
02C0:  DATA 6B,6F
02C2:  DATA 66,6B
02C4:  DATA 62,20
02C6:  DATA 6F,6C
02C8:  DATA 64,00
02CA:  CLRF   FF7
02CC:  ADDLW  DA
02CE:  MOVWF  FF6
02D0:  MOVLW  02
02D2:  ADDWFC FF7,F
02D4:  TBLRD*+
02D6:  MOVF   FF5,W
02D8:  RETURN 0
02DA:  DATA 74,72
02DC:  DATA 61,6E
02DE:  DATA 74,69
02E0:  DATA 6D,65
02E2:  DATA 00,00
02E4:  CLRF   FF7
02E6:  ADDLW  F4
02E8:  MOVWF  FF6
02EA:  MOVLW  02
02EC:  ADDWFC FF7,F
02EE:  TBLRD*+
02F0:  MOVF   FF5,W
02F2:  RETURN 0
02F4:  DATA 61,75
02F6:  DATA 74,6F
02F8:  DATA 73,65
02FA:  DATA 6E,64
02FC:  DATA 69,6E
02FE:  DATA 67,00
0300:  CLRF   FF7
0302:  ADDLW  10
0304:  MOVWF  FF6
0306:  MOVLW  03
0308:  ADDWFC FF7,F
030A:  TBLRD*+
030C:  MOVF   FF5,W
030E:  RETURN 0
0310:  DATA 71,75
0312:  DATA 6C,6C
0314:  DATA 66,00
0316:  CLRF   FF7
0318:  ADDLW  26
031A:  MOVWF  FF6
031C:  MOVLW  03
031E:  ADDWFC FF7,F
0320:  TBLRD*+
0322:  MOVF   FF5,W
0324:  RETURN 0
0326:  DATA 66,6F
0328:  DATA 72,6D
032A:  DATA 61,74
032C:  DATA 00,00
032E:  CLRF   FF7
0330:  ADDLW  3E
0332:  MOVWF  FF6
0334:  MOVLW  03
0336:  ADDWFC FF7,F
0338:  TBLRD*+
033A:  MOVF   FF5,W
033C:  RETURN 0
033E:  DATA 63,6F
0340:  DATA 75,6E
0342:  DATA 74,72
0344:  DATA 65,63
0346:  DATA 00,00
0348:  CLRF   FF7
034A:  ADDLW  58
034C:  MOVWF  FF6
034E:  MOVLW  03
0350:  ADDWFC FF7,F
0352:  TBLRD*+
0354:  MOVF   FF5,W
0356:  RETURN 0
0358:  DATA 64,65
035A:  DATA 76,69
035C:  DATA 63,65
035E:  DATA 20,68
0360:  DATA 61,73
0362:  DATA 20,00
0364:  CLRF   FF7
0366:  ADDLW  74
0368:  MOVWF  FF6
036A:  MOVLW  03
036C:  ADDWFC FF7,F
036E:  TBLRD*+
0370:  MOVF   FF5,W
0372:  RETURN 0
0374:  DATA 20,74
0376:  DATA 72,61
0378:  DATA 6E,73
037A:  DATA 61,63
037C:  DATA 74,69
037E:  DATA 6F,6E
0380:  DATA 20,00
0382:  CLRF   FF7
0384:  ADDLW  92
0386:  MOVWF  FF6
0388:  MOVLW  03
038A:  ADDWFC FF7,F
038C:  TBLRD*+
038E:  MOVF   FF5,W
0390:  RETURN 0
0392:  DATA 64,6F
0394:  DATA 77,6E
0396:  DATA 6C,6F
0398:  DATA 61,64
039A:  DATA 20,61
039C:  DATA 6C,6C
039E:  DATA 00,00
03A0:  CLRF   FF7
03A2:  ADDLW  B0
03A4:  MOVWF  FF6
03A6:  MOVLW  03
03A8:  ADDWFC FF7,F
03AA:  TBLRD*+
03AC:  MOVF   FF5,W
03AE:  RETURN 0
03B0:  DATA 64,6F
03B2:  DATA 77,6E
03B4:  DATA 6C,6F
03B6:  DATA 61,64
03B8:  DATA 20,00
03BA:  CLRF   FF7
03BC:  ADDLW  CA
03BE:  MOVWF  FF6
03C0:  MOVLW  03
03C2:  ADDWFC FF7,F
03C4:  TBLRD*+
03C6:  MOVF   FF5,W
03C8:  RETURN 0
03CA:  DATA 44,65
03CC:  DATA 76,69
03CE:  DATA 63,65
03D0:  DATA 20,68
03D2:  DATA 61,73
03D4:  DATA 20,6F
03D6:  DATA 6E,6C
03D8:  DATA 79,20
03DA:  DATA 00,00
03DC:  CLRF   FF7
03DE:  ADDLW  EC
03E0:  MOVWF  FF6
03E2:  MOVLW  03
03E4:  ADDWFC FF7,F
03E6:  TBLRD*+
03E8:  MOVF   FF5,W
03EA:  RETURN 0
03EC:  DATA 20,54
03EE:  DATA 72,61
03F0:  DATA 63,6B
03F2:  DATA 31,3E
03F4:  DATA 00,00
03F6:  CLRF   FF7
03F8:  ADDLW  06
03FA:  MOVWF  FF6
03FC:  MOVLW  04
03FE:  ADDWFC FF7,F
0400:  TBLRD*+
0402:  MOVF   FF5,W
0404:  RETURN 0
0406:  DATA 20,54
0408:  DATA 72,61
040A:  DATA 63,6B
040C:  DATA 32,3E
040E:  DATA 00,00
0410:  CLRF   FF7
0412:  ADDLW  20
0414:  MOVWF  FF6
0416:  MOVLW  04
0418:  ADDWFC FF7,F
041A:  TBLRD*+
041C:  MOVF   FF5,W
041E:  RETURN 0
0420:  DATA 20,50
0422:  DATA 49,4E
0424:  DATA 3A,00
0426:  DATA 63,6F
0428:  DATA 6C,30
042A:  DATA 20,3D
042C:  DATA 20,25
042E:  DATA 6C,75
0430:  DATA 0D,0A
0432:  DATA 00,00
0434:  DATA 63,6F
0436:  DATA 6C,31
0438:  DATA 20,3D
043A:  DATA 20,25
043C:  DATA 6C,75
043E:  DATA 0D,0A
0440:  DATA 00,00
0442:  DATA 63,6F
0444:  DATA 6C,32
0446:  DATA 20,3D
0448:  DATA 20,25
044A:  DATA 6C,75
044C:  DATA 0D,0A
044E:  DATA 00,00
0450:  DATA 63,6F
0452:  DATA 6C,33
0454:  DATA 20,3D
0456:  DATA 20,25
0458:  DATA 6C,75
045A:  DATA 0D,0A
045C:  DATA 00,00
045E:  DATA 63,6F
0460:  DATA 6C,34
0462:  DATA 20,3D
0464:  DATA 20,25
0466:  DATA 6C,75
0468:  DATA 0D,0A
046A:  DATA 00,00
046C:  DATA 63,6F
046E:  DATA 6C,30
0470:  DATA 20,3D
0472:  DATA 20,25
0474:  DATA 6C,75
0476:  DATA 0D,0A
0478:  DATA 00,00
047A:  DATA 63,6F
047C:  DATA 6C,31
047E:  DATA 20,3D
0480:  DATA 20,25
0482:  DATA 6C,75
0484:  DATA 0D,0A
0486:  DATA 00,00
0488:  DATA 63,6F
048A:  DATA 6C,32
048C:  DATA 20,3D
048E:  DATA 20,25
0490:  DATA 6C,75
0492:  DATA 0D,0A
0494:  DATA 00,00
0496:  DATA 63,6F
0498:  DATA 6C,33
049A:  DATA 20,3D
049C:  DATA 20,25
049E:  DATA 6C,75
04A0:  DATA 0D,0A
04A2:  DATA 00,00
04A4:  DATA 63,6F
04A6:  DATA 6C,34
04A8:  DATA 20,3D
04AA:  DATA 20,25
04AC:  DATA 6C,75
04AE:  DATA 0D,0A
04B0:  DATA 00,00
04B2:  DATA 63,6F
04B4:  DATA 6C,35
04B6:  DATA 20,3D
04B8:  DATA 20,25
04BA:  DATA 6C,75
04BC:  DATA 0D,0A
04BE:  DATA 00,00
04C0:  DATA 6B,65
04C2:  DATA 79,20
04C4:  DATA 64,61
04C6:  DATA 74,61
04C8:  DATA 5B,25
04CA:  DATA 64,5D
04CC:  DATA 20,25
04CE:  DATA 63,0D
04D0:  DATA 0A,00
04D2:  DATA 44,6F
04D4:  DATA 6E,65
04D6:  DATA 20,50
04D8:  DATA 49,4E
04DA:  DATA 00,00
04DC:  DATA 4B,65
04DE:  DATA 79,00
04E0:  DATA 41,54
04E2:  DATA 0D,0A
04E4:  DATA 00,00
04E6:  DATA 41,54
04E8:  DATA 2B,43
04EA:  DATA 4D,47
04EC:  DATA 46,3D
04EE:  DATA 31,0D
04F0:  DATA 0A,00
04F2:  DATA 41,54
04F4:  DATA 0D,0A
04F6:  DATA 00,00
04F8:  DATA 41,54
04FA:  DATA 0D,0A
04FC:  DATA 00,00
04FE:  DATA 41,54
0500:  DATA 0D,0A
0502:  DATA 00,00
0504:  DATA 41,54
0506:  DATA 0D,0A
0508:  DATA 00,00
050A:  DATA 41,54
050C:  DATA 0D,0A
050E:  DATA 00,00
0510:  DATA 41,54
0512:  DATA 2B,43
0514:  DATA 50,4F
0516:  DATA 57,44
0518:  DATA 0D,0A
051A:  DATA 00,00
051C:  DATA 41,54
051E:  DATA 2B,43
0520:  DATA 4D,47
0522:  DATA 44,3D
0524:  DATA 31,0D
0526:  DATA 0A,00
0528:  DATA 41,54
052A:  DATA 2B,43
052C:  DATA 4D,47
052E:  DATA 44,3D
0530:  DATA 32,0D
0532:  DATA 0A,00
0534:  DATA 41,54
0536:  DATA 2B,43
0538:  DATA 4D,47
053A:  DATA 44,3D
053C:  DATA 33,0D
053E:  DATA 0A,00
0540:  DATA 41,54
0542:  DATA 2B,43
0544:  DATA 4D,47
0546:  DATA 44,3D
0548:  DATA 34,0D
054A:  DATA 0A,00
054C:  DATA 41,54
054E:  DATA 2B,43
0550:  DATA 4D,47
0552:  DATA 44,3D
0554:  DATA 35,0D
0556:  DATA 0A,00
0558:  DATA 41,54
055A:  DATA 2B,43
055C:  DATA 4D,47
055E:  DATA 44,3D
0560:  DATA 36,0D
0562:  DATA 0A,00
0564:  DATA 41,54
0566:  DATA 2B,43
0568:  DATA 4D,47
056A:  DATA 44,3D
056C:  DATA 37,0D
056E:  DATA 0A,00
0570:  DATA 41,54
0572:  DATA 2B,43
0574:  DATA 4D,47
0576:  DATA 44,3D
0578:  DATA 38,0D
057A:  DATA 0A,00
057C:  DATA 41,54
057E:  DATA 2B,43
0580:  DATA 4D,47
0582:  DATA 53,3D
0584:  DATA 00,00
0586:  DATA 41,54
0588:  DATA 2B,43
058A:  DATA 4D,47
058C:  DATA 46,3D
058E:  DATA 31,0D
0590:  DATA 0A,00
0592:  DATA 41,54
0594:  DATA 2B,43
0596:  DATA 4D,47
0598:  DATA 52,3D
059A:  DATA 31,0D
059C:  DATA 0A,00
059E:  DATA 0A,0D
05A0:  DATA 4E,65
05A2:  DATA 77,20
05A4:  DATA 53,4D
05A6:  DATA 53,20
05A8:  DATA 25,6C
05AA:  DATA 75,0A
05AC:  DATA 0D,00
05AE:  DATA 0A,0D
05B0:  DATA 52,45
05B2:  DATA 43,20
05B4:  DATA 55,4E
05B6:  DATA 52,45
05B8:  DATA 41,44
05BA:  DATA 0A,0D
05BC:  DATA 00,00
05BE:  DATA 0A,0D
05C0:  DATA 52,49
05C2:  DATA 4E,47
05C4:  DATA 20,25
05C6:  DATA 6C,75
05C8:  DATA 0A,0D
05CA:  DATA 00,00
05CC:  DATA 52,65
05CE:  DATA 61,64
05D0:  DATA 79,20
05D2:  DATA 28,4D
05D4:  DATA 54,20
05D6:  DATA 61,6C
05D8:  DATA 6C,6F
05DA:  DATA 77,73
05DC:  DATA 20,63
05DE:  DATA 6F,6D
05E0:  DATA 6D,61
05E2:  DATA 6E,64
05E4:  DATA 73,20
05E6:  DATA 66,72
05E8:  DATA 6F,6D
05EA:  DATA 20,54
05EC:  DATA 41,2F
05EE:  DATA 54,45
05F0:  DATA 29,25
05F2:  DATA 6C,75
05F4:  DATA 0A,0D
05F6:  DATA 00,00
05F8:  DATA 4E,6F
05FA:  DATA 20,6E
05FC:  DATA 65,74
05FE:  DATA 77,6F
0600:  DATA 72,6B
0602:  DATA 0A,0D
0604:  DATA 00,00
0606:  DATA 72,65
0608:  DATA 73,65
060A:  DATA 74,69
060C:  DATA 6E,67
060E:  DATA 20,6D
0610:  DATA 6F,64
0612:  DATA 75,6C
0614:  DATA 65,20
0616:  DATA 53,49
0618:  DATA 4D,0A
061A:  DATA 0D,00
061C:  DATA 52,69
061E:  DATA 6E,67
0620:  DATA 69,6E
0622:  DATA 67,0A
0624:  DATA 0D,00
0626:  DATA 43,61
0628:  DATA 6C,6C
062A:  DATA 20,69
062C:  DATA 6E,20
062E:  DATA 70,72
0630:  DATA 6F,67
0632:  DATA 72,65
0634:  DATA 73,73
0636:  DATA 0A,0D
0638:  DATA 00,00
063A:  DATA 0A,0D
063C:  DATA 55,4E
063E:  DATA 44,45
0640:  DATA 52,2D
0642:  DATA 56,4F
0644:  DATA 4C,54
0646:  DATA 41,47
0648:  DATA 45,20
064A:  DATA 57,41
064C:  DATA 52,4E
064E:  DATA 4E,49
0650:  DATA 4E,47
0652:  DATA 0A,0D
0654:  DATA 00,00
0656:  DATA 0A,0D
0658:  DATA 4F,56
065A:  DATA 45,52
065C:  DATA 2D,56
065E:  DATA 4F,4C
0660:  DATA 54,41
0662:  DATA 47,45
0664:  DATA 20,50
0666:  DATA 4F,57
0668:  DATA 45,52
066A:  DATA 20,44
066C:  DATA 4F,57
066E:  DATA 4E,0A
0670:  DATA 0D,00
0672:  DATA 0D,0A
0674:  DATA 42,49
0676:  DATA 54,5F
0678:  DATA 54,72
067A:  DATA 61,63
067C:  DATA 6B,31
067E:  DATA 20,44
0680:  DATA 61,74
0682:  DATA 61,3A
0684:  DATA 0D,0A
0686:  DATA 00,00
0688:  DATA 0D,0A
068A:  DATA 42,49
068C:  DATA 54,5F
068E:  DATA 54,72
0690:  DATA 61,63
0692:  DATA 6B,32
0694:  DATA 20,44
0696:  DATA 61,74
0698:  DATA 61,3A
069A:  DATA 0D,0A
069C:  DATA 00,00
069E:  DATA 0D,0A
06A0:  DATA 53,61
06A2:  DATA 76,69
06A4:  DATA 6E,67
06A6:  DATA 20,43
06A8:  DATA 61,72
06AA:  DATA 64,20
06AC:  DATA 44,61
06AE:  DATA 74,61
06B0:  DATA 0D,0A
06B2:  DATA 00,00
06B4:  DATA 44,6F
06B6:  DATA 6E,65
06B8:  DATA 00,00
06BA:  DATA 0A,0D
06BC:  DATA 4B,65
06BE:  DATA 79,20
06C0:  DATA 72,65
06C2:  DATA 6C,65
06C4:  DATA 61,73
06C6:  DATA 65,0A
06C8:  DATA 0D,00
06CA:  DATA 57,61
06CC:  DATA 69,74
06CE:  DATA 69,6E
06D0:  DATA 67,20
06D2:  DATA 66,6F
06D4:  DATA 72,20
06D6:  DATA 50,49
06D8:  DATA 4E,20
06DA:  DATA 6E,75
06DC:  DATA 6D,62
06DE:  DATA 65,72
06E0:  DATA 00,00
06E2:  DATA 0D,0A
06E4:  DATA 63,6F
06E6:  DATA 75,6E
06E8:  DATA 74,62
06EA:  DATA 69,74
06EC:  DATA 5F,54
06EE:  DATA 31,3A
06F0:  DATA 25,6C
06F2:  DATA 75,0D
06F4:  DATA 0A,00
06F6:  DATA 0D,0A
06F8:  DATA 63,6F
06FA:  DATA 75,6E
06FC:  DATA 74,62
06FE:  DATA 69,74
0700:  DATA 5F,54
0702:  DATA 32,3A
0704:  DATA 25,6C
0706:  DATA 75,0D
0708:  DATA 0A,00
070A:  DATA 0D,0A
070C:  DATA 72,65
070E:  DATA 61,64
0710:  DATA 69,6E
0712:  DATA 67,20
0714:  DATA 65,72
0716:  DATA 72,6F
0718:  DATA 72,20
071A:  DATA 54,31
071C:  DATA 0D,0A
071E:  DATA 00,00
0720:  DATA 0D,0A
0722:  DATA 72,65
0724:  DATA 61,64
0726:  DATA 69,6E
0728:  DATA 67,20
072A:  DATA 65,72
072C:  DATA 72,6F
072E:  DATA 72,20
0730:  DATA 54,32
0732:  DATA 0D,0A
0734:  DATA 00,00
*
07A0:  TBLRD*+
07A2:  MOVF   FF5,F
07A4:  BZ    07BE
07A6:  MOVFF  FF6,ABE
07AA:  MOVFF  FF7,ABF
07AE:  MOVFF  FF5,ADF
07B2:  RCALL  075A
07B4:  MOVFF  ABE,FF6
07B8:  MOVFF  ABF,FF7
07BC:  BRA    07A0
07BE:  RETURN 0
*
1718:  TBLRD*+
171A:  MOVFF  FF6,AD4
171E:  MOVFF  FF7,AD5
1722:  MOVFF  FF5,ADF
1726:  CALL   075A
172A:  MOVFF  AD4,FF6
172E:  MOVFF  AD5,FF7
1732:  MOVLB  A
1734:  DECFSZ xD3,F
1736:  BRA    173A
1738:  BRA    173E
173A:  MOVLB  0
173C:  BRA    1718
173E:  MOVLB  0
1740:  RETURN 0
1742:  MOVFF  FEA,AC4
1746:  MOVFF  FE9,AC3
174A:  MOVLB  A
174C:  SWAPF  xBD,W
174E:  IORLW  F0
1750:  MOVWF  xBF
1752:  ADDWF  xBF,F
1754:  ADDLW  E2
1756:  MOVWF  xC0
1758:  ADDLW  32
175A:  MOVWF  xC2
175C:  MOVF   xBD,W
175E:  ANDLW  0F
1760:  ADDWF  xC0,F
1762:  ADDWF  xC0,F
1764:  ADDWF  xC2,F
1766:  ADDLW  E9
1768:  MOVWF  xC1
176A:  ADDWF  xC1,F
176C:  ADDWF  xC1,F
176E:  SWAPF  xBC,W
1770:  ANDLW  0F
1772:  ADDWF  xC1,F
1774:  ADDWF  xC2,F
1776:  RLCF   xC1,F
1778:  RLCF   xC2,F
177A:  COMF   xC2,F
177C:  RLCF   xC2,F
177E:  MOVF   xBC,W
1780:  ANDLW  0F
1782:  ADDWF  xC2,F
1784:  RLCF   xBF,F
1786:  MOVLW  07
1788:  MOVWF  xBE
178A:  MOVLW  0A
178C:  DECF   xC1,F
178E:  ADDWF  xC2,F
1790:  BNC   178C
1792:  DECF   xC0,F
1794:  ADDWF  xC1,F
1796:  BNC   1792
1798:  DECF   xBF,F
179A:  ADDWF  xC0,F
179C:  BNC   1798
179E:  DECF   xBE,F
17A0:  ADDWF  xBF,F
17A2:  BNC   179E
17A4:  MOVLW  0A
17A6:  MOVWF  FEA
17A8:  MOVLW  BE
17AA:  MOVWF  FE9
17AC:  MOVLW  07
17AE:  ANDWF  xC3,W
17B0:  BCF    xC3.6
17B2:  ADDWF  FE9,F
17B4:  MOVLW  00
17B6:  ADDWFC FEA,F
17B8:  MOVF   FE9,W
17BA:  SUBLW  C2
17BC:  BNZ   17C6
17BE:  MOVF   FEA,W
17C0:  SUBLW  0A
17C2:  BNZ   17C6
17C4:  BSF    xC3.6
17C6:  MOVF   FEF,W
17C8:  MOVWF  00
17CA:  BNZ   17DC
17CC:  BTFSC  xC3.6
17CE:  BRA    17DC
17D0:  BTFSC  xC3.4
17D2:  BRA    1800
17D4:  BTFSC  xC3.3
17D6:  BRA    17DC
17D8:  MOVLW  20
17DA:  BRA    17E2
17DC:  BSF    xC3.3
17DE:  BCF    xC3.4
17E0:  MOVLW  30
17E2:  ADDWF  00,F
17E4:  MOVFF  FEA,ABD
17E8:  MOVFF  FE9,ABC
17EC:  MOVFF  00,ADF
17F0:  MOVLB  0
17F2:  CALL   075A
17F6:  MOVFF  ABD,FEA
17FA:  MOVFF  ABC,FE9
17FE:  MOVLB  A
1800:  MOVF   FEE,W
1802:  BTFSS  xC3.6
1804:  BRA    17B8
1806:  MOVLB  0
1808:  RETURN 0
180A:  MOVLB  A
180C:  MOVF   xC6,W
180E:  CLRF   01
1810:  SUBWF  xC5,W
1812:  BC    181A
1814:  MOVFF  AC5,00
1818:  BRA    1832
181A:  CLRF   00
181C:  MOVLW  08
181E:  MOVWF  xC7
1820:  RLCF   xC5,F
1822:  RLCF   00,F
1824:  MOVF   xC6,W
1826:  SUBWF  00,W
1828:  BTFSC  FD8.0
182A:  MOVWF  00
182C:  RLCF   01,F
182E:  DECFSZ xC7,F
1830:  BRA    1820
1832:  MOVLB  0
1834:  RETURN 0
1836:  MOVLW  20
1838:  MOVLB  A
183A:  BTFSS  xC0.4
183C:  MOVLW  30
183E:  MOVWF  xC1
1840:  MOVFF  ABF,00
1844:  BTFSS  xBF.7
1846:  BRA    1858
1848:  COMF   00,F
184A:  INCF   00,F
184C:  MOVFF  00,ABF
1850:  MOVLW  2D
1852:  MOVWF  xC1
1854:  BSF    xC0.7
1856:  BSF    xC0.0
1858:  MOVF   01,W
185A:  MOVFF  ABF,AC5
185E:  MOVLW  64
1860:  MOVWF  xC6
1862:  MOVLB  0
1864:  RCALL  180A
1866:  MOVFF  00,ABF
186A:  MOVLW  30
186C:  ADDWF  01,W
186E:  MOVLB  A
1870:  MOVWF  xC2
1872:  MOVFF  ABF,AC5
1876:  MOVLW  0A
1878:  MOVWF  xC6
187A:  MOVLB  0
187C:  RCALL  180A
187E:  MOVLW  30
1880:  ADDWF  00,W
1882:  MOVLB  A
1884:  MOVWF  xC4
1886:  MOVLW  30
1888:  ADDWF  01,W
188A:  MOVWF  xC3
188C:  MOVFF  AC1,00
1890:  MOVLW  30
1892:  SUBWF  xC2,W
1894:  BZ    189E
1896:  BSF    xC0.1
1898:  BTFSC  xC0.7
189A:  BSF    xC0.2
189C:  BRA    18C2
189E:  MOVFF  AC1,AC2
18A2:  MOVLW  20
18A4:  MOVWF  xC1
18A6:  MOVLW  30
18A8:  SUBWF  xC3,W
18AA:  BZ    18B4
18AC:  BSF    xC0.0
18AE:  BTFSC  xC0.7
18B0:  BSF    xC0.1
18B2:  BRA    18C2
18B4:  BTFSS  FD8.2
18B6:  BSF    xC0.0
18B8:  BNZ   18C2
18BA:  MOVFF  AC2,AC3
18BE:  MOVLW  20
18C0:  MOVWF  xC2
18C2:  BTFSC  xC0.2
18C4:  BRA    18D0
18C6:  BTFSC  xC0.1
18C8:  BRA    18DA
18CA:  BTFSC  xC0.0
18CC:  BRA    18E4
18CE:  BRA    18EE
18D0:  MOVFF  AC1,ADF
18D4:  MOVLB  0
18D6:  CALL   075A
18DA:  MOVFF  AC2,ADF
18DE:  MOVLB  0
18E0:  CALL   075A
18E4:  MOVFF  AC3,ADF
18E8:  MOVLB  0
18EA:  CALL   075A
18EE:  MOVFF  AC4,ADF
18F2:  MOVLB  0
18F4:  CALL   075A
18F8:  RETURN 0
*
1D42:  DATA 0A,0D
1D44:  DATA 4B,65
1D46:  DATA 79,20
1D48:  DATA 72,65
1D4A:  DATA 6C,65
1D4C:  DATA 61,73
1D4E:  DATA 65,2E
1D50:  DATA 0A,0D
1D52:  DATA 00,00
1D54:  DATA 0A,0D
1D56:  DATA 4B,65
1D58:  DATA 79,20
1D5A:  DATA 70,72
1D5C:  DATA 65,73
1D5E:  DATA 73,2E
1D60:  DATA 0A,0D
1D62:  DATA 00,00
1D64:  DATA 0D,0A
1D66:  DATA 54,72
1D68:  DATA 61,63
1D6A:  DATA 6B,31
1D6C:  DATA 20,44
1D6E:  DATA 61,74
1D70:  DATA 61,3A
1D72:  DATA 0D,0A
1D74:  DATA 00,00
1D76:  DATA 0D,0A
1D78:  DATA 54,72
1D7A:  DATA 61,63
1D7C:  DATA 6B,32
1D7E:  DATA 20,44
1D80:  DATA 61,74
1D82:  DATA 61,3A
1D84:  DATA 0D,0A
1D86:  DATA 00,00
1D88:  DATA 74,72
1D8A:  DATA 61,6E
1D8C:  DATA 20,74
1D8E:  DATA 69,6D
1D90:  DATA 65,20
1D92:  DATA 3D,20
1D94:  DATA 25,64
1D96:  DATA 0A,0D
1D98:  DATA 00,00
1D9A:  DATA 4B,50
1D9C:  DATA 2D,3E
1D9E:  DATA 20,4B
1DA0:  DATA 65,79
1DA2:  DATA 70,72
1DA4:  DATA 65,73
1DA6:  DATA 73,20
1DA8:  DATA 6D,6F
1DAA:  DATA 64,65
1DAC:  DATA 20,73
1DAE:  DATA 65,74
1DB0:  DATA 74,69
1DB2:  DATA 6E,67
1DB4:  DATA 20,28
1DB6:  DATA 4F,6E
1DB8:  DATA 29,0A
1DBA:  DATA 0D,00
1DBC:  DATA 4B,50
1DBE:  DATA 2D,3E
1DC0:  DATA 20,4B
1DC2:  DATA 65,79
1DC4:  DATA 70,72
1DC6:  DATA 65,73
1DC8:  DATA 73,20
1DCA:  DATA 6D,6F
1DCC:  DATA 64,65
1DCE:  DATA 20,73
1DD0:  DATA 65,74
1DD2:  DATA 74,69
1DD4:  DATA 6E,67
1DD6:  DATA 20,28
1DD8:  DATA 4F,66
1DDA:  DATA 66,29
1DDC:  DATA 0A,0D
1DDE:  DATA 00,00
1DE0:  DATA 49,73
1DE2:  DATA 20,53
1DE4:  DATA 6C,61
1DE6:  DATA 76,65
1DE8:  DATA 20,6D
1DEA:  DATA 6F,64
1DEC:  DATA 65,0A
1DEE:  DATA 0D,00
1DF0:  DATA 49,73
1DF2:  DATA 20,4D
1DF4:  DATA 61,73
1DF6:  DATA 74,65
1DF8:  DATA 72,20
1DFA:  DATA 6D,6F
1DFC:  DATA 64,65
1DFE:  DATA 29,0A
1E00:  DATA 0D,00
1E02:  DATA 49,73
1E04:  DATA 20,34
1E06:  DATA 78,36
1E08:  DATA 20,6D
1E0A:  DATA 61,74
1E0C:  DATA 72,69
1E0E:  DATA 78,0A
1E10:  DATA 0D,00
1E12:  DATA 49,73
1E14:  DATA 20,34
1E16:  DATA 78,35
1E18:  DATA 20,6D
1E1A:  DATA 61,74
1E1C:  DATA 72,69
1E1E:  DATA 78,0A
1E20:  DATA 0D,00
1E22:  DATA 0D,0A
1E24:  DATA 54,72
1E26:  DATA 61,63
1E28:  DATA 6B,31
1E2A:  DATA 20,44
1E2C:  DATA 61,74
1E2E:  DATA 61,3A
1E30:  DATA 0D,0A
1E32:  DATA 00,00
1E34:  DATA 0D,0A
1E36:  DATA 54,72
1E38:  DATA 61,63
1E3A:  DATA 6B,32
1E3C:  DATA 20,44
1E3E:  DATA 61,74
1E40:  DATA 61,3A
1E42:  DATA 0D,0A
1E44:  DATA 00,00
1E46:  DATA 0D,0A
1E48:  DATA 50,49
1E4A:  DATA 4E,20
1E4C:  DATA 4E,75
1E4E:  DATA 6D,62
1E50:  DATA 65,72
1E52:  DATA 3A,0D
1E54:  DATA 0A,00
1E56:  DATA 46,4F
1E58:  DATA 52,4D
1E5A:  DATA 41,54
1E5C:  DATA 54,49
1E5E:  DATA 4E,47
1E60:  DATA 2E,2E
1E62:  DATA 2E,00
1E64:  DATA 20,65
1E66:  DATA 78,69
1E68:  DATA 74,0A
1E6A:  DATA 0D,00
1E6C:  DATA 46,4F
1E6E:  DATA 52,4D
1E70:  DATA 41,54
1E72:  DATA 54,49
1E74:  DATA 4E,47
1E76:  DATA 2E,2E
1E78:  DATA 2E,00
1E7A:  DATA 20,65
1E7C:  DATA 78,69
1E7E:  DATA 74,0A
1E80:  DATA 0D,00
1E82:  DATA 72,65
1E84:  DATA 73,65
1E86:  DATA 74,69
1E88:  DATA 6E,67
1E8A:  DATA 20,70
1E8C:  DATA 61,73
1E8E:  DATA 73,77
1E90:  DATA 6F,72
1E92:  DATA 64,2E
1E94:  DATA 2E,2E
1E96:  DATA 00,00
1E98:  DATA 20,65
1E9A:  DATA 78,69
1E9C:  DATA 74,0A
1E9E:  DATA 0D,00
1EA0:  DATA 4B,65
1EA2:  DATA 79,20
1EA4:  DATA 62,6F
1EA6:  DATA 61,72
1EA8:  DATA 64,20
1EAA:  DATA 74,65
1EAC:  DATA 73,74
1EAE:  DATA 69,6E
1EB0:  DATA 67,0A
1EB2:  DATA 0D,00
1EB4:  DATA 72,65
1EB6:  DATA 73,65
1EB8:  DATA 74,20
1EBA:  DATA 66,61
1EBC:  DATA 63,74
1EBE:  DATA 6F,72
1EC0:  DATA 79,0A
1EC2:  DATA 0D,00
1EC4:  DATA 20,65
1EC6:  DATA 78,69
1EC8:  DATA 74,0A
1ECA:  DATA 0D,00
1ECC:  DATA 4E,65
1ECE:  DATA 77,20
1ED0:  DATA 63,6F
1ED2:  DATA 6E,73
1ED4:  DATA 6F,6C
1ED6:  DATA 65,20
1ED8:  DATA 6E,61
1EDA:  DATA 6D,65
1EDC:  DATA 3E,00
1EDE:  DATA 20,4F
1EE0:  DATA 4B,0A
1EE2:  DATA 0D,00
1EE4:  DATA 5B,4D
1EE6:  DATA 5D,00
1EE8:  DATA 5B,53
1EEA:  DATA 5D,00
1EEC:  DATA 5B,61
1EEE:  DATA 75,74
1EF0:  DATA 6F,20
1EF2:  DATA 73,65
1EF4:  DATA 6E,64
1EF6:  DATA 69,6E
1EF8:  DATA 67,20
1EFA:  DATA 28,6F
1EFC:  DATA 66,66
1EFE:  DATA 29,5D
1F00:  DATA 00,00
1F02:  DATA 5B,61
1F04:  DATA 75,74
1F06:  DATA 6F,20
1F08:  DATA 73,65
1F0A:  DATA 6E,64
1F0C:  DATA 69,6E
1F0E:  DATA 67,20
1F10:  DATA 28,6F
1F12:  DATA 6E,29
1F14:  DATA 5D,00
1F16:  DATA 59,65
1F18:  DATA 61,72
1F1A:  DATA 3E,00
1F1C:  DATA 4D,6F
1F1E:  DATA 6E,74
1F20:  DATA 68,3E
1F22:  DATA 00,00
1F24:  DATA 44,61
1F26:  DATA 74,65
1F28:  DATA 3E,00
1F2A:  DATA 44,61
1F2C:  DATA 79,3E
1F2E:  DATA 00,00
1F30:  DATA 48,6F
1F32:  DATA 75,72
1F34:  DATA 3E,00
1F36:  DATA 4D,69
1F38:  DATA 6E,75
1F3A:  DATA 74,65
1F3C:  DATA 73,3E
1F3E:  DATA 00,00
1F40:  DATA 53,65
1F42:  DATA 63,6F
1F44:  DATA 6E,64
1F46:  DATA 73,3E
1F48:  DATA 00,00
1F4A:  DATA 50,72
1F4C:  DATA 65,73
1F4E:  DATA 73,20
1F50:  DATA 27,31
1F52:  DATA 27,20
1F54:  DATA 74,6F
1F56:  DATA 20,73
1F58:  DATA 65,6C
1F5A:  DATA 65,63
1F5C:  DATA 74,20
1F5E:  DATA 53,6C
1F60:  DATA 61,76
1F62:  DATA 65,72
1F64:  DATA 20,6D
1F66:  DATA 6F,64
1F68:  DATA 65,00
1F6A:  DATA 50,72
1F6C:  DATA 65,73
1F6E:  DATA 73,20
1F70:  DATA 27,30
1F72:  DATA 27,20
1F74:  DATA 74,6F
1F76:  DATA 20,73
1F78:  DATA 65,6C
1F7A:  DATA 65,63
1F7C:  DATA 74,20
1F7E:  DATA 4D,61
1F80:  DATA 73,74
1F82:  DATA 65,72
1F84:  DATA 20,6D
1F86:  DATA 6F,64
1F88:  DATA 65,00
1F8A:  DATA 50,72
1F8C:  DATA 65,73
1F8E:  DATA 73,20
1F90:  DATA 27,31
1F92:  DATA 27,20
1F94:  DATA 74,6F
1F96:  DATA 20,74
1F98:  DATA 75,72
1F9A:  DATA 6E,20
1F9C:  DATA 6F,6E
1F9E:  DATA 20,6B
1FA0:  DATA 65,70
1FA2:  DATA 72,65
1FA4:  DATA 73,73
1FA6:  DATA 00,00
1FA8:  DATA 50,72
1FAA:  DATA 65,73
1FAC:  DATA 73,20
1FAE:  DATA 27,30
1FB0:  DATA 27,20
1FB2:  DATA 74,6F
1FB4:  DATA 20,74
1FB6:  DATA 75,72
1FB8:  DATA 6E,20
1FBA:  DATA 6F,66
1FBC:  DATA 66,20
1FBE:  DATA 6B,65
1FC0:  DATA 70,72
1FC2:  DATA 65,73
1FC4:  DATA 73,00
1FC6:  DATA 49,6E
1FC8:  DATA 70,75
1FCA:  DATA 74,20
1FCC:  DATA 4E,75
1FCE:  DATA 6D,62
1FD0:  DATA 65,72
1FD2:  DATA 00,00
1FD4:  DATA 50,72
1FD6:  DATA 65,73
1FD8:  DATA 73,20
1FDA:  DATA 27,31
1FDC:  DATA 27,20
1FDE:  DATA 74,6F
1FE0:  DATA 20,73
1FE2:  DATA 65,6C
1FE4:  DATA 65,63
1FE6:  DATA 74,20
1FE8:  DATA 74,68
1FEA:  DATA 65,20
1FEC:  DATA 6E,65
1FEE:  DATA 77,20
1FF0:  DATA 6B,65
1FF2:  DATA 79,62
1FF4:  DATA 6F,61
1FF6:  DATA 72,64
1FF8:  DATA 00,00
1FFA:  DATA 50,72
1FFC:  DATA 65,73
1FFE:  DATA 73,20
2000:  DATA 27,30
2002:  DATA 27,20
2004:  DATA 74,6F
2006:  DATA 20,73
2008:  DATA 65,6C
200A:  DATA 65,63
200C:  DATA 74,20
200E:  DATA 74,68
2010:  DATA 65,20
2012:  DATA 6F,6C
2014:  DATA 64,20
2016:  DATA 6B,65
2018:  DATA 79,62
201A:  DATA 6F,61
201C:  DATA 72,64
201E:  DATA 00,00
2020:  DATA 0A,0D
2022:  DATA 49,6E
2024:  DATA 70,75
2026:  DATA 74,20
2028:  DATA 79,6F
202A:  DATA 75,72
202C:  DATA 20,6D
202E:  DATA 6F,62
2030:  DATA 69,6C
2032:  DATA 65,20
2034:  DATA 70,68
2036:  DATA 6F,6E
2038:  DATA 65,20
203A:  DATA 6E,75
203C:  DATA 6D,62
203E:  DATA 65,72
2040:  DATA 3A,00
2042:  DATA 0A,0D
2044:  DATA 64,6F
2046:  DATA 6E,65
2048:  DATA 0A,0D
204A:  DATA 00,00
204C:  DATA 50,72
204E:  DATA 65,73
2050:  DATA 73,20
2052:  DATA 27,31
2054:  DATA 27,20
2056:  DATA 74,6F
2058:  DATA 20,74
205A:  DATA 75,72
205C:  DATA 6E,20
205E:  DATA 6F,6E
2060:  DATA 20,41
2062:  DATA 75,74
2064:  DATA 6F,20
2066:  DATA 6D,6F
2068:  DATA 64,65
206A:  DATA 00,00
206C:  DATA 50,72
206E:  DATA 65,73
2070:  DATA 73,20
2072:  DATA 27,30
2074:  DATA 27,20
2076:  DATA 74,6F
2078:  DATA 20,74
207A:  DATA 75,72
207C:  DATA 6E,20
207E:  DATA 6F,66
2080:  DATA 66,20
2082:  DATA 41,75
2084:  DATA 74,6F
2086:  DATA 20,6D
2088:  DATA 6F,64
208A:  DATA 65,00
208C:  DATA 68,2D
208E:  DATA 3E,20
2090:  DATA 48,65
2092:  DATA 6C,70
2094:  DATA 0A,0D
2096:  DATA 00,00
2098:  DATA 73,63
209A:  DATA 2D,3E
209C:  DATA 20,53
209E:  DATA 65,74
20A0:  DATA 20,43
20A2:  DATA 6C,6F
20A4:  DATA 63,6B
20A6:  DATA 0A,0D
20A8:  DATA 00,00
20AA:  DATA 63,2D
20AC:  DATA 3E,20
20AE:  DATA 73,68
20B0:  DATA 6F,77
20B2:  DATA 20,43
20B4:  DATA 6C,6F
20B6:  DATA 63,6B
20B8:  DATA 0A,0D
20BA:  DATA 00,00
20BC:  DATA 70,61
20BE:  DATA 73,73
20C0:  DATA 77,6F
20C2:  DATA 72,64
20C4:  DATA 2D,3E
20C6:  DATA 20,63
20C8:  DATA 68,61
20CA:  DATA 6E,67
20CC:  DATA 69,6E
20CE:  DATA 67,20
20D0:  DATA 50,41
20D2:  DATA 53,53
20D4:  DATA 57,4F
20D6:  DATA 52,44
20D8:  DATA 0A,0D
20DA:  DATA 00,00
20DC:  DATA 6E,20
20DE:  DATA 2D,3E
20E0:  DATA 20,63
20E2:  DATA 68,61
20E4:  DATA 6E,67
20E6:  DATA 65,20
20E8:  DATA 63,6F
20EA:  DATA 6E,73
20EC:  DATA 6F,6C
20EE:  DATA 65,20
20F0:  DATA 4E,61
20F2:  DATA 6D,65
20F4:  DATA 0A,0D
20F6:  DATA 00,00
20F8:  DATA 66,2D
20FA:  DATA 3E,20
20FC:  DATA 46,6F
20FE:  DATA 72,6D
2100:  DATA 61,74
2102:  DATA 0A,0D
2104:  DATA 00,00
2106:  DATA 65,2D
2108:  DATA 3E,20
210A:  DATA 45,78
210C:  DATA 69,74
210E:  DATA 0A,0D
2110:  DATA 00,00
2112:  DATA 4D,53
2114:  DATA 2D,3E
2116:  DATA 20,4B
2118:  DATA 65,79
211A:  DATA 62,6F
211C:  DATA 61,72
211E:  DATA 64,20
2120:  DATA 6D,6F
2122:  DATA 64,65
2124:  DATA 20,73
2126:  DATA 65,74
2128:  DATA 74,69
212A:  DATA 6E,67
212C:  DATA 20,28
212E:  DATA 53,6C
2130:  DATA 61,76
2132:  DATA 65,2F
2134:  DATA 4D,61
2136:  DATA 73,74
2138:  DATA 65,72
213A:  DATA 29,0A
213C:  DATA 0D,00
213E:  DATA 4B,50
2140:  DATA 2D,3E
2142:  DATA 20,4B
2144:  DATA 65,79
2146:  DATA 70,72
2148:  DATA 65,73
214A:  DATA 73,20
214C:  DATA 6D,6F
214E:  DATA 64,65
2150:  DATA 20,73
2152:  DATA 65,74
2154:  DATA 74,69
2156:  DATA 6E,67
2158:  DATA 20,28
215A:  DATA 4F,6E
215C:  DATA 29,0A
215E:  DATA 0D,00
2160:  DATA 4B,50
2162:  DATA 2D,3E
2164:  DATA 20,4B
2166:  DATA 65,79
2168:  DATA 70,72
216A:  DATA 65,73
216C:  DATA 73,20
216E:  DATA 6D,6F
2170:  DATA 64,65
2172:  DATA 20,73
2174:  DATA 65,74
2176:  DATA 74,69
2178:  DATA 6E,67
217A:  DATA 20,28
217C:  DATA 4F,66
217E:  DATA 66,29
2180:  DATA 0A,0D
2182:  DATA 00,00
2184:  DATA 74,72
2186:  DATA 61,6E
2188:  DATA 20,74
218A:  DATA 69,6D
218C:  DATA 65,2D
218E:  DATA 3E,20
2190:  DATA 74,69
2192:  DATA 6D,65
2194:  DATA 20,6F
2196:  DATA 66,20
2198:  DATA 65,61
219A:  DATA 63,68
219C:  DATA 20,74
219E:  DATA 72,61
21A0:  DATA 6E,73
21A2:  DATA 61,63
21A4:  DATA 74,69
21A6:  DATA 6F,6E
21A8:  DATA 0A,0D
21AA:  DATA 00,00
21AC:  DATA 64,65
21AE:  DATA 62,75
21B0:  DATA 67,2D
21B2:  DATA 3E,20
21B4:  DATA 6F,6E
21B6:  DATA 2F,6F
21B8:  DATA 66,66
21BA:  DATA 20,64
21BC:  DATA 65,62
21BE:  DATA 75,67
21C0:  DATA 20,6D
21C2:  DATA 6F,64
21C4:  DATA 65,0A
21C6:  DATA 0D,00
21C8:  DATA 6B,6F
21CA:  DATA 66,6B
21CC:  DATA 62,20
21CE:  DATA 25,64
21D0:  DATA 20,2D
21D2:  DATA 3E,20
21D4:  DATA 73,65
21D6:  DATA 6C,65
21D8:  DATA 63,74
21DA:  DATA 20,6B
21DC:  DATA 69,6E
21DE:  DATA 64,20
21E0:  DATA 6F,66
21E2:  DATA 20,6B
21E4:  DATA 65,79
21E6:  DATA 62,6F
21E8:  DATA 61,72
21EA:  DATA 64,0A
21EC:  DATA 0D,00
21EE:  DATA 72,73
21F0:  DATA 66,61
21F2:  DATA 63,74
21F4:  DATA 2D,3E
21F6:  DATA 20,72
21F8:  DATA 65,73
21FA:  DATA 65,74
21FC:  DATA 20,66
21FE:  DATA 61,63
2200:  DATA 74,6F
2202:  DATA 72,79
2204:  DATA 0A,0D
2206:  DATA 00,00
2208:  DATA 63,66
220A:  DATA 20,6D
220C:  DATA 62,6E
220E:  DATA 2D,3E
2210:  DATA 20,63
2212:  DATA 68,61
2214:  DATA 6E,67
2216:  DATA 69,6E
2218:  DATA 67,20
221A:  DATA 74,61
221C:  DATA 72,67
221E:  DATA 65,74
2220:  DATA 20,6D
2222:  DATA 6F,62
2224:  DATA 69,6C
2226:  DATA 65,20
2228:  DATA 70,68
222A:  DATA 6F,6E
222C:  DATA 65,20
222E:  DATA 6E,75
2230:  DATA 6D,62
2232:  DATA 65,72
2234:  DATA 0A,0D
2236:  DATA 00,00
2238:  DATA 53,49
223A:  DATA 4D,39
223C:  DATA 30,30
223E:  DATA 61,75
2240:  DATA 74,6F
2242:  DATA 2D,3E
2244:  DATA 20,6F
2246:  DATA 6E,2F
2248:  DATA 6F,66
224A:  DATA 66,20
224C:  DATA 61,75
224E:  DATA 74,6F
2250:  DATA 20,73
2252:  DATA 65,6E
2254:  DATA 64,69
2256:  DATA 6E,67
2258:  DATA 20,6D
225A:  DATA 6F,64
225C:  DATA 65,0A
225E:  DATA 0D,00
2260:  DATA 6F,6C
2262:  DATA 64,20
2264:  DATA 70,61
2266:  DATA 73,73
2268:  DATA 77,6F
226A:  DATA 72,64
226C:  DATA 3A,00
226E:  DATA 0A,0D
2270:  DATA 6E,65
2272:  DATA 77,3A
2274:  DATA 00,00
2276:  DATA 0A,0D
2278:  DATA 61,67
227A:  DATA 61,69
227C:  DATA 6E,3A
227E:  DATA 00,00
2280:  DATA 0A,0D
2282:  DATA 4F,4B
2284:  DATA 0A,0D
2286:  DATA 00,00
2288:  DATA 0A,0D
228A:  DATA 45,52
228C:  DATA 52,0A
228E:  DATA 0D,00
2290:  DATA 20,58
2292:  DATA 0A,0D
2294:  DATA 00,00
2296:  DATA 50,72
2298:  DATA 65,73
229A:  DATA 73,20
229C:  DATA 27,31
229E:  DATA 27,20
22A0:  DATA 74,6F
22A2:  DATA 20,65
22A4:  DATA 6E,61
22A6:  DATA 62,6C
22A8:  DATA 65,20
22AA:  DATA 64,65
22AC:  DATA 62,75
22AE:  DATA 67,20
22B0:  DATA 6D,6F
22B2:  DATA 64,65
22B4:  DATA 00,00
22B6:  DATA 50,72
22B8:  DATA 65,73
22BA:  DATA 73,20
22BC:  DATA 27,30
22BE:  DATA 27,20
22C0:  DATA 74,6F
22C2:  DATA 20,64
22C4:  DATA 69,73
22C6:  DATA 61,62
22C8:  DATA 6C,65
22CA:  DATA 20,64
22CC:  DATA 65,62
22CE:  DATA 75,67
22D0:  DATA 20,6D
22D2:  DATA 6F,64
22D4:  DATA 65,00
*
238C:  DATA 4F,4B
238E:  DATA 0A,0D
2390:  DATA 00,00
2392:  DATA 0A,0D
2394:  DATA 44,65
2396:  DATA 76,69
2398:  DATA 63,65
239A:  DATA 20,77
239C:  DATA 69,6C
239E:  DATA 6C,20
23A0:  DATA 72,65
23A2:  DATA 73,65
23A4:  DATA 74,0A
23A6:  DATA 0D,00
*
2574:  ADDWF  FE8,W
2576:  CLRF   FF7
2578:  RLCF   FF7,F
257A:  ADDLW  8F
257C:  MOVWF  FF6
257E:  MOVLW  25
2580:  ADDWFC FF7,F
2582:  TBLRD*-
2584:  MOVF   FF5,W
2586:  MOVWF  FFA
2588:  TBLRD*
258A:  MOVF   FF5,W
258C:  MOVWF  FF9
258E:  DATA D2,23
2590:  DATA EA,23
2592:  DATA 02,24
2594:  DATA 1A,24
2596:  DATA 32,24
*
2680:  ADDWF  FE8,W
2682:  CLRF   FF7
2684:  RLCF   FF7,F
2686:  ADDLW  9B
2688:  MOVWF  FF6
268A:  MOVLW  26
268C:  ADDWFC FF7,F
268E:  TBLRD*-
2690:  MOVF   FF5,W
2692:  MOVWF  FFA
2694:  TBLRD*
2696:  MOVF   FF5,W
2698:  MOVWF  FF9
269A:  DATA BA,25
269C:  DATA DA,25
269E:  DATA FA,25
26A0:  DATA 1A,26
26A2:  DATA 3A,26
26A4:  DATA 5A,26
26A6:  BTFSC  FD8.1
26A8:  BRA    26B2
26AA:  MOVLW  0A
26AC:  MOVWF  FEA
26AE:  MOVLW  E7
26B0:  MOVWF  FE9
26B2:  CLRF   00
26B4:  CLRF   01
26B6:  CLRF   02
26B8:  CLRF   03
26BA:  MOVLB  A
26BC:  CLRF   xE7
26BE:  CLRF   xE8
26C0:  CLRF   xE9
26C2:  CLRF   xEA
26C4:  MOVF   xE6,W
26C6:  IORWF  xE5,W
26C8:  IORWF  xE4,W
26CA:  IORWF  xE3,W
26CC:  BZ    2726
26CE:  MOVLW  20
26D0:  MOVWF  xEB
26D2:  BCF    FD8.0
26D4:  RLCF   xDF,F
26D6:  RLCF   xE0,F
26D8:  RLCF   xE1,F
26DA:  RLCF   xE2,F
26DC:  RLCF   xE7,F
26DE:  RLCF   xE8,F
26E0:  RLCF   xE9,F
26E2:  RLCF   xEA,F
26E4:  MOVF   xE6,W
26E6:  SUBWF  xEA,W
26E8:  BNZ   26FA
26EA:  MOVF   xE5,W
26EC:  SUBWF  xE9,W
26EE:  BNZ   26FA
26F0:  MOVF   xE4,W
26F2:  SUBWF  xE8,W
26F4:  BNZ   26FA
26F6:  MOVF   xE3,W
26F8:  SUBWF  xE7,W
26FA:  BNC   271A
26FC:  MOVF   xE3,W
26FE:  SUBWF  xE7,F
2700:  MOVF   xE4,W
2702:  BTFSS  FD8.0
2704:  INCFSZ xE4,W
2706:  SUBWF  xE8,F
2708:  MOVF   xE5,W
270A:  BTFSS  FD8.0
270C:  INCFSZ xE5,W
270E:  SUBWF  xE9,F
2710:  MOVF   xE6,W
2712:  BTFSS  FD8.0
2714:  INCFSZ xE6,W
2716:  SUBWF  xEA,F
2718:  BSF    FD8.0
271A:  RLCF   00,F
271C:  RLCF   01,F
271E:  RLCF   02,F
2720:  RLCF   03,F
2722:  DECFSZ xEB,F
2724:  BRA    26D2
2726:  MOVFF  AE7,FEF
272A:  MOVFF  AE8,FEC
272E:  MOVFF  AE9,FEC
2732:  MOVFF  AEA,FEC
2736:  MOVLB  0
2738:  RETURN 0
273A:  MOVF   FE9,W
273C:  MOVLB  A
273E:  MOVWF  xD7
2740:  MOVLW  3B
2742:  MOVWF  xDE
2744:  MOVLW  9A
2746:  MOVWF  xDD
2748:  MOVLW  CA
274A:  MOVWF  xDC
274C:  CLRF   xDB
274E:  MOVLW  0A
2750:  MOVWF  xD9
2752:  BSF    FD8.1
2754:  MOVLW  0A
2756:  MOVWF  FEA
2758:  MOVLW  D3
275A:  MOVWF  FE9
275C:  MOVFF  AD6,AE2
2760:  MOVFF  AD5,AE1
2764:  MOVFF  AD4,AE0
2768:  MOVFF  AD3,ADF
276C:  MOVFF  ADE,AE6
2770:  MOVFF  ADD,AE5
2774:  MOVFF  ADC,AE4
2778:  MOVFF  ADB,AE3
277C:  MOVLB  0
277E:  RCALL  26A6
2780:  MOVF   01,W
2782:  MOVF   00,F
2784:  BNZ   27AC
2786:  MOVLB  A
2788:  MOVF   xD9,W
278A:  XORLW  01
278C:  BTFSS  FD8.2
278E:  BRA    2794
2790:  MOVLB  0
2792:  BRA    27AC
2794:  MOVF   xD7,W
2796:  BZ    27B0
2798:  ANDLW  0F
279A:  SUBWF  xD9,W
279C:  BZ    27A0
279E:  BC    27C0
27A0:  BTFSC  xD7.7
27A2:  BRA    27C0
27A4:  BTFSC  xD7.6
27A6:  BRA    27B0
27A8:  MOVLW  20
27AA:  BRA    27B2
27AC:  MOVLB  A
27AE:  CLRF   xD7
27B0:  MOVLW  30
27B2:  ADDWF  00,F
27B4:  MOVFF  00,ADF
27B8:  MOVLB  0
27BA:  CALL   075A
27BE:  MOVLB  A
27C0:  BCF    FD8.1
27C2:  MOVFF  ADE,AE2
27C6:  MOVFF  ADD,AE1
27CA:  MOVFF  ADC,AE0
27CE:  MOVFF  ADB,ADF
27D2:  CLRF   xE6
27D4:  CLRF   xE5
27D6:  CLRF   xE4
27D8:  MOVLW  0A
27DA:  MOVWF  xE3
27DC:  MOVLB  0
27DE:  RCALL  26A6
27E0:  MOVFF  03,ADE
27E4:  MOVFF  02,ADD
27E8:  MOVFF  01,ADC
27EC:  MOVFF  00,ADB
27F0:  MOVLB  A
27F2:  DECFSZ xD9,F
27F4:  BRA    2752
27F6:  MOVLB  0
27F8:  RETURN 0
*
3A52:  MOVLB  A
3A54:  MOVF   xBB,W
3A56:  MULWF  xBD
3A58:  MOVFF  FF3,01
3A5C:  MOVFF  FF4,00
3A60:  MULWF  xBE
3A62:  MOVF   FF3,W
3A64:  ADDWF  00,F
3A66:  MOVF   xBC,W
3A68:  MULWF  xBD
3A6A:  MOVF   FF3,W
3A6C:  ADDWFC 00,W
3A6E:  MOVWF  02
3A70:  MOVLB  0
3A72:  RETURN 0
*
4476:  TSTFSZ 01
4478:  BRA    4480
447A:  TSTFSZ 02
447C:  BRA    4482
447E:  BRA    448E
4480:  INCF   02,F
4482:  MOVFF  00,FEE
4486:  DECFSZ 01,F
4488:  BRA    4482
448A:  DECFSZ 02,F
448C:  BRA    4482
448E:  RETURN 0
*
461E:  MOVFF  FEA,ABE
4622:  MOVFF  FE9,ABD
4626:  MOVLB  A
4628:  BTFSS  xB7.7
462A:  BRA    463C
462C:  BSF    xBD.7
462E:  BTFSS  xBD.4
4630:  INCF   xBD,F
4632:  COMF   xB6,F
4634:  COMF   xB7,F
4636:  INCF   xB6,F
4638:  BTFSC  FD8.2
463A:  INCF   xB7,F
463C:  SWAPF  xB7,W
463E:  IORLW  F0
4640:  MOVWF  xB9
4642:  ADDWF  xB9,F
4644:  ADDLW  E2
4646:  MOVWF  xBA
4648:  ADDLW  32
464A:  MOVWF  xBC
464C:  MOVF   xB7,W
464E:  ANDLW  0F
4650:  ADDWF  xBA,F
4652:  ADDWF  xBA,F
4654:  ADDWF  xBC,F
4656:  ADDLW  E9
4658:  MOVWF  xBB
465A:  ADDWF  xBB,F
465C:  ADDWF  xBB,F
465E:  SWAPF  xB6,W
4660:  ANDLW  0F
4662:  ADDWF  xBB,F
4664:  ADDWF  xBC,F
4666:  RLCF   xBB,F
4668:  RLCF   xBC,F
466A:  COMF   xBC,F
466C:  RLCF   xBC,F
466E:  MOVF   xB6,W
4670:  ANDLW  0F
4672:  ADDWF  xBC,F
4674:  RLCF   xB9,F
4676:  MOVLW  07
4678:  MOVWF  xB8
467A:  MOVLW  0A
467C:  DECF   xBB,F
467E:  ADDWF  xBC,F
4680:  BNC   467C
4682:  DECF   xBA,F
4684:  ADDWF  xBB,F
4686:  BNC   4682
4688:  DECF   xB9,F
468A:  ADDWF  xBA,F
468C:  BNC   4688
468E:  DECF   xB8,F
4690:  ADDWF  xB9,F
4692:  BNC   468E
4694:  MOVLW  0A
4696:  MOVWF  FEA
4698:  MOVLW  B8
469A:  MOVWF  FE9
469C:  MOVLW  07
469E:  ANDWF  xBD,W
46A0:  BCF    xBD.6
46A2:  MOVF   FED,F
46A4:  ANDWF  xBD,W
46A6:  BNZ   46B6
46A8:  BTFSC  xBD.4
46AA:  MOVF   FEE,F
46AC:  BTFSC  xBD.4
46AE:  BRA    46B6
46B0:  MOVLW  20
46B2:  MOVWF  00
46B4:  BRA    46F8
46B6:  ADDWF  FE9,F
46B8:  MOVLW  00
46BA:  ADDWFC FEA,F
46BC:  MOVF   FE9,W
46BE:  SUBLW  BC
46C0:  BNZ   46CA
46C2:  MOVF   FEA,W
46C4:  SUBLW  0A
46C6:  BNZ   46CA
46C8:  BSF    xBD.6
46CA:  MOVF   FEF,W
46CC:  MOVWF  00
46CE:  BNZ   46E0
46D0:  BTFSC  xBD.6
46D2:  BRA    46E0
46D4:  BTFSC  xBD.4
46D6:  BRA    4714
46D8:  BTFSC  xBD.3
46DA:  BRA    46E0
46DC:  MOVLW  20
46DE:  BRA    46F6
46E0:  BTFSS  xBD.7
46E2:  BRA    46F0
46E4:  MOVLW  2D
46E6:  MOVWF  00
46E8:  MOVF   FED,W
46EA:  BCF    xBD.6
46EC:  BCF    xBD.7
46EE:  BRA    46F8
46F0:  BSF    xBD.3
46F2:  BCF    xBD.4
46F4:  MOVLW  30
46F6:  ADDWF  00,F
46F8:  MOVFF  FEA,AB7
46FC:  MOVFF  FE9,AB6
4700:  MOVFF  00,ADF
4704:  MOVLB  0
4706:  CALL   075A
470A:  MOVFF  AB7,FEA
470E:  MOVFF  AB6,FE9
4712:  MOVLB  A
4714:  MOVF   FEE,W
4716:  BTFSS  xBD.6
4718:  BRA    46BC
471A:  MOVLB  0
471C:  GOTO   4920 (RETURN)
*
4956:  DATA 0A,0D
4958:  DATA 4B,65
495A:  DATA 79,20
495C:  DATA 72,65
495E:  DATA 6C,65
4960:  DATA 61,73
4962:  DATA 65,0A
4964:  DATA 0D,00
4966:  DATA 0D,0A
4968:  DATA 46,75
496A:  DATA 6C,6C
496C:  DATA 20,6D
496E:  DATA 65,6D
4970:  DATA 6F,72
4972:  DATA 79,0D
4974:  DATA 0A,00
4976:  DATA 0D,0A
4978:  DATA 53,61
497A:  DATA 76,69
497C:  DATA 6E,67
497E:  DATA 20,50
4980:  DATA 49,4E
4982:  DATA 0D,0A
4984:  DATA 00,00
4986:  DATA 0D,0A
4988:  DATA 6E,65
498A:  DATA 78,74
498C:  DATA 20,74
498E:  DATA 72,61
4990:  DATA 6E,73
4992:  DATA 61,63
4994:  DATA 74,69
4996:  DATA 6F,6E
4998:  DATA 20,28
499A:  DATA 25,6C
499C:  DATA 64,29
499E:  DATA 0D,0A
49A0:  DATA 00,00
49A2:  DATA 0D,0A
49A4:  DATA 62,6F
49A6:  DATA 6F,74
49A8:  DATA 69,6E
49AA:  DATA 67,2E
49AC:  DATA 2E,2E
49AE:  DATA 0D,0A
49B0:  DATA 00,00
49B2:  DATA 41,54
49B4:  DATA 0D,0A
49B6:  DATA 00,00
49B8:  DATA 41,54
49BA:  DATA 2B,43
49BC:  DATA 4D,47
49BE:  DATA 46,3D
49C0:  DATA 31,0D
49C2:  DATA 0A,00
49C4:  DATA 41,54
49C6:  DATA 2B,43
49C8:  DATA 53,4D
49CA:  DATA 50,3D
49CC:  DATA 31,37
49CE:  DATA 2C,31
49D0:  DATA 36,37
49D2:  DATA 2C,30
49D4:  DATA 2C,32
49D6:  DATA 34,35
49D8:  DATA 0D,0A
49DA:  DATA 00,00
49DC:  DATA 41,54
49DE:  DATA 2B,43
49E0:  DATA 4D,47
49E2:  DATA 44,3D
49E4:  DATA 31,0D
49E6:  DATA 0A,00
49E8:  DATA 41,54
49EA:  DATA 2B,43
49EC:  DATA 4D,47
49EE:  DATA 44,3D
49F0:  DATA 32,0D
49F2:  DATA 0A,00
49F4:  DATA 41,54
49F6:  DATA 2B,43
49F8:  DATA 4D,47
49FA:  DATA 44,3D
49FC:  DATA 33,0D
49FE:  DATA 0A,00
4A00:  DATA 41,54
4A02:  DATA 2B,43
4A04:  DATA 4D,47
4A06:  DATA 44,3D
4A08:  DATA 34,0D
4A0A:  DATA 0A,00
4A0C:  DATA 41,54
4A0E:  DATA 2B,43
4A10:  DATA 4D,47
4A12:  DATA 44,3D
4A14:  DATA 35,0D
4A16:  DATA 0A,00
4A18:  DATA 6E,65
4A1A:  DATA 77,20
4A1C:  DATA 6B,65
4A1E:  DATA 62,6F
4A20:  DATA 61,72
4A22:  DATA 64,20
4A24:  DATA 6D,6F
4A26:  DATA 64,65
4A28:  DATA 0A,0D
4A2A:  DATA 00,00
4A2C:  DATA 4F,6C
4A2E:  DATA 64,20
4A30:  DATA 6B,65
4A32:  DATA 62,6F
4A34:  DATA 61,72
4A36:  DATA 64,20
4A38:  DATA 6D,6F
4A3A:  DATA 64,65
4A3C:  DATA 0A,0D
4A3E:  DATA 00,00
4A40:  DATA 53,6C
4A42:  DATA 61,76
4A44:  DATA 65,72
4A46:  DATA 20,6D
4A48:  DATA 6F,64
4A4A:  DATA 65,20
4A4C:  DATA 69,73
4A4E:  DATA 20,64
4A50:  DATA 69,73
4A52:  DATA 61,62
4A54:  DATA 6C,65
4A56:  DATA 0A,0D
4A58:  DATA 00,00
4A5A:  DATA 53,6C
4A5C:  DATA 61,76
4A5E:  DATA 65,72
4A60:  DATA 20,6D
4A62:  DATA 6F,64
4A64:  DATA 65,20
4A66:  DATA 69,73
4A68:  DATA 20,65
4A6A:  DATA 6E,61
4A6C:  DATA 62,6C
4A6E:  DATA 65,0A
4A70:  DATA 0D,00
4A72:  DATA 74,77
4A74:  DATA 6F,20
4A76:  DATA 6E,75
4A78:  DATA 6D,62
4A7A:  DATA 65,72
4A7C:  DATA 73,20
4A7E:  DATA 6D,6F
4A80:  DATA 64,65
4A82:  DATA 20,76
4A84:  DATA 65,72
4A86:  DATA 0A,0D
4A88:  DATA 00,00
4A8A:  DATA 61,75
4A8C:  DATA 74,6F
4A8E:  DATA 73,65
4A90:  DATA 6E,64
4A92:  DATA 69,6E
4A94:  DATA 67,20
4A96:  DATA 69,73
4A98:  DATA 20,64
4A9A:  DATA 69,73
4A9C:  DATA 61,62
4A9E:  DATA 6C,65
4AA0:  DATA 0A,0D
4AA2:  DATA 00,00
4AA4:  DATA 61,75
4AA6:  DATA 74,6F
4AA8:  DATA 73,65
4AAA:  DATA 6E,64
4AAC:  DATA 69,6E
4AAE:  DATA 67,20
4AB0:  DATA 69,73
4AB2:  DATA 20,65
4AB4:  DATA 6E,61
4AB6:  DATA 62,6C
4AB8:  DATA 65,0A
4ABA:  DATA 0D,00
4ABC:  DATA 41,54
4ABE:  DATA 2B,43
4AC0:  DATA 4D,47
4AC2:  DATA 46,3D
4AC4:  DATA 31,0D
4AC6:  DATA 0A,00
4AC8:  DATA 72,65
4ACA:  DATA 61,64
4ACC:  DATA 69,6E
4ACE:  DATA 67,5F
4AD0:  DATA 73,6D
4AD2:  DATA 73,2E
4AD4:  DATA 2E,2E
4AD6:  DATA 0A,0D
4AD8:  DATA 00,00
4ADA:  DATA 41,54
4ADC:  DATA 2B,43
4ADE:  DATA 4D,47
4AE0:  DATA 52,3D
4AE2:  DATA 31,0D
4AE4:  DATA 0A,00
4AE6:  DATA 4D,53
4AE8:  DATA 47,5F
4AEA:  DATA 61,76
4AEC:  DATA 61,69
4AEE:  DATA 2E,2E
4AF0:  DATA 2E,25
4AF2:  DATA 64,0A
4AF4:  DATA 0D,00
4AF6:  DATA 61,6E
4AF8:  DATA 61,6C
4AFA:  DATA 79,7A
4AFC:  DATA 65,5F
4AFE:  DATA 73,6D
4B00:  DATA 73,2E
4B02:  DATA 2E,2E
4B04:  DATA 0A,0D
4B06:  DATA 00,00
4B08:  DATA 74,68
4B0A:  DATA 65,20
4B0C:  DATA 73,69
4B0E:  DATA 67,6E
4B10:  DATA 61,6C
4B12:  DATA 20,69
4B14:  DATA 73,20
4B16:  DATA 6E,6F
4B18:  DATA 74,20
4B1A:  DATA 67,6F
4B1C:  DATA 6F,64
4B1E:  DATA 2C,20
4B20:  DATA 64,65
4B22:  DATA 76,69
4B24:  DATA 63,65
4B26:  DATA 20,77
4B28:  DATA 69,6C
4B2A:  DATA 6C,20
4B2C:  DATA 72,65
4B2E:  DATA 62,6F
4B30:  DATA 6F,74
4B32:  DATA 0A,0D
4B34:  DATA 00,00
4B36:  DATA 0A,0D
4B38:  DATA 63,68
4B3A:  DATA 65,63
4B3C:  DATA 6B,69
4B3E:  DATA 6E,67
4B40:  DATA 20,74
4B42:  DATA 68,65
4B44:  DATA 20,66
4B46:  DATA 69,72
4B48:  DATA 73,74
4B4A:  DATA 20,6E
4B4C:  DATA 75,6D
4B4E:  DATA 62,65
4B50:  DATA 72,0A
4B52:  DATA 0D,00
4B54:  DATA 0A,0D
4B56:  DATA 4D,6F
4B58:  DATA 62,69
4B5A:  DATA 6C,65
4B5C:  DATA 20,70
4B5E:  DATA 68,6F
4B60:  DATA 6E,65
4B62:  DATA 20,6E
4B64:  DATA 75,6D
4B66:  DATA 62,65
4B68:  DATA 72,20
4B6A:  DATA 69,73
4B6C:  DATA 20,00
4B6E:  DATA 0A,0D
4B70:  DATA 4D,53
4B72:  DATA 47,3A
4B74:  DATA 20,00
4B76:  DATA 0A,0D
4B78:  DATA 54,49
4B7A:  DATA 4D,45
4B7C:  DATA 3A,20
4B7E:  DATA 00,00
4B80:  DATA 0A,0D
4B82:  DATA 72,65
4B84:  DATA 73,65
4B86:  DATA 74,20
4B88:  DATA 74,68
4B8A:  DATA 65,20
4B8C:  DATA 70,61
4B8E:  DATA 73,73
4B90:  DATA 77,6F
4B92:  DATA 72,64
4B94:  DATA 0A,0D
4B96:  DATA 00,00
4B98:  DATA 64,6F
4B9A:  DATA 6E,65
4B9C:  DATA 0A,0D
4B9E:  DATA 00,00
4BA0:  DATA 0A,0D
4BA2:  DATA 63,68
4BA4:  DATA 65,63
4BA6:  DATA 6B,69
4BA8:  DATA 6E,67
4BAA:  DATA 20,70
4BAC:  DATA 68,6F
4BAE:  DATA 6E,65
4BB0:  DATA 20,6E
4BB2:  DATA 75,6D
4BB4:  DATA 62,65
4BB6:  DATA 72,20
4BB8:  DATA 69,73
4BBA:  DATA 20,64
4BBC:  DATA 6F,6E
4BBE:  DATA 65,0A
4BC0:  DATA 0D,00
4BC2:  DATA 0A,0D
4BC4:  DATA 63,6F
4BC6:  DATA 6E,66
4BC8:  DATA 69,67
4BCA:  DATA 75,72
4BCC:  DATA 65,64
4BCE:  DATA 20,6D
4BD0:  DATA 6F,62
4BD2:  DATA 69,6C
4BD4:  DATA 65,20
4BD6:  DATA 70,68
4BD8:  DATA 6F,6E
4BDA:  DATA 65,20
4BDC:  DATA 6E,75
4BDE:  DATA 6D,62
4BE0:  DATA 65,72
4BE2:  DATA 0A,0D
4BE4:  DATA 00,00
4BE6:  DATA 63,68
4BE8:  DATA 61,6E
4BEA:  DATA 67,65
4BEC:  DATA 64,20
4BEE:  DATA 70,68
4BF0:  DATA 6F,6E
4BF2:  DATA 65,20
4BF4:  DATA 6E,75
4BF6:  DATA 6D,62
4BF8:  DATA 65,72
4BFA:  DATA 0A,0D
4BFC:  DATA 28,00
4BFE:  DATA 29,0A
4C00:  DATA 0D,00
4C02:  DATA 77,72
4C04:  DATA 6F,6E
4C06:  DATA 67,20
4C08:  DATA 70,61
4C0A:  DATA 73,73
4C0C:  DATA 77,6F
4C0E:  DATA 72,64
4C10:  DATA 0A,0D
4C12:  DATA 00,00
4C14:  DATA 0A,0D
4C16:  DATA 63,68
4C18:  DATA 65,63
4C1A:  DATA 6B,69
4C1C:  DATA 6E,67
4C1E:  DATA 20,74
4C20:  DATA 68,65
4C22:  DATA 20,73
4C24:  DATA 65,63
4C26:  DATA 6F,6E
4C28:  DATA 64,20
4C2A:  DATA 6E,75
4C2C:  DATA 6D,62
4C2E:  DATA 65,72
4C30:  DATA 0A,0D
4C32:  DATA 00,00
4C34:  DATA 0A,0D
4C36:  DATA 4D,6F
4C38:  DATA 62,69
4C3A:  DATA 6C,65
4C3C:  DATA 20,70
4C3E:  DATA 68,6F
4C40:  DATA 6E,65
4C42:  DATA 20,6E
4C44:  DATA 75,6D
4C46:  DATA 62,65
4C48:  DATA 72,20
4C4A:  DATA 69,73
4C4C:  DATA 20,00
4C4E:  DATA 0A,0D
4C50:  DATA 4D,53
4C52:  DATA 47,3A
4C54:  DATA 20,00
4C56:  DATA 0A,0D
4C58:  DATA 54,49
4C5A:  DATA 4D,45
4C5C:  DATA 3A,20
4C5E:  DATA 00,00
4C60:  DATA 0A,0D
4C62:  DATA 63,68
4C64:  DATA 65,63
4C66:  DATA 6B,69
4C68:  DATA 6E,67
4C6A:  DATA 20,70
4C6C:  DATA 68,6F
4C6E:  DATA 6E,65
4C70:  DATA 20,6E
4C72:  DATA 75,6D
4C74:  DATA 62,65
4C76:  DATA 72,20
4C78:  DATA 69,73
4C7A:  DATA 20,64
4C7C:  DATA 6F,6E
4C7E:  DATA 65,0A
4C80:  DATA 0D,00
4C82:  DATA 0A,0D
4C84:  DATA 63,6F
4C86:  DATA 6E,66
4C88:  DATA 69,67
4C8A:  DATA 75,72
4C8C:  DATA 65,64
4C8E:  DATA 20,6D
4C90:  DATA 6F,62
4C92:  DATA 69,6C
4C94:  DATA 65,20
4C96:  DATA 70,68
4C98:  DATA 6F,6E
4C9A:  DATA 65,20
4C9C:  DATA 6E,75
4C9E:  DATA 6D,62
4CA0:  DATA 65,72
4CA2:  DATA 0A,0D
4CA4:  DATA 00,00
4CA6:  DATA 63,68
4CA8:  DATA 61,6E
4CAA:  DATA 67,65
4CAC:  DATA 64,20
4CAE:  DATA 70,68
4CB0:  DATA 6F,6E
4CB2:  DATA 65,20
4CB4:  DATA 6E,75
4CB6:  DATA 6D,62
4CB8:  DATA 65,72
4CBA:  DATA 0A,0D
4CBC:  DATA 28,00
4CBE:  DATA 29,0A
4CC0:  DATA 0D,00
4CC2:  DATA 77,72
4CC4:  DATA 6F,6E
4CC6:  DATA 67,20
4CC8:  DATA 70,61
4CCA:  DATA 73,73
4CCC:  DATA 77,6F
4CCE:  DATA 72,64
4CD0:  DATA 0A,0D
4CD2:  DATA 00,00
4CD4:  DATA 0A,0D
4CD6:  DATA 20,74
4CD8:  DATA 68,69
4CDA:  DATA 73,20
4CDC:  DATA 70,68
4CDE:  DATA 6F,6E
4CE0:  DATA 65,20
4CE2:  DATA 75,6E
4CE4:  DATA 61,62
4CE6:  DATA 6C,65
4CE8:  DATA 20,74
4CEA:  DATA 6F,20
4CEC:  DATA 73,65
4CEE:  DATA 6E,64
4CF0:  DATA 20,63
4CF2:  DATA 6F,6D
4CF4:  DATA 6D,61
4CF6:  DATA 6E,64
4CF8:  DATA 73,20
4CFA:  DATA 0A,0D
4CFC:  DATA 00,00
4CFE:  DATA 63,68
4D00:  DATA 61,6E
4D02:  DATA 67,65
4D04:  DATA 64,20
4D06:  DATA 74,68
4D08:  DATA 65,20
4D0A:  DATA 70,61
4D0C:  DATA 73,73
4D0E:  DATA 77,6F
4D10:  DATA 72,64
4D12:  DATA 0A,0D
4D14:  DATA 00,00
4D16:  DATA 0A,0D
4D18:  DATA 65,78
4D1A:  DATA 69,74
4D1C:  DATA 0A,0D
4D1E:  DATA 00,00
4D20:  DATA 0A,0D
4D22:  DATA 6B,65
4D24:  DATA 79,70
4D26:  DATA 72,65
4D28:  DATA 73,73
4D2A:  DATA 20,74
4D2C:  DATA 75,72
4D2E:  DATA 6E,20
4D30:  DATA 6F,6E
4D32:  DATA 0A,0D
4D34:  DATA 00,00
4D36:  DATA 20,65
4D38:  DATA 78,69
4D3A:  DATA 74,0A
4D3C:  DATA 0D,00
4D3E:  DATA 0A,0D
4D40:  DATA 6B,65
4D42:  DATA 79,70
4D44:  DATA 72,65
4D46:  DATA 73,73
4D48:  DATA 20,74
4D4A:  DATA 75,72
4D4C:  DATA 6E,20
4D4E:  DATA 6F,66
4D50:  DATA 66,0A
4D52:  DATA 0D,00
4D54:  DATA 20,65
4D56:  DATA 78,69
4D58:  DATA 74,0A
4D5A:  DATA 0D,00
4D5C:  DATA 0A,0D
4D5E:  DATA 70,6C
4D60:  DATA 65,61
4D62:  DATA 73,65
4D64:  DATA 20,63
4D66:  DATA 68,65
4D68:  DATA 63,6B
4D6A:  DATA 20,79
4D6C:  DATA 6F,75
4D6E:  DATA 72,20
4D70:  DATA 73,79
4D72:  DATA 6E,74
4D74:  DATA 61,78
4D76:  DATA 0A,0D
4D78:  DATA 00,00
4D7A:  DATA 0A,0D
4D7C:  DATA 6D,61
4D7E:  DATA 73,74
4D80:  DATA 65,72
4D82:  DATA 20,6D
4D84:  DATA 6F,64
4D86:  DATA 65,20
4D88:  DATA 74,75
4D8A:  DATA 72,6E
4D8C:  DATA 20,6F
4D8E:  DATA 6E,0A
4D90:  DATA 0D,00
4D92:  DATA 20,65
4D94:  DATA 78,69
4D96:  DATA 74,0A
4D98:  DATA 0D,00
4D9A:  DATA 0A,0D
4D9C:  DATA 6D,61
4D9E:  DATA 73,74
4DA0:  DATA 65,72
4DA2:  DATA 20,6D
4DA4:  DATA 6F,64
4DA6:  DATA 65,20
4DA8:  DATA 74,75
4DAA:  DATA 72,6E
4DAC:  DATA 20,6F
4DAE:  DATA 66,66
4DB0:  DATA 0A,0D
4DB2:  DATA 00,00
4DB4:  DATA 20,65
4DB6:  DATA 78,69
4DB8:  DATA 74,0A
4DBA:  DATA 0D,00
4DBC:  DATA 0A,0D
4DBE:  DATA 70,6C
4DC0:  DATA 65,61
4DC2:  DATA 73,65
4DC4:  DATA 20,63
4DC6:  DATA 68,65
4DC8:  DATA 63,6B
4DCA:  DATA 20,79
4DCC:  DATA 6F,75
4DCE:  DATA 72,20
4DD0:  DATA 73,79
4DD2:  DATA 6E,74
4DD4:  DATA 61,78
4DD6:  DATA 0A,0D
4DD8:  DATA 00,00
4DDA:  DATA 72,65
4DDC:  DATA 73,65
4DDE:  DATA 74,20
4DE0:  DATA 66,61
4DE2:  DATA 63,74
4DE4:  DATA 6F,72
4DE6:  DATA 79,0A
4DE8:  DATA 0D,00
4DEA:  DATA 63,68
4DEC:  DATA 61,6E
4DEE:  DATA 67,65
4DF0:  DATA 64,20
4DF2:  DATA 74,6F
4DF4:  DATA 20,6E
4DF6:  DATA 65,77
4DF8:  DATA 20,6B
4DFA:  DATA 65,79
4DFC:  DATA 62,6F
4DFE:  DATA 61,72
4E00:  DATA 64,0A
4E02:  DATA 0D,00
4E04:  DATA 63,68
4E06:  DATA 61,6E
4E08:  DATA 67,65
4E0A:  DATA 64,20
4E0C:  DATA 74,6F
4E0E:  DATA 20,6F
4E10:  DATA 6C,64
4E12:  DATA 20,6B
4E14:  DATA 65,79
4E16:  DATA 62,6F
4E18:  DATA 61,72
4E1A:  DATA 64,0A
4E1C:  DATA 0D,00
4E1E:  DATA 74,72
4E20:  DATA 61,6E
4E22:  DATA 20,74
4E24:  DATA 69,6D
4E26:  DATA 65,20
4E28:  DATA 3D,20
4E2A:  DATA 25,64
4E2C:  DATA 0A,0D
4E2E:  DATA 00,00
4E30:  DATA 0A,0D
4E32:  DATA 70,6C
4E34:  DATA 65,61
4E36:  DATA 73,65
4E38:  DATA 20,63
4E3A:  DATA 68,65
4E3C:  DATA 63,6B
4E3E:  DATA 20,79
4E40:  DATA 6F,75
4E42:  DATA 72,20
4E44:  DATA 73,79
4E46:  DATA 6E,74
4E48:  DATA 61,78
4E4A:  DATA 0A,0D
4E4C:  DATA 00,00
4E4E:  DATA 0A,0D
4E50:  DATA 61,75
4E52:  DATA 74,6F
4E54:  DATA 73,65
4E56:  DATA 6E,64
4E58:  DATA 69,6E
4E5A:  DATA 67,20
4E5C:  DATA 74,75
4E5E:  DATA 72,6E
4E60:  DATA 20,6F
4E62:  DATA 6E,0A
4E64:  DATA 0D,00
4E66:  DATA 20,65
4E68:  DATA 78,69
4E6A:  DATA 74,0A
4E6C:  DATA 0D,00
4E6E:  DATA 0A,0D
4E70:  DATA 61,75
4E72:  DATA 74,6F
4E74:  DATA 73,65
4E76:  DATA 6E,64
4E78:  DATA 69,6E
4E7A:  DATA 67,20
4E7C:  DATA 74,75
4E7E:  DATA 72,6E
4E80:  DATA 20,6F
4E82:  DATA 66,66
4E84:  DATA 0A,0D
4E86:  DATA 00,00
4E88:  DATA 20,65
4E8A:  DATA 78,69
4E8C:  DATA 74,0A
4E8E:  DATA 0D,00
4E90:  DATA 0A,0D
4E92:  DATA 70,6C
4E94:  DATA 65,61
4E96:  DATA 73,65
4E98:  DATA 20,63
4E9A:  DATA 68,65
4E9C:  DATA 63,6B
4E9E:  DATA 20,79
4EA0:  DATA 6F,75
4EA2:  DATA 72,20
4EA4:  DATA 73,79
4EA6:  DATA 6E,74
4EA8:  DATA 61,78
4EAA:  DATA 0A,0D
4EAC:  DATA 00,00
4EAE:  DATA 46,4F
4EB0:  DATA 52,4D
4EB2:  DATA 41,54
4EB4:  DATA 54,49
4EB6:  DATA 4E,47
4EB8:  DATA 2E,2E
4EBA:  DATA 2E,00
4EBC:  DATA 20,65
4EBE:  DATA 78,69
4EC0:  DATA 74,0A
4EC2:  DATA 0D,00
4EC4:  DATA 46,4F
4EC6:  DATA 52,4D
4EC8:  DATA 41,54
4ECA:  DATA 54,49
4ECC:  DATA 4E,47
4ECE:  DATA 2E,2E
4ED0:  DATA 2E,00
4ED2:  DATA 20,65
4ED4:  DATA 78,69
4ED6:  DATA 74,0A
4ED8:  DATA 0D,00
4EDA:  DATA 64,65
4EDC:  DATA 76,69
4EDE:  DATA 63,65
4EE0:  DATA 20,68
4EE2:  DATA 61,73
4EE4:  DATA 20,25
4EE6:  DATA 6C,75
4EE8:  DATA 20,74
4EEA:  DATA 72,61
4EEC:  DATA 6E,73
4EEE:  DATA 61,63
4EF0:  DATA 74,69
4EF2:  DATA 6F,6E
4EF4:  DATA 20,0A
4EF6:  DATA 0D,00
4EF8:  DATA 64,6F
4EFA:  DATA 77,6E
4EFC:  DATA 6C,6F
4EFE:  DATA 61,64
4F00:  DATA 20,61
4F02:  DATA 6C,6C
4F04:  DATA 0A,0D
4F06:  DATA 00,00
4F08:  DATA 0A,0D
4F0A:  DATA 70,6C
4F0C:  DATA 65,61
4F0E:  DATA 73,65
4F10:  DATA 20,63
4F12:  DATA 68,65
4F14:  DATA 63,6B
4F16:  DATA 20,79
4F18:  DATA 6F,75
4F1A:  DATA 72,20
4F1C:  DATA 73,79
4F1E:  DATA 6E,74
4F20:  DATA 61,78
4F22:  DATA 0A,0D
4F24:  DATA 00,00
4F26:  DATA 64,65
4F28:  DATA 6C,65
4F2A:  DATA 74,65
4F2C:  DATA 5F,4D
4F2E:  DATA 53,47
4F30:  DATA 2E,2E
4F32:  DATA 2E,0A
4F34:  DATA 0D,00
4F36:  DATA 41,54
4F38:  DATA 2B,43
4F3A:  DATA 4D,47
4F3C:  DATA 44,3D
4F3E:  DATA 31,0D
4F40:  DATA 0A,00
4F42:  DATA 25,6C
4F44:  DATA 75,20
4F46:  DATA 63,68
4F48:  DATA 61,72
4F4A:  DATA 61,63
4F4C:  DATA 74,65
4F4E:  DATA 72,0A
4F50:  DATA 0D,00
4F52:  DATA 4D,53
4F54:  DATA 47,5F
4F56:  DATA 73,65
4F58:  DATA 6E,64
4F5A:  DATA 69,6E
4F5C:  DATA 67,20
4F5E:  DATA 25,64
4F60:  DATA 0A,0D
4F62:  DATA 00,00
4F64:  DATA 41,54
4F66:  DATA 2B,43
4F68:  DATA 4D,47
4F6A:  DATA 46,3D
4F6C:  DATA 31,0D
4F6E:  DATA 0A,00
4F70:  DATA 41,54
4F72:  DATA 2B,43
4F74:  DATA 4D,47
4F76:  DATA 53,3D
4F78:  DATA 00,00
4F7A:  DATA 0D,0A
4F7C:  DATA 53,65
4F7E:  DATA 6E,64
4F80:  DATA 69,6E
4F82:  DATA 67,20
4F84:  DATA 74,6F
4F86:  DATA 20,74
4F88:  DATA 68,65
4F8A:  DATA 20,66
4F8C:  DATA 69,72
4F8E:  DATA 73,74
4F90:  DATA 20,6E
4F92:  DATA 75,6D
4F94:  DATA 62,65
4F96:  DATA 72,0D
4F98:  DATA 0A,00
4F9A:  DATA 0D,0A
4F9C:  DATA 74,68
4F9E:  DATA 65,20
4FA0:  DATA 32,6E
4FA2:  DATA 64,20
4FA4:  DATA 6E,75
4FA6:  DATA 6D,62
4FA8:  DATA 65,72
4FAA:  DATA 20,69
4FAC:  DATA 73,20
4FAE:  DATA 6E,6F
4FB0:  DATA 74,20
4FB2:  DATA 69,6E
4FB4:  DATA 73,74
4FB6:  DATA 61,6C
4FB8:  DATA 6C,65
4FBA:  DATA 64,0D
4FBC:  DATA 0A,00
4FBE:  DATA 0D,0A
4FC0:  DATA 53,65
4FC2:  DATA 6E,64
4FC4:  DATA 69,6E
4FC6:  DATA 67,20
4FC8:  DATA 74,6F
4FCA:  DATA 20,74
4FCC:  DATA 68,65
4FCE:  DATA 20,73
4FD0:  DATA 65,63
4FD2:  DATA 6F,6E
4FD4:  DATA 64,20
4FD6:  DATA 6E,75
4FD8:  DATA 6D,62
4FDA:  DATA 65,72
4FDC:  DATA 0D,0A
4FDE:  DATA 00,00
4FE0:  DATA 69,64
4FE2:  DATA 6C,65
4FE4:  DATA 0A,0D
4FE6:  DATA 00,00
4FE8:  DATA 41,54
4FEA:  DATA 2B,43
4FEC:  DATA 4D,47
4FEE:  DATA 46,3D
4FF0:  DATA 31,0D
4FF2:  DATA 0A,00
4FF4:  DATA 53,49
4FF6:  DATA 4D,20
4FF8:  DATA 69,73
4FFA:  DATA 20,72
4FFC:  DATA 65,70
4FFE:  DATA 6C,79
5000:  DATA 69,6E
5002:  DATA 67,0A
5004:  DATA 0D,00
5006:  DATA 63,68
5008:  DATA 65,63
500A:  DATA 6B,20
500C:  DATA 63,6F
500E:  DATA 6D,75
5010:  DATA 6E,69
5012:  DATA 63,61
5014:  DATA 74,69
5016:  DATA 6F,6E
5018:  DATA 0A,0D
501A:  DATA 00,00
501C:  DATA 41,54
501E:  DATA 0D,0A
5020:  DATA 00,00
5022:  DATA 53,49
5024:  DATA 4D,20
5026:  DATA 61,63
5028:  DATA 74,69
502A:  DATA 76,69
502C:  DATA 74,79
502E:  DATA 20,73
5030:  DATA 74,61
5032:  DATA 74,75
5034:  DATA 73,0A
5036:  DATA 0D,00
5038:  DATA 41,54
503A:  DATA 2B,43
503C:  DATA 50,41
503E:  DATA 53,0D
5040:  DATA 0A,00
5042:  DATA 63,68
5044:  DATA 65,63
5046:  DATA 6B,20
5048:  DATA 69,6E
504A:  DATA 62,6F
504C:  DATA 78,0A
504E:  DATA 0D,00
5050:  DATA 41,54
5052:  DATA 2B,43
5054:  DATA 4D,47
5056:  DATA 52,3D
5058:  DATA 31,0D
505A:  DATA 0A,00
505C:  DATA 72,65
505E:  DATA 73,65
5060:  DATA 74,5F
5062:  DATA 6D,6F
5064:  DATA 64,75
5066:  DATA 6C,65
5068:  DATA 0A,0D
506A:  DATA 00,00
*
53E0:  TBLRD*+
53E2:  MOVF   FF5,F
53E4:  BZ    5400
53E6:  MOVFF  FF6,A8E
53EA:  MOVFF  FF7,A8F
53EE:  MOVF   FF5,W
53F0:  BTFSS  F9E.4
53F2:  BRA    53F0
53F4:  MOVWF  FAE
53F6:  MOVFF  A8E,FF6
53FA:  MOVFF  A8F,FF7
53FE:  BRA    53E0
5400:  RETURN 0
*
5FA0:  MOVLB  A
5FA2:  CLRF   xA5
5FA4:  CLRF   xA6
5FA6:  MOVLW  01
5FA8:  MOVWF  xA7
5FAA:  CLRF   FDA
5FAC:  CLRF   FD9
5FAE:  MOVLW  0A
5FB0:  MOVWF  xAA
5FB2:  MOVLW  9D
5FB4:  MOVWF  xA9
5FB6:  MOVLW  0A
5FB8:  MOVWF  FEA
5FBA:  MOVLW  A1
5FBC:  MOVWF  FE9
5FBE:  MOVFF  AAA,FE2
5FC2:  MOVFF  AA9,FE1
5FC6:  MOVFF  AA7,AA8
5FCA:  BCF    FD8.0
5FCC:  MOVF   FE5,W
5FCE:  MULWF  FEE
5FD0:  MOVF   FF3,W
5FD2:  ADDWFC xA5,F
5FD4:  MOVF   FF4,W
5FD6:  ADDWFC xA6,F
5FD8:  DECFSZ xA8,F
5FDA:  BRA    5FCA
5FDC:  MOVFF  AA5,FDE
5FE0:  MOVFF  AA6,AA5
5FE4:  CLRF   xA6
5FE6:  BTFSC  FD8.0
5FE8:  INCF   xA6,F
5FEA:  INCF   xA9,F
5FEC:  BTFSC  FD8.2
5FEE:  INCF   xAA,F
5FF0:  INCF   xA7,F
5FF2:  MOVF   xA7,W
5FF4:  SUBLW  05
5FF6:  BNZ   5FB6
5FF8:  MOVLB  0
5FFA:  GOTO   611C (RETURN)
5FFE:  BTFSC  FD8.1
6000:  BRA    600A
6002:  MOVLW  0A
6004:  MOVWF  FEA
6006:  MOVLW  AD
6008:  MOVWF  FE9
600A:  MOVLB  A
600C:  MOVF   xA8,W
600E:  XORWF  xAC,W
6010:  ANDLW  80
6012:  MOVWF  xB2
6014:  BTFSS  xA8.7
6016:  BRA    602E
6018:  COMF   xA5,F
601A:  COMF   xA6,F
601C:  COMF   xA7,F
601E:  COMF   xA8,F
6020:  INCF   xA5,F
6022:  BTFSC  FD8.2
6024:  INCF   xA6,F
6026:  BTFSC  FD8.2
6028:  INCF   xA7,F
602A:  BTFSC  FD8.2
602C:  INCF   xA8,F
602E:  BTFSS  xAC.7
6030:  BRA    6048
6032:  COMF   xA9,F
6034:  COMF   xAA,F
6036:  COMF   xAB,F
6038:  COMF   xAC,F
603A:  INCF   xA9,F
603C:  BTFSC  FD8.2
603E:  INCF   xAA,F
6040:  BTFSC  FD8.2
6042:  INCF   xAB,F
6044:  BTFSC  FD8.2
6046:  INCF   xAC,F
6048:  CLRF   00
604A:  CLRF   01
604C:  CLRF   02
604E:  CLRF   03
6050:  CLRF   xAD
6052:  CLRF   xAE
6054:  CLRF   xAF
6056:  CLRF   xB0
6058:  MOVF   xAC,W
605A:  IORWF  xAB,W
605C:  IORWF  xAA,W
605E:  IORWF  xA9,W
6060:  BZ    60BA
6062:  MOVLW  20
6064:  MOVWF  xB1
6066:  BCF    FD8.0
6068:  RLCF   xA5,F
606A:  RLCF   xA6,F
606C:  RLCF   xA7,F
606E:  RLCF   xA8,F
6070:  RLCF   xAD,F
6072:  RLCF   xAE,F
6074:  RLCF   xAF,F
6076:  RLCF   xB0,F
6078:  MOVF   xAC,W
607A:  SUBWF  xB0,W
607C:  BNZ   608E
607E:  MOVF   xAB,W
6080:  SUBWF  xAF,W
6082:  BNZ   608E
6084:  MOVF   xAA,W
6086:  SUBWF  xAE,W
6088:  BNZ   608E
608A:  MOVF   xA9,W
608C:  SUBWF  xAD,W
608E:  BNC   60AE
6090:  MOVF   xA9,W
6092:  SUBWF  xAD,F
6094:  MOVF   xAA,W
6096:  BTFSS  FD8.0
6098:  INCFSZ xAA,W
609A:  SUBWF  xAE,F
609C:  MOVF   xAB,W
609E:  BTFSS  FD8.0
60A0:  INCFSZ xAB,W
60A2:  SUBWF  xAF,F
60A4:  MOVF   xAC,W
60A6:  BTFSS  FD8.0
60A8:  INCFSZ xAC,W
60AA:  SUBWF  xB0,F
60AC:  BSF    FD8.0
60AE:  RLCF   00,F
60B0:  RLCF   01,F
60B2:  RLCF   02,F
60B4:  RLCF   03,F
60B6:  DECFSZ xB1,F
60B8:  BRA    6066
60BA:  BTFSS  xB2.7
60BC:  BRA    60D4
60BE:  COMF   00,F
60C0:  COMF   01,F
60C2:  COMF   02,F
60C4:  COMF   03,F
60C6:  INCF   00,F
60C8:  BTFSC  FD8.2
60CA:  INCF   01,F
60CC:  BTFSC  FD8.2
60CE:  INCF   02,F
60D0:  BTFSC  FD8.2
60D2:  INCF   03,F
60D4:  MOVFF  AAD,FEF
60D8:  MOVFF  AAE,FEC
60DC:  MOVFF  AAF,FEC
60E0:  MOVFF  AB0,FEC
60E4:  MOVLB  0
60E6:  RETURN 0
*
62A0:  CLRF   00
62A2:  CLRF   01
62A4:  MOVLB  A
62A6:  MOVF   x95,W
62A8:  BCF    FD8.0
62AA:  BTFSC  x96.0
62AC:  ADDWF  00,F
62AE:  RRCF   00,F
62B0:  RRCF   01,F
62B2:  BTFSC  x96.1
62B4:  ADDWF  00,F
62B6:  RRCF   00,F
62B8:  RRCF   01,F
62BA:  BTFSC  x96.2
62BC:  ADDWF  00,F
62BE:  RRCF   00,F
62C0:  RRCF   01,F
62C2:  BTFSC  x96.3
62C4:  ADDWF  00,F
62C6:  RRCF   00,F
62C8:  RRCF   01,F
62CA:  BTFSC  x96.4
62CC:  ADDWF  00,F
62CE:  RRCF   00,F
62D0:  RRCF   01,F
62D2:  BTFSC  x96.5
62D4:  ADDWF  00,F
62D6:  RRCF   00,F
62D8:  RRCF   01,F
62DA:  BTFSC  x96.6
62DC:  ADDWF  00,F
62DE:  RRCF   00,F
62E0:  RRCF   01,F
62E2:  BTFSC  x96.7
62E4:  ADDWF  00,F
62E6:  RRCF   00,F
62E8:  RRCF   01,F
62EA:  MOVLB  0
62EC:  GOTO   63C0 (RETURN)
*
9948:  ADDWF  FE8,W
994A:  CLRF   FF7
994C:  RLCF   FF7,F
994E:  ADDLW  63
9950:  MOVWF  FF6
9952:  MOVLW  99
9954:  ADDWFC FF7,F
9956:  TBLRD*-
9958:  MOVF   FF5,W
995A:  MOVWF  FFA
995C:  TBLRD*
995E:  MOVF   FF5,W
9960:  MOVWF  FF9
9962:  DATA A8,72
9964:  DATA CE,72
9966:  DATA 70,73
9968:  DATA E6,73
996A:  DATA 56,79
996C:  DATA 46,7D
996E:  DATA E4,8D
9970:  DATA 8A,8E
9972:  DATA EA,93
9974:  DATA 0C,96
9976:  DATA 1C,99
9978:  DATA 46,96
997A:  DATA 54,97
997C:  DATA 96,97
997E:  DATA E6,97
9980:  DATA 5A,98
9982:  DATA 96,98
9984:  DATA CE,98
9986:  DATA E2,74
9988:  DATA A8,96
998A:  DATA FE,98
....................  
.................... #list 
....................  
....................    //#include <18F46j11.h> 
.................... #endif 
....................  
.................... #if defined(SIM900) 
....................    #define rst_sim   PIN_C1 
.................... #endif 
.................... //========================= 
.................... //#include <18F26j11.h> 
....................    //#device adc=16  
.................... //#use STANDARD_IO(A) 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT,NOMCLR,NOUSBDIV,NOVREGEN, NOICPRT,NOPBADEN,NOICPRT 
.................... //#FUSES NOWDT, INTRC_IO, NOPUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT, NOMCLR 
.................... //#FUSES NOWDT, WDT128, PLL1, CPUDIV1, NOUSBDIV, INTRC_IO, NOBROWNOUT, NOLVP, NOXINST,NOMCLR 
.................... #FUSES NOWDT, WDT128, NOXINST,INTRC_PLL_IO 
....................  
.................... #device ADC=8 
.................... #use delay(clock=32000000) 
*
0736:  MOVLW  02
0738:  MOVLB  A
073A:  SUBWF  xB4,F
073C:  BNC   0756
073E:  MOVLW  0A
0740:  MOVWF  FEA
0742:  MOVLW  B4
0744:  MOVWF  FE9
0746:  MOVF   FEF,W
0748:  BZ    0756
074A:  BRA    0752
074C:  BRA    074E
074E:  BRA    0750
0750:  NOP   
0752:  DECFSZ FEF,F
0754:  BRA    074C
0756:  MOVLB  0
0758:  RETURN 0
*
198E:  MOVLW  0A
1990:  MOVWF  FEA
1992:  MOVLW  BC
1994:  MOVWF  FE9
1996:  MOVF   FEF,W
1998:  BZ    19B4
199A:  MOVLW  0A
199C:  MOVWF  01
199E:  CLRF   00
19A0:  DECFSZ 00,F
19A2:  BRA    19A0
19A4:  DECFSZ 01,F
19A6:  BRA    199E
19A8:  MOVLW  5F
19AA:  MOVWF  00
19AC:  DECFSZ 00,F
19AE:  BRA    19AC
19B0:  DECFSZ FEF,F
19B2:  BRA    199A
19B4:  RETURN 0
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=COM1) 
*
650A:  BTFSS  F9E.4
650C:  BRA    650A
650E:  MOVWF  FAE
6510:  RETURN 0
.................... //#use rs232(uart1, baud=9600) 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_C0,rcv=PIN_C1,bits=8,stream=COM2) 
*
075A:  BCF    F94.0
075C:  BCF    F8B.0
075E:  MOVLW  08
0760:  MOVWF  01
0762:  BRA    0764
0764:  NOP   
0766:  BSF    01.7
0768:  BRA    078A
076A:  BCF    01.7
076C:  MOVLB  A
076E:  RRCF   xDF,F
0770:  MOVLB  0
0772:  BTFSC  FD8.0
0774:  BSF    F8B.0
0776:  BTFSS  FD8.0
0778:  BCF    F8B.0
077A:  BSF    01.6
077C:  BRA    078A
077E:  BCF    01.6
0780:  DECFSZ 01,F
0782:  BRA    076C
0784:  BRA    0786
0786:  NOP   
0788:  BSF    F8B.0
078A:  MOVLW  10
078C:  MOVWF  FE9
078E:  DECFSZ FE9,F
0790:  BRA    078E
0792:  BRA    0794
0794:  NOP   
0796:  BTFSC  01.7
0798:  BRA    076A
079A:  BTFSC  01.6
079C:  BRA    077E
079E:  RETURN 0
....................  
....................  
.................... #include "stdlib.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
*
56A2:  MOVLB  A
56A4:  MOVF   x92,F
56A6:  BNZ   56AC
56A8:  MOVF   x93,F
56AA:  BZ    5730
....................       if (*s1 != *s2) 
56AC:  MOVFF  A8E,FE9
56B0:  MOVFF  A8F,FEA
56B4:  MOVFF  FEF,A94
56B8:  MOVFF  A91,03
56BC:  MOVFF  A90,FE9
56C0:  MOVFF  A91,FEA
56C4:  MOVF   FEF,W
56C6:  SUBWF  x94,W
56C8:  BZ    56F8
....................          return((*s1 <*s2) ? -1: 1); 
56CA:  MOVFF  A8F,03
56CE:  MOVFF  A8E,FE9
56D2:  MOVFF  03,FEA
56D6:  MOVFF  FEF,A94
56DA:  MOVFF  A91,03
56DE:  MOVFF  A90,FE9
56E2:  MOVFF  A91,FEA
56E6:  MOVF   FEF,W
56E8:  SUBWF  x94,W
56EA:  BC    56F0
56EC:  MOVLW  FF
56EE:  BRA    56F2
56F0:  MOVLW  01
56F2:  MOVWF  01
56F4:  BRA    5734
56F6:  BRA    570E
....................       else if (*s1 == '\0') 
56F8:  MOVFF  A8F,03
56FC:  MOVFF  A8E,FE9
5700:  MOVFF  A8F,FEA
5704:  MOVF   FEF,F
5706:  BNZ   570E
....................          return(0); 
5708:  MOVLW  00
570A:  MOVWF  01
570C:  BRA    5734
570E:  MOVFF  A8F,03
5712:  MOVF   x8E,W
5714:  INCF   x8E,F
5716:  BTFSC  FD8.2
5718:  INCF   x8F,F
571A:  MOVFF  A91,03
571E:  MOVF   x90,W
5720:  INCF   x90,F
5722:  BTFSC  FD8.2
5724:  INCF   x91,F
5726:  MOVF   x92,W
5728:  BTFSC  FD8.2
572A:  DECF   x93,F
572C:  DECF   x92,F
572E:  BRA    56A4
....................    return(0); 
5730:  MOVLW  00
5732:  MOVWF  01
5734:  MOVLB  0
5736:  RETURN 0
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
5EFC:  MOVFF  A97,A99
5F00:  MOVFF  A96,A98
5F04:  MOVFF  A99,03
5F08:  MOVLB  A
5F0A:  MOVFF  A98,FE9
5F0E:  MOVFF  A99,FEA
5F12:  MOVF   FEF,F
5F14:  BZ    5F22
5F16:  INCF   x98,F
5F18:  BTFSC  FD8.2
5F1A:  INCF   x99,F
5F1C:  MOVLB  0
5F1E:  BRA    5F04
5F20:  MOVLB  A
....................    return(sc - s); 
5F22:  MOVF   x96,W
5F24:  SUBWF  x98,W
5F26:  MOVWF  00
5F28:  MOVF   x97,W
5F2A:  SUBWFB x99,W
5F2C:  MOVWF  03
5F2E:  MOVFF  00,01
5F32:  MOVLB  0
5F34:  RETURN 0
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
62F0:  MOVLB  A
62F2:  CLRF   x93
....................    sign = 0; 
62F4:  CLRF   x91
....................    base = 10; 
62F6:  MOVLW  0A
62F8:  MOVWF  x92
....................    result = 0; 
62FA:  CLRF   x90
....................  
....................    if (!s) 
62FC:  MOVF   x8E,W
62FE:  IORWF  x8F,W
6300:  BNZ   6308
....................       return 0; 
6302:  MOVLW  00
6304:  MOVWF  01
6306:  BRA    647E
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
6308:  MOVF   x93,W
630A:  INCF   x93,F
630C:  ADDWF  x8E,W
630E:  MOVWF  FE9
6310:  MOVLW  00
6312:  ADDWFC x8F,W
6314:  MOVWF  FEA
6316:  MOVFF  FEF,A94
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
631A:  MOVF   x94,W
631C:  SUBLW  2D
631E:  BNZ   6338
....................    { 
....................       sign = 1;         // Set the sign to negative 
6320:  MOVLW  01
6322:  MOVWF  x91
....................       c = s[index++]; 
6324:  MOVF   x93,W
6326:  INCF   x93,F
6328:  ADDWF  x8E,W
632A:  MOVWF  FE9
632C:  MOVLW  00
632E:  ADDWFC x8F,W
6330:  MOVWF  FEA
6332:  MOVFF  FEF,A94
....................    } 
6336:  BRA    6350
....................    else if (c == '+') 
6338:  MOVF   x94,W
633A:  SUBLW  2B
633C:  BNZ   6350
....................    { 
....................       c = s[index++]; 
633E:  MOVF   x93,W
6340:  INCF   x93,F
6342:  ADDWF  x8E,W
6344:  MOVWF  FE9
6346:  MOVLW  00
6348:  ADDWFC x8F,W
634A:  MOVWF  FEA
634C:  MOVFF  FEF,A94
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
6350:  MOVF   x94,W
6352:  SUBLW  2F
6354:  BTFSC  FD8.0
6356:  BRA    646E
6358:  MOVF   x94,W
635A:  SUBLW  39
635C:  BTFSS  FD8.0
635E:  BRA    646E
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
6360:  MOVF   x94,W
6362:  SUBLW  30
6364:  BNZ   63A2
6366:  MOVF   x93,W
6368:  ADDWF  x8E,W
636A:  MOVWF  FE9
636C:  MOVLW  00
636E:  ADDWFC x8F,W
6370:  MOVWF  FEA
6372:  MOVF   FEF,W
6374:  SUBLW  78
6376:  BZ    638A
6378:  MOVF   x93,W
637A:  ADDWF  x8E,W
637C:  MOVWF  FE9
637E:  MOVLW  00
6380:  ADDWFC x8F,W
6382:  MOVWF  FEA
6384:  MOVF   FEF,W
6386:  SUBLW  58
6388:  BNZ   63A2
....................       { 
....................          base = 16; 
638A:  MOVLW  10
638C:  MOVWF  x92
....................          index++; 
638E:  INCF   x93,F
....................          c = s[index++]; 
6390:  MOVF   x93,W
6392:  INCF   x93,F
6394:  ADDWF  x8E,W
6396:  MOVWF  FE9
6398:  MOVLW  00
639A:  ADDWFC x8F,W
639C:  MOVWF  FEA
639E:  MOVFF  FEF,A94
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
63A2:  MOVF   x92,W
63A4:  SUBLW  0A
63A6:  BNZ   63E0
....................       { 
....................          while (c >= '0' && c <= '9') 
63A8:  MOVF   x94,W
63AA:  SUBLW  2F
63AC:  BC    63DE
63AE:  MOVF   x94,W
63B0:  SUBLW  39
63B2:  BNC   63DE
....................          { 
....................             result = 10*result + (c - '0'); 
63B4:  MOVLW  0A
63B6:  MOVWF  x95
63B8:  MOVFF  A90,A96
63BC:  MOVLB  0
63BE:  BRA    62A0
63C0:  MOVLW  30
63C2:  MOVLB  A
63C4:  SUBWF  x94,W
63C6:  ADDWF  01,W
63C8:  MOVWF  x90
....................             c = s[index++]; 
63CA:  MOVF   x93,W
63CC:  INCF   x93,F
63CE:  ADDWF  x8E,W
63D0:  MOVWF  FE9
63D2:  MOVLW  00
63D4:  ADDWFC x8F,W
63D6:  MOVWF  FEA
63D8:  MOVFF  FEF,A94
63DC:  BRA    63A8
....................          } 
....................       } 
63DE:  BRA    646E
....................       else if (base == 16)    // The number is a hexa number 
63E0:  MOVF   x92,W
63E2:  SUBLW  10
63E4:  BNZ   646E
....................       { 
....................          c = toupper(c); 
63E6:  MOVF   x94,W
63E8:  SUBLW  60
63EA:  BC    63F8
63EC:  MOVF   x94,W
63EE:  SUBLW  7A
63F0:  BNC   63F8
63F2:  MOVF   x94,W
63F4:  ANDLW  DF
63F6:  BRA    63FA
63F8:  MOVF   x94,W
63FA:  MOVWF  x94
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
63FC:  MOVF   x94,W
63FE:  SUBLW  2F
6400:  BC    6408
6402:  MOVF   x94,W
6404:  SUBLW  39
6406:  BC    6414
6408:  MOVF   x94,W
640A:  SUBLW  40
640C:  BC    646E
640E:  MOVF   x94,W
6410:  SUBLW  46
6412:  BNC   646E
....................          { 
....................             if (c >= '0' && c <= '9') 
6414:  MOVF   x94,W
6416:  SUBLW  2F
6418:  BC    6432
641A:  MOVF   x94,W
641C:  SUBLW  39
641E:  BNC   6432
....................                result = (result << 4) + (c - '0'); 
6420:  SWAPF  x90,W
6422:  MOVWF  x95
6424:  MOVLW  F0
6426:  ANDWF  x95,F
6428:  MOVLW  30
642A:  SUBWF  x94,W
642C:  ADDWF  x95,W
642E:  MOVWF  x90
6430:  BRA    6444
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
6432:  SWAPF  x90,W
6434:  MOVWF  x95
6436:  MOVLW  F0
6438:  ANDWF  x95,F
643A:  MOVLW  41
643C:  SUBWF  x94,W
643E:  ADDLW  0A
6440:  ADDWF  x95,W
6442:  MOVWF  x90
....................  
....................             c = s[index++]; 
6444:  MOVF   x93,W
6446:  INCF   x93,F
6448:  ADDWF  x8E,W
644A:  MOVWF  FE9
644C:  MOVLW  00
644E:  ADDWFC x8F,W
6450:  MOVWF  FEA
6452:  MOVFF  FEF,A94
....................             c = toupper(c); 
6456:  MOVF   x94,W
6458:  SUBLW  60
645A:  BC    6468
645C:  MOVF   x94,W
645E:  SUBLW  7A
6460:  BNC   6468
6462:  MOVF   x94,W
6464:  ANDLW  DF
6466:  BRA    646A
6468:  MOVF   x94,W
646A:  MOVWF  x94
646C:  BRA    63FC
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
646E:  DECFSZ x91,W
6470:  BRA    647A
6472:  MOVF   x92,W
6474:  SUBLW  0A
6476:  BNZ   647A
....................        result = -result; 
6478:  NEGF   x90
....................  
....................    return(result); 
647A:  MOVFF  A90,01
647E:  MOVLB  0
6480:  GOTO   8C7E (RETURN)
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
60E8:  MOVLB  A
60EA:  CLRF   x98
60EC:  CLRF   x97
60EE:  CLRF   x96
60F0:  MOVLW  01
60F2:  MOVWF  x95
60F4:  CLRF   x9A
60F6:  CLRF   x9B
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
60F8:  BTFSS  x91.7
60FA:  BRA    612E
....................          sign=1;        // Check for negative number 
60FC:  MOVLW  01
60FE:  MOVWF  x9A
....................          num*=-1; 
6100:  MOVFF  A91,AA0
6104:  MOVFF  A90,A9F
6108:  MOVFF  A8F,A9E
610C:  MOVFF  A8E,A9D
6110:  SETF   xA4
6112:  SETF   xA3
6114:  SETF   xA2
6116:  SETF   xA1
6118:  MOVLB  0
611A:  BRA    5FA0
611C:  MOVFF  03,A91
6120:  MOVFF  02,A90
6124:  MOVFF  01,A8F
6128:  MOVFF  00,A8E
612C:  MOVLB  A
....................      } 
....................  
....................      while(temp>0) { 
612E:  MOVF   x95,F
6130:  BNZ   613E
6132:  MOVF   x96,F
6134:  BNZ   613E
6136:  MOVF   x97,F
6138:  BNZ   613E
613A:  MOVF   x98,F
613C:  BZ    6212
....................          temp=(num/base); 
613E:  BCF    FD8.1
6140:  MOVFF  A91,AA8
6144:  MOVFF  A90,AA7
6148:  MOVFF  A8F,AA6
614C:  MOVFF  A8E,AA5
6150:  CLRF   xAC
6152:  CLRF   xAB
6154:  CLRF   xAA
6156:  MOVFF  A92,AA9
615A:  MOVLB  0
615C:  RCALL  5FFE
615E:  MOVFF  03,A98
6162:  MOVFF  02,A97
6166:  MOVFF  01,A96
616A:  MOVFF  00,A95
....................          s[cnt]=(num%base)+'0';    // Conversion 
616E:  MOVLB  A
6170:  MOVF   x9B,W
6172:  ADDWF  x93,W
6174:  MOVWF  01
6176:  MOVLW  00
6178:  ADDWFC x94,W
617A:  MOVWF  03
617C:  MOVFF  01,A9D
6180:  MOVWF  x9E
6182:  MOVFF  FEA,AA0
6186:  MOVFF  FE9,A9F
618A:  BSF    FD8.1
618C:  MOVLW  0A
618E:  MOVWF  FEA
6190:  MOVLW  A1
6192:  MOVWF  FE9
6194:  MOVFF  A91,AA8
6198:  MOVFF  A90,AA7
619C:  MOVFF  A8F,AA6
61A0:  MOVFF  A8E,AA5
61A4:  CLRF   xAC
61A6:  CLRF   xAB
61A8:  CLRF   xAA
61AA:  MOVFF  A92,AA9
61AE:  MOVLB  0
61B0:  RCALL  5FFE
61B2:  MOVFF  AA0,FEA
61B6:  MOVFF  A9F,FE9
61BA:  MOVLW  30
61BC:  MOVLB  A
61BE:  ADDWF  xA1,W
61C0:  MOVWF  00
61C2:  MOVLW  00
61C4:  ADDWFC xA2,W
61C6:  MOVLW  00
61C8:  ADDWFC xA3,W
61CA:  MOVLW  00
61CC:  ADDWFC xA4,W
61CE:  MOVFF  A9E,FEA
61D2:  MOVFF  A9D,FE9
61D6:  MOVFF  00,FEF
....................  
....................          if(s[cnt]>0x39) 
61DA:  MOVF   x9B,W
61DC:  ADDWF  x93,W
61DE:  MOVWF  FE9
61E0:  MOVLW  00
61E2:  ADDWFC x94,W
61E4:  MOVWF  FEA
61E6:  MOVF   FEF,W
61E8:  SUBLW  39
61EA:  BC    61FE
....................             s[cnt]+=0x7; 
61EC:  MOVF   x9B,W
61EE:  ADDWF  x93,W
61F0:  MOVWF  FE9
61F2:  MOVLW  00
61F4:  ADDWFC x94,W
61F6:  MOVWF  FEA
61F8:  MOVLW  07
61FA:  ADDWF  FEF,W
61FC:  MOVWF  FEF
....................  
....................          cnt++; 
61FE:  INCF   x9B,F
....................          num=temp; 
6200:  MOVFF  A98,A91
6204:  MOVFF  A97,A90
6208:  MOVFF  A96,A8F
620C:  MOVFF  A95,A8E
6210:  BRA    612E
....................      } 
....................  
....................      if(sign==1) { 
6212:  DECFSZ x9A,W
6214:  BRA    6228
....................          s[cnt]=0x2D;      // Negative sign 
6216:  MOVF   x9B,W
6218:  ADDWF  x93,W
621A:  MOVWF  FE9
621C:  MOVLW  00
621E:  ADDWFC x94,W
6220:  MOVWF  FEA
6222:  MOVLW  2D
6224:  MOVWF  FEF
....................          cnt++; 
6226:  INCF   x9B,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
6228:  CLRF   x99
622A:  BCF    FD8.0
622C:  RRCF   x9B,W
622E:  SUBWF  x99,W
6230:  BC    6286
....................  
....................          c=s[i]; 
6232:  MOVF   x99,W
6234:  ADDWF  x93,W
6236:  MOVWF  FE9
6238:  MOVLW  00
623A:  ADDWFC x94,W
623C:  MOVWF  FEA
623E:  MOVFF  FEF,A9C
....................          s[i]=s[cnt-i-1];        // Reverse the number 
6242:  MOVF   x99,W
6244:  ADDWF  x93,W
6246:  MOVWF  01
6248:  MOVLW  00
624A:  ADDWFC x94,W
624C:  MOVWF  03
624E:  MOVF   x99,W
6250:  SUBWF  x9B,W
6252:  ADDLW  FF
6254:  ADDWF  x93,W
6256:  MOVWF  FE9
6258:  MOVLW  00
625A:  ADDWFC x94,W
625C:  MOVWF  FEA
625E:  MOVFF  FEF,A9F
6262:  MOVFF  03,FEA
6266:  MOVFF  01,FE9
626A:  MOVFF  A9F,FEF
....................          s[cnt-i-1]=c; 
626E:  MOVF   x99,W
6270:  SUBWF  x9B,W
6272:  ADDLW  FF
6274:  ADDWF  x93,W
6276:  MOVWF  FE9
6278:  MOVLW  00
627A:  ADDWFC x94,W
627C:  MOVWF  FEA
627E:  MOVFF  A9C,FEF
6282:  INCF   x99,F
6284:  BRA    622A
....................      } 
....................      s[cnt]='\0';     // End the string 
6286:  MOVF   x9B,W
6288:  ADDWF  x93,W
628A:  MOVWF  FE9
628C:  MOVLW  00
628E:  ADDWFC x94,W
6290:  MOVWF  FEA
6292:  CLRF   FEF
....................      return s; 
6294:  MOVFF  A93,01
6298:  MOVFF  A94,02
629C:  MOVLB  0
629E:  RETURN 0
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "24512.C" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC512 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... //#ifndef EEPROM_SDA 
....................  
.................... /*#define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C5*/ 
....................  
.................... #define EEPROM_SDA  PIN_C4 
.................... #define EEPROM_SCL  PIN_C3 
.................... //#endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
37B0:  MOVLW  08
37B2:  MOVWF  01
37B4:  MOVLW  0A
37B6:  MOVWF  00
37B8:  DECFSZ 00,F
37BA:  BRA    37B8
37BC:  BCF    F8B.3
37BE:  BCF    F94.3
37C0:  MOVLW  0B
37C2:  MOVWF  00
37C4:  DECFSZ 00,F
37C6:  BRA    37C4
37C8:  MOVLB  A
37CA:  RLCF   xCE,F
37CC:  BCF    F8B.4
37CE:  BTFSC  FD8.0
37D0:  BSF    F94.4
37D2:  BTFSS  FD8.0
37D4:  BCF    F94.4
37D6:  BSF    F94.3
37D8:  BTFSS  F82.3
37DA:  BRA    37D8
37DC:  DECFSZ 01,F
37DE:  BRA    37E2
37E0:  BRA    37E6
37E2:  MOVLB  0
37E4:  BRA    37B4
37E6:  MOVLW  0A
37E8:  MOVWF  00
37EA:  DECFSZ 00,F
37EC:  BRA    37EA
37EE:  BCF    F8B.3
37F0:  BCF    F94.3
37F2:  NOP   
37F4:  BSF    F94.4
37F6:  MOVLW  0B
37F8:  MOVWF  00
37FA:  DECFSZ 00,F
37FC:  BRA    37FA
37FE:  MOVLW  0B
3800:  MOVWF  00
3802:  DECFSZ 00,F
3804:  BRA    3802
3806:  BSF    F94.3
3808:  BTFSS  F82.3
380A:  BRA    3808
380C:  CLRF   01
380E:  MOVLW  0B
3810:  MOVWF  00
3812:  DECFSZ 00,F
3814:  BRA    3812
3816:  BTFSC  F82.4
3818:  BSF    01.0
381A:  BCF    F8B.3
381C:  BCF    F94.3
381E:  BCF    F8B.4
3820:  BCF    F94.4
3822:  MOVLB  0
3824:  RETURN 0
3826:  MOVLW  08
3828:  MOVLB  A
382A:  MOVWF  xC3
382C:  MOVFF  00,AC4
3830:  BSF    F94.4
3832:  MOVLW  0B
3834:  MOVWF  00
3836:  DECFSZ 00,F
3838:  BRA    3836
383A:  BSF    F94.3
383C:  BTFSS  F82.3
383E:  BRA    383C
3840:  BTFSC  F82.4
3842:  BSF    FD8.0
3844:  BTFSS  F82.4
3846:  BCF    FD8.0
3848:  RLCF   01,F
384A:  MOVLW  0A
384C:  MOVWF  00
384E:  DECFSZ 00,F
3850:  BRA    384E
3852:  BCF    F94.3
3854:  BCF    F8B.3
3856:  DECFSZ xC3,F
3858:  BRA    3830
385A:  BSF    F94.4
385C:  MOVLW  0B
385E:  MOVWF  00
3860:  DECFSZ 00,F
3862:  BRA    3860
3864:  BCF    F8B.4
3866:  MOVF   xC4,W
3868:  BTFSS  FD8.2
386A:  BCF    F94.4
386C:  NOP   
386E:  BSF    F94.3
3870:  BTFSS  F82.3
3872:  BRA    3870
3874:  MOVLW  0A
3876:  MOVWF  00
3878:  DECFSZ 00,F
387A:  BRA    3878
387C:  BCF    F8B.3
387E:  BCF    F94.3
3880:  MOVLW  0B
3882:  MOVWF  00
3884:  DECFSZ 00,F
3886:  BRA    3884
3888:  BCF    F8B.4
388A:  BCF    F94.4
388C:  MOVLB  0
388E:  RETURN 0
....................  
.................... #define EEPROM_ADDRESS long int 
.................... //#define EEPROM_SIZE   65535 
.................... #define EEPROM_SIZE_key    65535 
.................... #define EEPROM_SIZE        43590 
.................... #define EEPROM_KEY_ST      EEPROM_SIZE+1 
.................... //=============================== 
.................... #define ptr_start                150 
.................... unsigned int32 ptr_card=ptr_start; 
.................... unsigned int32 ptr_card_key=EEPROM_KEY_ST; 
.................... //=============================== 
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
506C:  BSF    F94.3
....................    output_float(EEPROM_SDA); 
506E:  BSF    F94.4
....................    port_b_pullups(0xff); 
5070:  BCF    FF1.7
5072:  GOTO   6D7C (RETURN)
.................... } 
....................  
.................... void write_ext_eeprom(long int address, BYTE data) 
.................... { 
....................    short int status; 
....................    i2c_start(); 
*
3E74:  BSF    F94.4
3E76:  MOVLW  0A
3E78:  MOVWF  00
3E7A:  DECFSZ 00,F
3E7C:  BRA    3E7A
3E7E:  BSF    F94.3
3E80:  MOVLW  0B
3E82:  MOVWF  00
3E84:  DECFSZ 00,F
3E86:  BRA    3E84
3E88:  BCF    F8B.4
3E8A:  BCF    F94.4
3E8C:  MOVLW  0A
3E8E:  MOVWF  00
3E90:  DECFSZ 00,F
3E92:  BRA    3E90
3E94:  BCF    F8B.3
3E96:  BCF    F94.3
....................    i2c_write(0xa0); 
3E98:  MOVLW  A0
3E9A:  MOVLB  A
3E9C:  MOVWF  xCE
3E9E:  MOVLB  0
3EA0:  RCALL  37B0
....................    i2c_write(address>>8); 
3EA2:  MOVFF  AC8,ACC
3EA6:  MOVLB  A
3EA8:  CLRF   xCD
3EAA:  MOVFF  AC8,ACE
3EAE:  MOVLB  0
3EB0:  RCALL  37B0
....................    i2c_write(address); 
3EB2:  MOVFF  AC7,ACE
3EB6:  RCALL  37B0
....................    i2c_write(data); 
3EB8:  MOVFF  AC9,ACE
3EBC:  RCALL  37B0
....................    i2c_stop(); 
3EBE:  BCF    F94.4
3EC0:  NOP   
3EC2:  BSF    F94.3
3EC4:  BTFSS  F82.3
3EC6:  BRA    3EC4
3EC8:  MOVLW  0A
3ECA:  MOVWF  00
3ECC:  DECFSZ 00,F
3ECE:  BRA    3ECC
3ED0:  BRA    3ED2
3ED2:  NOP   
3ED4:  BSF    F94.4
3ED6:  MOVLW  0A
3ED8:  MOVWF  00
3EDA:  DECFSZ 00,F
3EDC:  BRA    3EDA
....................    i2c_start(); 
3EDE:  BSF    F94.4
3EE0:  MOVLW  0A
3EE2:  MOVWF  00
3EE4:  DECFSZ 00,F
3EE6:  BRA    3EE4
3EE8:  BSF    F94.3
3EEA:  MOVLW  0B
3EEC:  MOVWF  00
3EEE:  DECFSZ 00,F
3EF0:  BRA    3EEE
3EF2:  BCF    F8B.4
3EF4:  BCF    F94.4
3EF6:  MOVLW  0A
3EF8:  MOVWF  00
3EFA:  DECFSZ 00,F
3EFC:  BRA    3EFA
3EFE:  BCF    F8B.3
3F00:  BCF    F94.3
....................    status=i2c_write(0xa0); 
3F02:  MOVLW  A0
3F04:  MOVLB  A
3F06:  MOVWF  xCE
3F08:  MOVLB  0
3F0A:  RCALL  37B0
3F0C:  MOVF   01,W
3F0E:  MOVLB  A
3F10:  BCF    xCA.0
3F12:  BTFSC  01.0
3F14:  BSF    xCA.0
....................    while(status==1) 
3F16:  BTFSS  xCA.0
3F18:  BRA    3F56
....................    { 
....................       i2c_start(); 
3F1A:  BSF    F94.4
3F1C:  MOVLW  0A
3F1E:  MOVWF  00
3F20:  DECFSZ 00,F
3F22:  BRA    3F20
3F24:  BSF    F94.3
3F26:  MOVLW  0B
3F28:  MOVWF  00
3F2A:  DECFSZ 00,F
3F2C:  BRA    3F2A
3F2E:  BTFSS  F82.3
3F30:  BRA    3F2E
3F32:  BCF    F8B.4
3F34:  BCF    F94.4
3F36:  MOVLW  0A
3F38:  MOVWF  00
3F3A:  DECFSZ 00,F
3F3C:  BRA    3F3A
3F3E:  BCF    F8B.3
3F40:  BCF    F94.3
....................       status=i2c_write(0xa0); 
3F42:  MOVLW  A0
3F44:  MOVWF  xCE
3F46:  MOVLB  0
3F48:  RCALL  37B0
3F4A:  MOVF   01,W
3F4C:  MOVLB  A
3F4E:  BCF    xCA.0
3F50:  BTFSC  01.0
3F52:  BSF    xCA.0
3F54:  BRA    3F16
....................    } 
....................    i2c_stop(); 
3F56:  BCF    F94.4
3F58:  NOP   
3F5A:  BSF    F94.3
3F5C:  BTFSS  F82.3
3F5E:  BRA    3F5C
3F60:  MOVLW  0A
3F62:  MOVWF  00
3F64:  DECFSZ 00,F
3F66:  BRA    3F64
3F68:  BRA    3F6A
3F6A:  NOP   
3F6C:  BSF    F94.4
3F6E:  MOVLW  0A
3F70:  MOVWF  00
3F72:  DECFSZ 00,F
3F74:  BRA    3F72
3F76:  MOVLB  0
3F78:  RETURN 0
.................... } 
....................  
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................    i2c_start(); 
*
395A:  BSF    F94.4
395C:  MOVLW  0A
395E:  MOVWF  00
3960:  DECFSZ 00,F
3962:  BRA    3960
3964:  BSF    F94.3
3966:  MOVLW  0B
3968:  MOVWF  00
396A:  DECFSZ 00,F
396C:  BRA    396A
396E:  BCF    F8B.4
3970:  BCF    F94.4
3972:  MOVLW  0A
3974:  MOVWF  00
3976:  DECFSZ 00,F
3978:  BRA    3976
397A:  BCF    F8B.3
397C:  BCF    F94.3
....................    i2c_write(0xa0); 
397E:  MOVLW  A0
3980:  MOVLB  A
3982:  MOVWF  xCE
3984:  MOVLB  0
3986:  RCALL  37B0
....................    i2c_write(address>>8); 
3988:  MOVFF  AC0,AC2
398C:  MOVLB  A
398E:  CLRF   xC3
3990:  MOVFF  AC0,ACE
3994:  MOVLB  0
3996:  RCALL  37B0
....................    i2c_write(address); 
3998:  MOVFF  ABF,ACE
399C:  RCALL  37B0
....................    i2c_start(); 
399E:  BSF    F94.4
39A0:  MOVLW  0A
39A2:  MOVWF  00
39A4:  DECFSZ 00,F
39A6:  BRA    39A4
39A8:  BSF    F94.3
39AA:  MOVLW  0B
39AC:  MOVWF  00
39AE:  DECFSZ 00,F
39B0:  BRA    39AE
39B2:  BTFSS  F82.3
39B4:  BRA    39B2
39B6:  BCF    F8B.4
39B8:  BCF    F94.4
39BA:  MOVLW  0A
39BC:  MOVWF  00
39BE:  DECFSZ 00,F
39C0:  BRA    39BE
39C2:  BCF    F8B.3
39C4:  BCF    F94.3
....................    i2c_write(0xa1); 
39C6:  MOVLW  A1
39C8:  MOVLB  A
39CA:  MOVWF  xCE
39CC:  MOVLB  0
39CE:  RCALL  37B0
....................    data=i2c_read(0); 
39D0:  CLRF   00
39D2:  RCALL  3826
39D4:  MOVFF  01,AC1
....................    i2c_stop(); 
39D8:  BCF    F94.4
39DA:  NOP   
39DC:  BSF    F94.3
39DE:  BTFSS  F82.3
39E0:  BRA    39DE
39E2:  MOVLW  0A
39E4:  MOVWF  00
39E6:  DECFSZ 00,F
39E8:  BRA    39E6
39EA:  BRA    39EC
39EC:  NOP   
39EE:  BSF    F94.4
39F0:  MOVLW  0A
39F2:  MOVWF  00
39F4:  DECFSZ 00,F
39F6:  BRA    39F4
....................    return(data); 
39F8:  MOVLB  A
39FA:  MOVFF  AC1,01
39FE:  MOVLB  0
3A00:  RETURN 0
.................... } 
....................  
.................... int8 I2CEEPROM_read(unsigned int16 adr, unsigned int16 len, int8 *buf) 
.................... { 
....................    unsigned int16 i; 
....................  
....................    if((adr+len) >= EEPROM_SIZE) return(0); 
*
6484:  MOVLB  A
6486:  MOVF   x92,W
6488:  ADDWF  x90,W
648A:  MOVWF  x98
648C:  MOVF   x93,W
648E:  ADDWFC x91,W
6490:  MOVWF  x99
6492:  SUBLW  A9
6494:  BC    64A6
6496:  XORLW  FF
6498:  BNZ   64A0
649A:  MOVF   x98,W
649C:  SUBLW  45
649E:  BC    64A6
64A0:  MOVLW  00
64A2:  MOVWF  01
64A4:  BRA    6504
....................    for(i=0;i<len;i++) 
64A6:  CLRF   x97
64A8:  CLRF   x96
64AA:  MOVF   x97,W
64AC:  SUBWF  x93,W
64AE:  BNC   6504
64B0:  BNZ   64B8
64B2:  MOVF   x92,W
64B4:  SUBWF  x96,W
64B6:  BC    6504
....................    { 
....................        buf[i]=read_ext_eeprom(adr+i); 
64B8:  MOVF   x94,W
64BA:  ADDWF  x96,W
64BC:  MOVWF  01
64BE:  MOVF   x95,W
64C0:  ADDWFC x97,W
64C2:  MOVWF  03
64C4:  MOVFF  01,A98
64C8:  MOVWF  x99
64CA:  MOVF   x96,W
64CC:  ADDWF  x90,W
64CE:  MOVWF  x9A
64D0:  MOVF   x97,W
64D2:  ADDWFC x91,W
64D4:  MOVWF  x9B
64D6:  CLRF   19
64D8:  BTFSC  FF2.7
64DA:  BSF    19.7
64DC:  BCF    FF2.7
64DE:  MOVWF  xC0
64E0:  MOVFF  A9A,ABF
64E4:  MOVLB  0
64E6:  CALL   395A
64EA:  BTFSC  19.7
64EC:  BSF    FF2.7
64EE:  MOVFF  A99,FEA
64F2:  MOVFF  A98,FE9
64F6:  MOVFF  01,FEF
64FA:  MOVLB  A
64FC:  INCF   x96,F
64FE:  BTFSC  FD8.2
6500:  INCF   x97,F
6502:  BRA    64AA
....................    } 
6504:  MOVLB  0
6506:  GOTO   8F1E (RETURN)
....................     
.................... } 
....................  
....................  
.................... #include <eeprom.c> 
....................  
....................  
.................... #include "STRING.H" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #define strobe_pass_addr         0 
.................... #define strobe_ptrcard_addr      25// from 21 to 24 use for stobe point 
.................... #define strobe_ptrcard_key       30// from 21 to 24 use for stobe point 
.................... //#define strobe_password          35 
.................... #define strobe_count_card        40 
.................... //#define strobe_ptrcard_addr      69// from 21 to 24 use for stobe point 
.................... #define strobe_mobile_num0        65   //  num1   num2  num3 num4 
.................... #define strobe_mobile_num1       85 // 1->16// ->34//-> 50 -> 66 
.................... #define strobe_nameconsole       102 // 102+16 
.................... //#define strobe_mobile_num2       105 //18-34   
.................... //#define strobe_mobile_num3       125 
....................  
....................  
.................... #define strobe_Master_SLV        145 
.................... #define strobe_debugmode         146 
.................... #define strobe_autosending       147 
.................... #define strobe_delaytime         148 
.................... #define strobe_two_number        149 
.................... #define kindofKB                 126 
.................... #define strobe_keypressmode      127 
....................  
....................  
.................... //#define ptr_start                150 
....................  
.................... //#define EEPROM_KEY_ST      43590+1 
....................  
.................... //#define install_password         0xfe 
.................... //============================================================== 
.................... #define numdata                  124 // 5+79+40=124 
.................... #define countcards                350   //43590/124 
.................... //=============================================================== 
....................  
.................... unsigned int8 temp[5]; 
.................... unsigned int8 buffer1[20]; 
.................... unsigned int8 buffer2[20]; 
.................... unsigned int8 password[20]; 
.................... unsigned int8 entpassword[20]; 
.................... unsigned int8 rec[numdata]; 
.................... int16 countcard=0; 
.................... int16 charac_timeout=0xffff; 
.................... //int8 twonumber=0; 
.................... //============================================== 
.................... void del_buf(int8 lenght, unsigned int8 *inputdat) 
.................... { 
....................    int8 i; 
....................    for(i=0;i<lenght;i++) 
*
3A74:  MOVLB  A
3A76:  CLRF   xC8
3A78:  MOVF   xC5,W
3A7A:  SUBWF  xC8,W
3A7C:  BC    3A90
....................    { 
....................       inputdat[i]=0; 
3A7E:  MOVF   xC8,W
3A80:  ADDWF  xC6,W
3A82:  MOVWF  FE9
3A84:  MOVLW  00
3A86:  ADDWFC xC7,W
3A88:  MOVWF  FEA
3A8A:  CLRF   FEF
3A8C:  INCF   xC8,F
3A8E:  BRA    3A78
....................    } 
3A90:  MOVLB  0
3A92:  RETURN 0
.................... } 
.................... //=============================================================== 
.................... void EEPROM_write(unsigned int adr, unsigned int len, char *buf) 
.................... { 
....................    unsigned int8 i; 
....................    for(i=0;i<len;i++) 
*
50CE:  MOVLB  A
50D0:  CLRF   xA7
50D2:  MOVF   xA4,W
50D4:  SUBWF  xA7,W
50D6:  BC    511A
....................    { 
....................       write_ext_eeprom(adr+i, buf[i]); 
50D8:  MOVF   xA7,W
50DA:  ADDWF  xA3,W
50DC:  MOVWF  xA8
50DE:  MOVF   xA7,W
50E0:  ADDWF  xA5,W
50E2:  MOVWF  FE9
50E4:  MOVLW  00
50E6:  ADDWFC xA6,W
50E8:  MOVWF  FEA
50EA:  MOVFF  FEF,AA9
50EE:  CLRF   19
50F0:  BTFSC  FF2.7
50F2:  BSF    19.7
50F4:  BCF    FF2.7
50F6:  CLRF   xC8
50F8:  MOVFF  AA8,AC7
50FC:  MOVFF  AA9,AC9
5100:  MOVLB  0
5102:  CALL   3E74
5106:  BTFSC  19.7
5108:  BSF    FF2.7
....................       delay_us(10); 
510A:  MOVLW  1A
510C:  MOVWF  00
510E:  DECFSZ 00,F
5110:  BRA    510E
5112:  NOP   
5114:  MOVLB  A
5116:  INCF   xA7,F
5118:  BRA    50D2
....................    } 
511A:  MOVLB  0
511C:  RETURN 0
.................... } 
.................... //=============================================================== 
.................... void EEPROM_read(unsigned int adr, unsigned int len, char *buf) 
.................... { 
....................    unsigned int8 i; 
....................    for(i=0;i<len;i++) 
*
5076:  MOVLB  A
5078:  CLRF   x92
507A:  MOVF   x8F,W
507C:  SUBWF  x92,W
507E:  BC    50CA
....................    { 
....................       buf[i]=read_ext_eeprom(adr+i); 
5080:  MOVF   x92,W
5082:  ADDWF  x90,W
5084:  MOVWF  01
5086:  MOVLW  00
5088:  ADDWFC x91,W
508A:  MOVWF  03
508C:  MOVFF  01,A93
5090:  MOVWF  x94
5092:  MOVF   x92,W
5094:  ADDWF  x8E,W
5096:  MOVWF  x95
5098:  CLRF   19
509A:  BTFSC  FF2.7
509C:  BSF    19.7
509E:  BCF    FF2.7
50A0:  CLRF   xC0
50A2:  MOVWF  xBF
50A4:  MOVLB  0
50A6:  CALL   395A
50AA:  BTFSC  19.7
50AC:  BSF    FF2.7
50AE:  MOVFF  A94,FEA
50B2:  MOVFF  A93,FE9
50B6:  MOVFF  01,FEF
....................       delay_us(10); 
50BA:  MOVLW  1A
50BC:  MOVWF  00
50BE:  DECFSZ 00,F
50C0:  BRA    50BE
50C2:  NOP   
50C4:  MOVLB  A
50C6:  INCF   x92,F
50C8:  BRA    507A
....................    } 
50CA:  MOVLB  0
50CC:  RETURN 0
.................... } 
.................... //================================================================ 
.................... /*void default_pass() 
.................... { 
....................    unsigned int8 temp; 
....................    temp = read_program_eeprom(strobe_password); 
....................    if(temp==0xff) 
....................    { 
....................       EEPROM_write(strobe_password,11,defaul_password); 
....................    } 
.................... }*/ 
.................... //================================================================ 
.................... /*int8 check_default_password() 
.................... { 
....................    int8 st=0; 
....................    EEPROM_read(strobe_password,11,buf_checkpass); 
....................    //strcpy (command1,"Den 6 tat"); 
....................    if(!memcmp(buf_checkpass,defaul_password,11))st=1; 
....................       else st=0; 
....................    return(st); 
.................... }*/ 
.................... //================================================================ 
.................... /*void save_mobile_number(int8 count,unsigned int8 *mb_num) 
.................... { 
....................    //strobe_count_num 
....................    unsigned int8 i=0,temp; 
....................    for(i=0;i<16;i++) 
....................    { 
....................       temp = mb_num[i]; 
....................       if((temp<48)||(temp>57)) 
....................       { 
....................          if(temp!='+') mb_num[i]=0; 
....................       } 
....................    } 
....................    switch (count) 
....................    { 
....................       case 0: 
....................          EEPROM_write(strobe_mobile_num1,16,mb_num); 
....................       break; 
....................       case 1: 
....................          EEPROM_write(strobe_mobile_num2,16,mb_num); 
....................       break; 
....................       case 2: 
....................          EEPROM_write(strobe_mobile_num3,16,mb_num); 
....................       break;       
....................       case 3: 
....................          //EEPROM_write(strobe_mobile_num4,16,mb_num); 
....................       break;       
....................    } 
.................... }*/ 
.................... //===================================================== 
.................... /*void save_password(unsigned int8 lenght, unsigned int8 *pass_dat) 
.................... { 
....................    EEPROM_write(strobe_password,lenght,pass_dat); 
.................... }*/ 
.................... //================================================================ 
.................... unsigned int32 get_ptrcard(int8 addr) 
*
52A2:  MOVLB  A
52A4:  CLRF   x92
52A6:  CLRF   x91
52A8:  CLRF   x90
52AA:  CLRF   x8F
52AC:  CLRF   x96
52AE:  CLRF   x95
52B0:  CLRF   x94
52B2:  CLRF   x93
52B4:  CLRF   x9A
52B6:  CLRF   x99
52B8:  CLRF   x98
52BA:  CLRF   x97
52BC:  CLRF   x9E
52BE:  CLRF   x9D
52C0:  CLRF   x9C
52C2:  CLRF   x9B
52C4:  CLRF   xA2
52C6:  CLRF   xA1
52C8:  CLRF   xA0
52CA:  CLRF   x9F
52CC:  CLRF   19
52CE:  BTFSC  FF2.7
52D0:  BSF    19.7
52D2:  BCF    FF2.7
.................... { 
....................    unsigned int32 buffer=0; 
....................    unsigned int32 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(addr+0)&0x000000ff; 
52D4:  CLRF   xC0
52D6:  MOVFF  A8E,ABF
52DA:  MOVLB  0
52DC:  CALL   395A
52E0:  BTFSC  19.7
52E2:  BSF    FF2.7
52E4:  MOVLB  A
52E6:  MOVFF  01,A93
52EA:  CLRF   x94
52EC:  CLRF   x95
52EE:  CLRF   x96
....................    temp2 = (unsigned int32)read_ext_eeprom(addr+1); 
52F0:  MOVLW  01
52F2:  ADDWF  x8E,W
52F4:  MOVWF  xA3
52F6:  CLRF   19
52F8:  BTFSC  FF2.7
52FA:  BSF    19.7
52FC:  BCF    FF2.7
52FE:  CLRF   xC0
5300:  MOVWF  xBF
5302:  MOVLB  0
5304:  CALL   395A
5308:  BTFSC  19.7
530A:  BSF    FF2.7
530C:  MOVLB  A
530E:  CLRF   x9A
5310:  CLRF   x99
5312:  CLRF   x98
5314:  MOVFF  01,A97
....................    temp2<<=8; 
5318:  MOVFF  A99,A9A
531C:  MOVFF  A98,A99
5320:  MOVFF  A97,A98
5324:  CLRF   x97
....................    temp3 = (unsigned int32)read_ext_eeprom(addr+2); 
5326:  MOVLW  02
5328:  ADDWF  x8E,W
532A:  MOVWF  xA3
532C:  CLRF   19
532E:  BTFSC  FF2.7
5330:  BSF    19.7
5332:  BCF    FF2.7
5334:  CLRF   xC0
5336:  MOVWF  xBF
5338:  MOVLB  0
533A:  CALL   395A
533E:  BTFSC  19.7
5340:  BSF    FF2.7
5342:  MOVLB  A
5344:  CLRF   x9E
5346:  CLRF   x9D
5348:  CLRF   x9C
534A:  MOVFF  01,A9B
....................    temp3<<=16; 
534E:  MOVFF  A9C,A9E
5352:  MOVFF  A9B,A9D
5356:  CLRF   x9B
5358:  CLRF   x9C
....................    temp4 = (unsigned int32)read_ext_eeprom(addr+3); 
535A:  MOVLW  03
535C:  ADDWF  x8E,W
535E:  MOVWF  xA3
5360:  CLRF   19
5362:  BTFSC  FF2.7
5364:  BSF    19.7
5366:  BCF    FF2.7
5368:  CLRF   xC0
536A:  MOVWF  xBF
536C:  MOVLB  0
536E:  CALL   395A
5372:  BTFSC  19.7
5374:  BSF    FF2.7
5376:  MOVLB  A
5378:  CLRF   xA2
537A:  CLRF   xA1
537C:  CLRF   xA0
537E:  MOVFF  01,A9F
....................    temp4<<=24; 
5382:  MOVFF  A9F,AA2
5386:  CLRF   x9F
5388:  CLRF   xA0
538A:  CLRF   xA1
....................    buffer = temp4|temp3|temp2|temp1; 
538C:  MOVF   x9F,W
538E:  IORWF  x9B,W
5390:  MOVWF  xA3
5392:  MOVF   xA0,W
5394:  IORWF  x9C,W
5396:  MOVWF  xA4
5398:  MOVF   xA1,W
539A:  IORWF  x9D,W
539C:  MOVWF  xA5
539E:  MOVF   xA2,W
53A0:  IORWF  x9E,W
53A2:  MOVWF  xA6
53A4:  MOVF   x97,W
53A6:  IORWF  xA3,F
53A8:  MOVF   x98,W
53AA:  IORWF  xA4,F
53AC:  MOVF   x99,W
53AE:  IORWF  xA5,F
53B0:  MOVF   x9A,W
53B2:  IORWF  xA6,F
53B4:  MOVF   xA3,W
53B6:  IORWF  x93,W
53B8:  MOVWF  x8F
53BA:  MOVF   xA4,W
53BC:  IORWF  x94,W
53BE:  MOVWF  x90
53C0:  MOVF   xA5,W
53C2:  IORWF  x95,W
53C4:  MOVWF  x91
53C6:  MOVF   xA6,W
53C8:  IORWF  x96,W
53CA:  MOVWF  x92
....................    return(buffer); 
53CC:  MOVFF  A8F,00
53D0:  MOVFF  A90,01
53D4:  MOVFF  A91,02
53D8:  MOVFF  A92,03
53DC:  MOVLB  0
53DE:  RETURN 0
.................... } 
.................... //======================================================= 
.................... void save_ptrcard(unsigned int32 ptr,int8 addr) 
*
3F7A:  MOVLB  A
3F7C:  CLRF   xC1
3F7E:  CLRF   xC0
3F80:  CLRF   xBF
3F82:  CLRF   xBE
3F84:  CLRF   xC2
3F86:  CLRF   xC3
3F88:  CLRF   xC4
3F8A:  CLRF   xC5
.................... { 
....................    unsigned int32 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0,temp3=0,temp4=0; 
....................    buffer=ptr; 
3F8C:  MOVFF  ABC,AC1
3F90:  MOVFF  ABB,AC0
3F94:  MOVFF  ABA,ABF
3F98:  MOVFF  AB9,ABE
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
3F9C:  MOVFF  ABE,AC2
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
3FA0:  MOVFF  ABF,AC3
....................    temp3 = (unsigned int8)(buffer>>16)&0x000000ff; 
3FA4:  MOVFF  AC0,AC4
....................    temp4 = (unsigned int8)(buffer>>24)&0x000000ff; 
3FA8:  MOVFF  AC1,AC5
....................    write_ext_eeprom((addr+0),temp1); 
3FAC:  CLRF   xC8
3FAE:  MOVFF  ABD,AC7
3FB2:  MOVFF  AC2,AC9
3FB6:  MOVLB  0
3FB8:  RCALL  3E74
....................    write_ext_eeprom((addr+1),temp2); 
3FBA:  MOVLW  01
3FBC:  MOVLB  A
3FBE:  ADDWF  xBD,W
3FC0:  MOVWF  xC6
3FC2:  CLRF   xC8
3FC4:  MOVWF  xC7
3FC6:  MOVFF  AC3,AC9
3FCA:  MOVLB  0
3FCC:  RCALL  3E74
....................    write_ext_eeprom((addr+2),temp3); 
3FCE:  MOVLW  02
3FD0:  MOVLB  A
3FD2:  ADDWF  xBD,W
3FD4:  MOVWF  xC6
3FD6:  CLRF   xC8
3FD8:  MOVWF  xC7
3FDA:  MOVFF  AC4,AC9
3FDE:  MOVLB  0
3FE0:  RCALL  3E74
....................    write_ext_eeprom((addr+3),temp4); 
3FE2:  MOVLW  03
3FE4:  MOVLB  A
3FE6:  ADDWF  xBD,W
3FE8:  MOVWF  xC6
3FEA:  CLRF   xC8
3FEC:  MOVWF  xC7
3FEE:  MOVFF  AC5,AC9
3FF2:  MOVLB  0
3FF4:  RCALL  3E74
3FF6:  RETURN 0
.................... } 
.................... //============================================= 
.................... void save_coutcard(unsigned int16 ptr) 
*
45E4:  MOVLB  A
45E6:  CLRF   xB9
45E8:  CLRF   xB8
45EA:  CLRF   xBA
45EC:  CLRF   xBB
.................... { 
....................    unsigned int16 buffer=0; 
....................    unsigned int8 temp1=0,temp2=0; 
....................    buffer=ptr; 
45EE:  MOVFF  AB7,AB9
45F2:  MOVFF  AB6,AB8
....................    temp1 = (unsigned int8)buffer&0x000000ff; 
45F6:  MOVFF  AB8,ABA
....................    temp2 = (unsigned int8)(buffer>>8)&0x000000ff; 
45FA:  MOVF   xB9,W
45FC:  MOVWF  xBB
....................    write_ext_eeprom((strobe_count_card+0),temp1); 
45FE:  CLRF   xC8
4600:  MOVLW  28
4602:  MOVWF  xC7
4604:  MOVFF  ABA,AC9
4608:  MOVLB  0
460A:  RCALL  3E74
....................    write_ext_eeprom((strobe_count_card+1),temp2); 
460C:  MOVLB  A
460E:  CLRF   xC8
4610:  MOVLW  29
4612:  MOVWF  xC7
4614:  MOVFF  ABB,AC9
4618:  MOVLB  0
461A:  RCALL  3E74
461C:  RETURN 0
.................... } 
.................... //============================================= 
.................... unsigned int16 get_countcard() 
*
3A02:  MOVLB  A
3A04:  CLRF   xBA
3A06:  CLRF   xB9
3A08:  CLRF   xBC
3A0A:  CLRF   xBB
3A0C:  CLRF   xBE
3A0E:  CLRF   xBD
.................... { 
....................    unsigned int16 buffer=0; 
....................    unsigned int16 temp1=0,temp2=0; 
....................    temp1 = (unsigned int32)read_ext_eeprom(strobe_count_card+0)&0x000000ff; 
3A10:  CLRF   xC0
3A12:  MOVLW  28
3A14:  MOVWF  xBF
3A16:  MOVLB  0
3A18:  RCALL  395A
3A1A:  MOVLB  A
3A1C:  MOVFF  01,ABB
3A20:  CLRF   xBC
....................    temp2 = (unsigned int32)read_ext_eeprom(strobe_count_card+1); 
3A22:  CLRF   xC0
3A24:  MOVLW  29
3A26:  MOVWF  xBF
3A28:  MOVLB  0
3A2A:  RCALL  395A
3A2C:  MOVLB  A
3A2E:  CLRF   xBE
3A30:  MOVFF  01,ABD
....................    temp2<<=8; 
3A34:  MOVFF  ABD,ABE
3A38:  CLRF   xBD
....................    buffer = temp2|temp1; 
3A3A:  MOVF   xBD,W
3A3C:  IORWF  xBB,W
3A3E:  MOVWF  xB9
3A40:  MOVF   xBE,W
3A42:  IORWF  xBC,W
3A44:  MOVWF  xBA
....................    return(buffer); 
3A46:  MOVFF  AB9,01
3A4A:  MOVFF  ABA,02
3A4E:  MOVLB  0
3A50:  RETURN 0
.................... } 
.................... //=========================================== 
.................... void format_eepromext() 
.................... { 
....................    int16 i; 
....................    for(i=EEPROM_KEY_ST;i<ptr_card_key;i++) 
*
5DDC:  MOVLW  AA
5DDE:  MOVLB  A
5DE0:  MOVWF  x8F
5DE2:  MOVLW  47
5DE4:  MOVWF  x8E
5DE6:  MOVF   27,F
5DE8:  BNZ   5DFC
5DEA:  MOVF   26,F
5DEC:  BNZ   5DFC
5DEE:  MOVF   x8F,W
5DF0:  SUBWF  25,W
5DF2:  BNC   5E22
5DF4:  BNZ   5DFC
5DF6:  MOVF   24,W
5DF8:  SUBWF  x8E,W
5DFA:  BC    5E22
5DFC:  CLRF   19
5DFE:  BTFSC  FF2.7
5E00:  BSF    19.7
5E02:  BCF    FF2.7
....................    { 
....................      write_ext_eeprom(i,0); 
5E04:  MOVFF  A8F,AC8
5E08:  MOVFF  A8E,AC7
5E0C:  CLRF   xC9
5E0E:  MOVLB  0
5E10:  CALL   3E74
5E14:  BTFSC  19.7
5E16:  BSF    FF2.7
5E18:  MOVLB  A
5E1A:  INCF   x8E,F
5E1C:  BTFSC  FD8.2
5E1E:  INCF   x8F,F
5E20:  BRA    5DE6
....................    } 
....................    for(i=ptr_start;i<ptr_card;i++) 
5E22:  CLRF   x8F
5E24:  MOVLW  96
5E26:  MOVWF  x8E
5E28:  MOVF   23,F
5E2A:  BNZ   5E3E
5E2C:  MOVF   22,F
5E2E:  BNZ   5E3E
5E30:  MOVF   x8F,W
5E32:  SUBWF  21,W
5E34:  BNC   5E64
5E36:  BNZ   5E3E
5E38:  MOVF   20,W
5E3A:  SUBWF  x8E,W
5E3C:  BC    5E64
5E3E:  CLRF   19
5E40:  BTFSC  FF2.7
5E42:  BSF    19.7
5E44:  BCF    FF2.7
....................    { 
....................      write_ext_eeprom(i,0); 
5E46:  MOVFF  A8F,AC8
5E4A:  MOVFF  A8E,AC7
5E4E:  CLRF   xC9
5E50:  MOVLB  0
5E52:  CALL   3E74
5E56:  BTFSC  19.7
5E58:  BSF    FF2.7
5E5A:  MOVLB  A
5E5C:  INCF   x8E,F
5E5E:  BTFSC  FD8.2
5E60:  INCF   x8F,F
5E62:  BRA    5E28
....................    } 
....................    ptr_card=ptr_start; 
5E64:  CLRF   23
5E66:  CLRF   22
5E68:  CLRF   21
5E6A:  MOVLW  96
5E6C:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
5E6E:  CLRF   27
5E70:  CLRF   26
5E72:  MOVLW  AA
5E74:  MOVWF  25
5E76:  MOVLW  47
5E78:  MOVWF  24
5E7A:  CLRF   19
5E7C:  BTFSC  FF2.7
5E7E:  BSF    19.7
5E80:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
5E82:  MOVFF  23,ABC
5E86:  MOVFF  22,ABB
5E8A:  MOVFF  21,ABA
5E8E:  MOVFF  20,AB9
5E92:  MOVLW  19
5E94:  MOVWF  xBD
5E96:  MOVLB  0
5E98:  CALL   3F7A
5E9C:  BTFSC  19.7
5E9E:  BSF    FF2.7
5EA0:  CLRF   19
5EA2:  BTFSC  FF2.7
5EA4:  BSF    19.7
5EA6:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
5EA8:  MOVFF  27,ABC
5EAC:  MOVFF  26,ABB
5EB0:  MOVFF  25,ABA
5EB4:  MOVFF  24,AB9
5EB8:  MOVLW  1E
5EBA:  MOVLB  A
5EBC:  MOVWF  xBD
5EBE:  MOVLB  0
5EC0:  CALL   3F7A
5EC4:  BTFSC  19.7
5EC6:  BSF    FF2.7
5EC8:  CLRF   19
5ECA:  BTFSC  FF2.7
5ECC:  BSF    19.7
5ECE:  BCF    FF2.7
....................    save_coutcard(0); 
5ED0:  MOVLB  A
5ED2:  CLRF   xB7
5ED4:  CLRF   xB6
5ED6:  MOVLB  0
5ED8:  CALL   45E4
5EDC:  BTFSC  19.7
5EDE:  BSF    FF2.7
5EE0:  CLRF   19
5EE2:  BTFSC  FF2.7
5EE4:  BSF    19.7
5EE6:  BCF    FF2.7
....................    countcard=get_countcard(); 
5EE8:  CALL   3A02
5EEC:  BTFSC  19.7
5EEE:  BSF    FF2.7
5EF0:  MOVFF  02,FA
5EF4:  MOVFF  01,F9
5EF8:  GOTO   8940 (RETURN)
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",get_ptrcard(strobe_ptrcard_addr)); 
....................    //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................    //fprintf(COM2," countcard=%lu\n\r",countcard); 
.................... } 
.................... //============================================ 
.................... void ease_eeprom() 
.................... { 
....................    int16 i; 
....................    for(i=ptr_start;i<EEPROM_SIZE_key;i++) 
*
5D24:  MOVLB  A
5D26:  CLRF   x8F
5D28:  MOVLW  96
5D2A:  MOVWF  x8E
5D2C:  INCFSZ x8E,W
5D2E:  BRA    5D36
5D30:  INCFSZ x8F,W
5D32:  BRA    5D36
5D34:  BRA    5D5C
5D36:  CLRF   19
5D38:  BTFSC  FF2.7
5D3A:  BSF    19.7
5D3C:  BCF    FF2.7
....................    { 
....................      write_ext_eeprom(i,0); 
5D3E:  MOVFF  A8F,AC8
5D42:  MOVFF  A8E,AC7
5D46:  CLRF   xC9
5D48:  MOVLB  0
5D4A:  CALL   3E74
5D4E:  BTFSC  19.7
5D50:  BSF    FF2.7
5D52:  MOVLB  A
5D54:  INCF   x8E,F
5D56:  BTFSC  FD8.2
5D58:  INCF   x8F,F
5D5A:  BRA    5D2C
....................    } 
....................    ptr_card=ptr_start; 
5D5C:  CLRF   23
5D5E:  CLRF   22
5D60:  CLRF   21
5D62:  MOVLW  96
5D64:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
5D66:  CLRF   27
5D68:  CLRF   26
5D6A:  MOVLW  AA
5D6C:  MOVWF  25
5D6E:  MOVLW  47
5D70:  MOVWF  24
5D72:  CLRF   19
5D74:  BTFSC  FF2.7
5D76:  BSF    19.7
5D78:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
5D7A:  MOVFF  23,ABC
5D7E:  MOVFF  22,ABB
5D82:  MOVFF  21,ABA
5D86:  MOVFF  20,AB9
5D8A:  MOVLW  19
5D8C:  MOVWF  xBD
5D8E:  MOVLB  0
5D90:  CALL   3F7A
5D94:  BTFSC  19.7
5D96:  BSF    FF2.7
5D98:  CLRF   19
5D9A:  BTFSC  FF2.7
5D9C:  BSF    19.7
5D9E:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
5DA0:  MOVFF  27,ABC
5DA4:  MOVFF  26,ABB
5DA8:  MOVFF  25,ABA
5DAC:  MOVFF  24,AB9
5DB0:  MOVLW  1E
5DB2:  MOVLB  A
5DB4:  MOVWF  xBD
5DB6:  MOVLB  0
5DB8:  CALL   3F7A
5DBC:  BTFSC  19.7
5DBE:  BSF    FF2.7
5DC0:  CLRF   19
5DC2:  BTFSC  FF2.7
5DC4:  BSF    19.7
5DC6:  BCF    FF2.7
....................    save_coutcard(0); 
5DC8:  MOVLB  A
5DCA:  CLRF   xB7
5DCC:  CLRF   xB6
5DCE:  MOVLB  0
5DD0:  CALL   45E4
5DD4:  BTFSC  19.7
5DD6:  BSF    FF2.7
5DD8:  GOTO   88C0 (RETURN)
.................... } 
.................... //=========================================== 
.................... void init_password() 
.................... { 
....................       EEPROM_read(strobe_pass_addr,20,password); 
*
511E:  MOVLB  A
5120:  CLRF   x8E
5122:  MOVLW  14
5124:  MOVWF  x8F
5126:  CLRF   x91
5128:  MOVLW  55
512A:  MOVWF  x90
512C:  MOVLB  0
512E:  RCALL  5076
....................       if((password[0]==0xff)&&(password[1]==0xff)&&(password[15]==0xff)) 
5130:  INCFSZ 55,W
5132:  BRA    518A
5134:  INCFSZ 56,W
5136:  BRA    518A
5138:  INCFSZ x64,W
513A:  BRA    518A
....................       { 
....................          memset(buffer1,0,20); 
513C:  CLRF   FEA
513E:  MOVLW  2D
5140:  MOVWF  FE9
5142:  CLRF   00
5144:  CLRF   02
5146:  MOVLW  14
5148:  MOVWF  01
514A:  CALL   4476
....................          strcpy(buffer1,"admin"); 
514E:  CLRF   FEA
5150:  MOVLW  2D
5152:  MOVWF  FE9
5154:  MOVLW  00
5156:  CALL   00D2
515A:  TBLRD*-
515C:  TBLRD*+
515E:  MOVF   FF5,W
5160:  MOVWF  FEE
5162:  IORLW  00
5164:  BNZ   515C
....................          EEPROM_write(strobe_pass_addr,20,buffer1); 
5166:  MOVLB  A
5168:  CLRF   xA3
516A:  MOVLW  14
516C:  MOVWF  xA4
516E:  CLRF   xA6
5170:  MOVLW  2D
5172:  MOVWF  xA5
5174:  MOVLB  0
5176:  RCALL  50CE
....................          EEPROM_read(strobe_pass_addr,20,password); 
5178:  MOVLB  A
517A:  CLRF   x8E
517C:  MOVLW  14
517E:  MOVWF  x8F
5180:  CLRF   x91
5182:  MOVLW  55
5184:  MOVWF  x90
5186:  MOVLB  0
5188:  RCALL  5076
....................       } 
518A:  RETURN 0
.................... } 
.................... //============================================= 
.................... void reset_password() 
.................... { 
....................    int8 buf[20],i; 
....................    for(i=0;i<20;i++)buf[i]=0xff; 
*
5738:  MOVLB  A
573A:  CLRF   xA2
573C:  MOVF   xA2,W
573E:  SUBLW  13
5740:  BNC   5756
5742:  CLRF   03
5744:  MOVF   xA2,W
5746:  ADDLW  8E
5748:  MOVWF  FE9
574A:  MOVLW  0A
574C:  ADDWFC 03,W
574E:  MOVWF  FEA
5750:  SETF   FEF
5752:  INCF   xA2,F
5754:  BRA    573C
....................    EEPROM_write(strobe_pass_addr,20,buf); 
5756:  CLRF   xA3
5758:  MOVLW  14
575A:  MOVWF  xA4
575C:  MOVLW  0A
575E:  MOVWF  xA6
5760:  MOVLW  8E
5762:  MOVWF  xA5
5764:  MOVLB  0
5766:  RCALL  50CE
5768:  GOTO   7674 (RETURN)
.................... } 
.................... //============================================ 
.................... void reset_2nd_number() 
.................... { 
....................    int8 buf[20],i; 
....................    for(i=0;i<20;i++)buf[i]=0; 
576C:  MOVLB  A
576E:  CLRF   xA2
5770:  MOVF   xA2,W
5772:  SUBLW  13
5774:  BNC   578A
5776:  CLRF   03
5778:  MOVF   xA2,W
577A:  ADDLW  8E
577C:  MOVWF  FE9
577E:  MOVLW  0A
5780:  ADDWFC 03,W
5782:  MOVWF  FEA
5784:  CLRF   FEF
5786:  INCF   xA2,F
5788:  BRA    5770
....................    EEPROM_write(strobe_mobile_num0,20,buf); 
578A:  MOVLW  41
578C:  MOVWF  xA3
578E:  MOVLW  14
5790:  MOVWF  xA4
5792:  MOVLW  0A
5794:  MOVWF  xA6
5796:  MOVLW  8E
5798:  MOVWF  xA5
579A:  MOVLB  0
579C:  RCALL  50CE
579E:  GOTO   767C (RETURN)
.................... } 
....................  
.................... #include "ds1307.C" 
....................  
.................... #define DS1307_SEC      0 
.................... #define DS1307_MIN      1    
.................... #define DS1307_HR       2 
.................... #define DS1307_DAY      3 
.................... #define DS1307_DATE     4 
.................... #define DS1307_MONTH    5 
.................... #define DS1307_YR       6 
.................... #define DS1307_CONTROL  7 
....................  
.................... //=============================== 
.................... unsigned int8 day,year=14,mon=1,date=1,h=0,min=0,sec=0; 
.................... //=============================== 
....................  
.................... BYTE read_DS1307(BYTE address) 
.................... { 
....................    BYTE result; 
....................  
....................    i2c_start(); 
*
3890:  BSF    F94.4
3892:  MOVLW  0A
3894:  MOVWF  00
3896:  DECFSZ 00,F
3898:  BRA    3896
389A:  BSF    F94.3
389C:  MOVLW  0B
389E:  MOVWF  00
38A0:  DECFSZ 00,F
38A2:  BRA    38A0
38A4:  BCF    F8B.4
38A6:  BCF    F94.4
38A8:  MOVLW  0A
38AA:  MOVWF  00
38AC:  DECFSZ 00,F
38AE:  BRA    38AC
38B0:  BCF    F8B.3
38B2:  BCF    F94.3
....................    i2c_write(0xD0); 
38B4:  MOVLW  D0
38B6:  MOVLB  A
38B8:  MOVWF  xCE
38BA:  MOVLB  0
38BC:  RCALL  37B0
....................    i2c_write(address); 
38BE:  MOVFF  ABD,ACE
38C2:  RCALL  37B0
....................    i2c_start(); 
38C4:  BSF    F94.4
38C6:  MOVLW  0A
38C8:  MOVWF  00
38CA:  DECFSZ 00,F
38CC:  BRA    38CA
38CE:  BSF    F94.3
38D0:  MOVLW  0B
38D2:  MOVWF  00
38D4:  DECFSZ 00,F
38D6:  BRA    38D4
38D8:  BTFSS  F82.3
38DA:  BRA    38D8
38DC:  BCF    F8B.4
38DE:  BCF    F94.4
38E0:  MOVLW  0A
38E2:  MOVWF  00
38E4:  DECFSZ 00,F
38E6:  BRA    38E4
38E8:  BCF    F8B.3
38EA:  BCF    F94.3
....................    i2c_write(0xD1); 
38EC:  MOVLW  D1
38EE:  MOVLB  A
38F0:  MOVWF  xCE
38F2:  MOVLB  0
38F4:  RCALL  37B0
....................    result = i2c_read(0); 
38F6:  CLRF   00
38F8:  RCALL  3826
38FA:  MOVFF  01,ABE
....................    i2c_stop(); 
38FE:  BCF    F94.4
3900:  NOP   
3902:  BSF    F94.3
3904:  BTFSS  F82.3
3906:  BRA    3904
3908:  MOVLW  0A
390A:  MOVWF  00
390C:  DECFSZ 00,F
390E:  BRA    390C
3910:  BRA    3912
3912:  NOP   
3914:  BSF    F94.4
3916:  MOVLW  0A
3918:  MOVWF  00
391A:  DECFSZ 00,F
391C:  BRA    391A
....................     
....................    return(result); 
391E:  MOVLB  A
3920:  MOVFF  ABE,01
3924:  MOVLB  0
3926:  RETURN 0
.................... } 
....................  
.................... void write_DS1307(BYTE address, BYTE data) 
.................... { 
....................    i2c_start(); 
*
5856:  BSF    F94.4
5858:  MOVLW  0A
585A:  MOVWF  00
585C:  DECFSZ 00,F
585E:  BRA    585C
5860:  BSF    F94.3
5862:  MOVLW  0B
5864:  MOVWF  00
5866:  DECFSZ 00,F
5868:  BRA    5866
586A:  BCF    F8B.4
586C:  BCF    F94.4
586E:  MOVLW  0A
5870:  MOVWF  00
5872:  DECFSZ 00,F
5874:  BRA    5872
5876:  BCF    F8B.3
5878:  BCF    F94.3
....................    delay_us(10); 
587A:  MOVLW  1A
587C:  MOVWF  00
587E:  DECFSZ 00,F
5880:  BRA    587E
5882:  NOP   
5884:  CLRF   19
5886:  BTFSC  FF2.7
5888:  BSF    19.7
588A:  BCF    FF2.7
....................    i2c_write(0xD0); 
588C:  MOVLW  D0
588E:  MOVLB  A
5890:  MOVWF  xCE
5892:  MOVLB  0
5894:  CALL   37B0
5898:  BTFSC  19.7
589A:  BSF    FF2.7
....................    delay_us(10); 
589C:  MOVLW  1A
589E:  MOVWF  00
58A0:  DECFSZ 00,F
58A2:  BRA    58A0
58A4:  NOP   
58A6:  CLRF   19
58A8:  BTFSC  FF2.7
58AA:  BSF    19.7
58AC:  BCF    FF2.7
....................    i2c_write(address); 
58AE:  MOVFF  A96,ACE
58B2:  CALL   37B0
58B6:  BTFSC  19.7
58B8:  BSF    FF2.7
....................    delay_us(10); 
58BA:  MOVLW  1A
58BC:  MOVWF  00
58BE:  DECFSZ 00,F
58C0:  BRA    58BE
58C2:  NOP   
58C4:  CLRF   19
58C6:  BTFSC  FF2.7
58C8:  BSF    19.7
58CA:  BCF    FF2.7
....................    i2c_write(data); 
58CC:  MOVFF  A97,ACE
58D0:  CALL   37B0
58D4:  BTFSC  19.7
58D6:  BSF    FF2.7
....................    i2c_stop(); 
58D8:  BCF    F94.4
58DA:  NOP   
58DC:  BSF    F94.3
58DE:  BTFSS  F82.3
58E0:  BRA    58DE
58E2:  MOVLW  0A
58E4:  MOVWF  00
58E6:  DECFSZ 00,F
58E8:  BRA    58E6
58EA:  BRA    58EC
58EC:  NOP   
58EE:  BSF    F94.4
58F0:  MOVLW  0A
58F2:  MOVWF  00
58F4:  DECFSZ 00,F
58F6:  BRA    58F4
....................    delay_us(10); 
58F8:  MOVLW  1A
58FA:  MOVWF  00
58FC:  DECFSZ 00,F
58FE:  BRA    58FC
5900:  NOP   
5902:  RETURN 0
.................... } 
....................  
.................... void rtc_init() 
*
518C:  CLRF   19
518E:  BTFSC  FF2.7
5190:  BSF    19.7
5192:  BCF    FF2.7
.................... { 
....................    unsigned int8 data; 
....................     
....................    data = read_DS1307(DS1307_SEC); 
5194:  MOVLB  A
5196:  CLRF   xBD
5198:  MOVLB  0
519A:  CALL   3890
519E:  BTFSC  19.7
51A0:  BSF    FF2.7
51A2:  MOVFF  01,A8E
....................     
....................    data &= 0x7F; 
51A6:  MOVLB  A
51A8:  BCF    x8E.7
....................     
....................    i2c_start(); 
51AA:  BSF    F94.4
51AC:  MOVLW  0A
51AE:  MOVWF  00
51B0:  DECFSZ 00,F
51B2:  BRA    51B0
51B4:  BSF    F94.3
51B6:  MOVLW  0B
51B8:  MOVWF  00
51BA:  DECFSZ 00,F
51BC:  BRA    51BA
51BE:  BCF    F8B.4
51C0:  BCF    F94.4
51C2:  MOVLW  0A
51C4:  MOVWF  00
51C6:  DECFSZ 00,F
51C8:  BRA    51C6
51CA:  BCF    F8B.3
51CC:  BCF    F94.3
51CE:  CLRF   19
51D0:  BTFSC  FF2.7
51D2:  BSF    19.7
51D4:  BCF    FF2.7
....................    i2c_write(0xD0); 
51D6:  MOVLW  D0
51D8:  MOVWF  xCE
51DA:  MOVLB  0
51DC:  CALL   37B0
51E0:  BTFSC  19.7
51E2:  BSF    FF2.7
51E4:  CLRF   19
51E6:  BTFSC  FF2.7
51E8:  BSF    19.7
51EA:  BCF    FF2.7
....................    i2c_write(DS1307_SEC); 
51EC:  MOVLB  A
51EE:  CLRF   xCE
51F0:  MOVLB  0
51F2:  CALL   37B0
51F6:  BTFSC  19.7
51F8:  BSF    FF2.7
51FA:  CLRF   19
51FC:  BTFSC  FF2.7
51FE:  BSF    19.7
5200:  BCF    FF2.7
....................    i2c_write(data); 
5202:  MOVFF  A8E,ACE
5206:  CALL   37B0
520A:  BTFSC  19.7
520C:  BSF    FF2.7
....................    i2c_start(); 
520E:  BSF    F94.4
5210:  MOVLW  0A
5212:  MOVWF  00
5214:  DECFSZ 00,F
5216:  BRA    5214
5218:  BSF    F94.3
521A:  MOVLW  0B
521C:  MOVWF  00
521E:  DECFSZ 00,F
5220:  BRA    521E
5222:  BTFSS  F82.3
5224:  BRA    5222
5226:  BCF    F8B.4
5228:  BCF    F94.4
522A:  MOVLW  0A
522C:  MOVWF  00
522E:  DECFSZ 00,F
5230:  BRA    522E
5232:  BCF    F8B.3
5234:  BCF    F94.3
5236:  CLRF   19
5238:  BTFSC  FF2.7
523A:  BSF    19.7
523C:  BCF    FF2.7
....................    i2c_write(0xD0); 
523E:  MOVLW  D0
5240:  MOVLB  A
5242:  MOVWF  xCE
5244:  MOVLB  0
5246:  CALL   37B0
524A:  BTFSC  19.7
524C:  BSF    FF2.7
524E:  CLRF   19
5250:  BTFSC  FF2.7
5252:  BSF    19.7
5254:  BCF    FF2.7
....................    i2c_write(DS1307_CONTROL); 
5256:  MOVLW  07
5258:  MOVLB  A
525A:  MOVWF  xCE
525C:  MOVLB  0
525E:  CALL   37B0
5262:  BTFSC  19.7
5264:  BSF    FF2.7
5266:  CLRF   19
5268:  BTFSC  FF2.7
526A:  BSF    19.7
526C:  BCF    FF2.7
....................    i2c_write(0x80); 
526E:  MOVLW  80
5270:  MOVLB  A
5272:  MOVWF  xCE
5274:  MOVLB  0
5276:  CALL   37B0
527A:  BTFSC  19.7
527C:  BSF    FF2.7
....................    i2c_stop(); 
527E:  BCF    F94.4
5280:  NOP   
5282:  BSF    F94.3
5284:  BTFSS  F82.3
5286:  BRA    5284
5288:  MOVLW  0A
528A:  MOVWF  00
528C:  DECFSZ 00,F
528E:  BRA    528C
5290:  BRA    5292
5292:  NOP   
5294:  BSF    F94.4
5296:  MOVLW  0A
5298:  MOVWF  00
529A:  DECFSZ 00,F
529C:  BRA    529A
529E:  GOTO   6DDA (RETURN)
.................... } 
....................  
.................... unsigned int8 get_bcd(BYTE data) 
*
5904:  CLRF   19
5906:  BTFSC  FF2.7
5908:  BSF    19.7
590A:  BCF    FF2.7
.................... { 
....................    unsigned int8 nibh; 
....................    unsigned int8 nibl; 
....................  
....................    nibh=data/10; 
590C:  MOVFF  A95,AC5
5910:  MOVLW  0A
5912:  MOVLB  A
5914:  MOVWF  xC6
5916:  MOVLB  0
5918:  CALL   180A
591C:  BTFSC  19.7
591E:  BSF    FF2.7
5920:  MOVFF  01,A96
....................    nibl=data-(nibh*10); 
5924:  MOVLB  A
5926:  MOVF   x96,W
5928:  MULLW  0A
592A:  MOVF   FF3,W
592C:  SUBWF  x95,W
592E:  MOVWF  x97
....................  
....................    return((nibh<<4)|nibl); 
5930:  SWAPF  x96,W
5932:  MOVWF  00
5934:  MOVLW  F0
5936:  ANDWF  00,F
5938:  MOVF   00,W
593A:  IORWF  x97,W
593C:  MOVWF  01
593E:  MOVLB  0
5940:  RETURN 0
.................... } 
....................  
.................... unsigned int8 rm_bcd(BYTE data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    i=data; 
*
3928:  MOVFF  ABE,ABF
....................    data=(i>>4)*10; 
392C:  MOVLB  A
392E:  SWAPF  xBF,W
3930:  MOVWF  00
3932:  MOVLW  0F
3934:  ANDWF  00,F
3936:  MOVF   00,W
3938:  MULLW  0A
393A:  MOVFF  FF3,ABE
....................    data=data+(i<<4>>4); 
393E:  SWAPF  xBF,W
3940:  MOVWF  00
3942:  MOVLW  F0
3944:  ANDWF  00,F
3946:  MOVF   00,W
3948:  SWAPF  00,F
394A:  MOVLW  0F
394C:  ANDWF  00,F
394E:  MOVF   00,W
3950:  ADDWF  xBE,F
....................  
....................    return data; 
3952:  MOVFF  ABE,01
3956:  MOVLB  0
3958:  RETURN 0
.................... } 
....................  
.................... void rtc_set_datetime(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min) 
.................... { 
....................    /*i2c_start(); 
....................    i2c_write(DS1307_SEC); 
....................    //i2c_write(0x00); 
....................    i2c_write(get_bcd(min)); 
....................    i2c_write(get_bcd(hr)); 
....................    i2c_write(get_bcd(dow)); 
....................    i2c_write(get_bcd(day)); 
....................    //i2c_write(0x01); 
....................    i2c_write(get_bcd(mth)); 
....................    i2c_write(get_bcd(year)); 
....................    i2c_stop();*/ 
....................    write_DS1307(DS1307_SEC,0x00); 
*
5942:  MOVLB  A
5944:  CLRF   x96
5946:  CLRF   x97
5948:  MOVLB  0
594A:  RCALL  5856
....................    write_DS1307(DS1307_MIN,get_bcd(min)); 
594C:  MOVFF  A94,A95
5950:  RCALL  5904
5952:  MOVFF  01,A95
5956:  MOVLW  01
5958:  MOVLB  A
595A:  MOVWF  x96
595C:  MOVFF  01,A97
5960:  MOVLB  0
5962:  RCALL  5856
....................    write_DS1307(DS1307_HR,get_bcd(hr)); 
5964:  MOVFF  A93,A95
5968:  RCALL  5904
596A:  MOVFF  01,A95
596E:  MOVLW  02
5970:  MOVLB  A
5972:  MOVWF  x96
5974:  MOVFF  01,A97
5978:  MOVLB  0
597A:  RCALL  5856
....................    write_DS1307(DS1307_DAY,get_bcd(dow)); 
597C:  MOVFF  A92,A95
5980:  RCALL  5904
5982:  MOVFF  01,A95
5986:  MOVLW  03
5988:  MOVLB  A
598A:  MOVWF  x96
598C:  MOVFF  01,A97
5990:  MOVLB  0
5992:  RCALL  5856
....................    write_DS1307(DS1307_DATE,get_bcd(day)); 
5994:  MOVFF  A8F,A95
5998:  RCALL  5904
599A:  MOVFF  01,A95
599E:  MOVLW  04
59A0:  MOVLB  A
59A2:  MOVWF  x96
59A4:  MOVFF  01,A97
59A8:  MOVLB  0
59AA:  RCALL  5856
....................    write_DS1307(DS1307_MONTH,get_bcd(mth)); 
59AC:  MOVFF  A90,A95
59B0:  RCALL  5904
59B2:  MOVFF  01,A95
59B6:  MOVLW  05
59B8:  MOVLB  A
59BA:  MOVWF  x96
59BC:  MOVFF  01,A97
59C0:  MOVLB  0
59C2:  RCALL  5856
....................    write_DS1307(DS1307_YR,get_bcd(year)); 
59C4:  MOVFF  A91,A95
59C8:  RCALL  5904
59CA:  MOVFF  01,A95
59CE:  MOVLW  06
59D0:  MOVLB  A
59D2:  MOVWF  x96
59D4:  MOVFF  01,A97
59D8:  MOVLB  0
59DA:  RCALL  5856
....................    write_DS1307(DS1307_CONTROL,0);    
59DC:  MOVLW  07
59DE:  MOVLB  A
59E0:  MOVWF  x96
59E2:  CLRF   x97
59E4:  MOVLB  0
59E6:  RCALL  5856
59E8:  GOTO   5A52 (RETURN)
.................... } 
....................  
.................... void rtc_get_date(BYTE &date, BYTE &mth, BYTE &year, BYTE &dow) 
.................... { 
....................    date = rm_bcd(read_DS1307(DS1307_DATE)); 
*
3FFE:  MOVLW  04
4000:  MOVLB  A
4002:  MOVWF  xBD
4004:  MOVLB  0
4006:  RCALL  3890
4008:  MOVFF  01,AB9
400C:  MOVFF  01,ABE
4010:  RCALL  3928
4012:  MOVFF  01,100
....................    mth = rm_bcd(read_DS1307(DS1307_MONTH)); 
4016:  MOVLW  05
4018:  MOVLB  A
401A:  MOVWF  xBD
401C:  MOVLB  0
401E:  RCALL  3890
4020:  MOVFF  01,AB9
4024:  MOVFF  01,ABE
4028:  RCALL  3928
402A:  MOVFF  01,FF
....................    year = rm_bcd(read_DS1307(DS1307_YR)); 
402E:  MOVLW  06
4030:  MOVLB  A
4032:  MOVWF  xBD
4034:  MOVLB  0
4036:  RCALL  3890
4038:  MOVFF  01,AB9
403C:  MOVFF  01,ABE
4040:  RCALL  3928
4042:  MOVFF  01,FE
....................    dow = rm_bcd(read_DS1307(DS1307_DAY)); 
4046:  MOVLW  03
4048:  MOVLB  A
404A:  MOVWF  xBD
404C:  MOVLB  0
404E:  RCALL  3890
4050:  MOVFF  01,AB9
4054:  MOVFF  01,ABE
4058:  RCALL  3928
405A:  MOVFF  01,FD
.................... } 
....................  
.................... void rtc_get_time(BYTE &hr, BYTE &min, BYTE &sec) 
.................... { 
....................    hr = rm_bcd(read_DS1307(DS1307_HR)); 
405E:  MOVLW  02
4060:  MOVLB  A
4062:  MOVWF  xBD
4064:  MOVLB  0
4066:  RCALL  3890
4068:  MOVFF  01,AB9
406C:  MOVFF  01,ABE
4070:  RCALL  3928
4072:  MOVFF  01,101
....................    min = rm_bcd(read_DS1307(DS1307_MIN)); 
4076:  MOVLW  01
4078:  MOVLB  A
407A:  MOVWF  xBD
407C:  MOVLB  0
407E:  RCALL  3890
4080:  MOVFF  01,AB9
4084:  MOVFF  01,ABE
4088:  RCALL  3928
408A:  MOVFF  01,102
....................    sec = rm_bcd(read_DS1307(DS1307_SEC)); 
408E:  MOVLB  A
4090:  CLRF   xBD
4092:  MOVLB  0
4094:  CALL   3890
4098:  MOVFF  01,AB9
409C:  MOVFF  01,ABE
40A0:  RCALL  3928
40A2:  MOVFF  01,103
.................... } 
....................  
.................... void rtc_write_nvr(BYTE address, BYTE data) 
.................... { 
....................    write_DS1307(address, data); 
.................... } 
....................  
.................... BYTE rtc_read_nvr(BYTE address) 
.................... { 
....................    return(read_DS1307(address)); 
.................... } 
.................... //==================================== 
.................... void mysettime() 
.................... { 
....................    rtc_set_datetime(9,9,14,0,1,0); 
.................... } 
.................... //==================================== 
....................  
.................... int8 count_spam=0,booting=0; 
.................... //#include "KBD.c" 
.................... //#include "I2c.h" 
.................... int16 count_checking=10; 
.................... #include <scan_key.c> 
....................  
....................  
....................  
.................... #define  COL0      PIN_A5 
.................... #define  COL1      PIN_A3 
.................... #define  COL2      PIN_A2 
.................... #define  COL3      PIN_A1 
.................... #define  COL4      PIN_A0 
....................  
.................... #define  ROW0      PIN_B4 
.................... #define  ROW1      PIN_B5 
.................... #define  ROW2      PIN_B6 
.................... #define  ROW3      PIN_B7 
....................  
.................... #define  key       PIN_A7 
....................  
.................... #define  keyprss_on     output_high(PIN_A7) 
.................... #define  keyprss_off    output_low(PIN_A7) 
....................  
.................... //#define  en_getpin      enable_interrupts(INT_TIMER1) 
.................... //#define  dis_getpin     disable_interrupts(INT_TIMER1) 
.................... //#define  ROW4      PIN_B1 
.................... #define  turnoff_bgn_af30s  enable_interrupts(INT_RTCC); 
.................... //#define ALL_ROWS (ROW0|ROW1|ROW2|ROW3|ROW3) 
.................... //#define ALL_COLS (COL0|COL1|COL2|COL3|COL4) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][5] = {{'1','2','3','A','B'}, 
....................                          {'4','5','6','C','D'}, 
....................                          {'7','8','9','E','F'}, 
....................                          {'*','0','#','G','H'} 
....................                          }; 
....................                         
.................... char const newKEYS[4][6] = {{'1','2','3','A','B','C'}, 
....................                             {'4','5','6','D','E','F'}, 
....................                             {'7','8','9','G','H','I'}, 
....................                             {'*','0','#','J','K','M'} 
....................                            };       
....................                           
.................... /*char const newKEYS[4][6] = {{'J','#','0','*','K','M'}, 
....................                             {'G','9','8','7','H','I'}, 
....................                             {'D','6','5','4','E','F'}, 
....................                             {'A','3','2','1','B','C'} 
....................                            };     
....................                            */ 
....................  
.................... #define KBD_DEBOUNCE_FACTOR  1    // Set this number to apx n/333 where 
....................                                   // n is the number of times you expect 
....................                                   // to call kbd_getc each second 
.................... #define KBD_DEBOUNCE_FACTOR_SL  5 
....................  
.................... #define wait_SL  10000 
....................  
.................... //unsigned int32 count_timer0=0; 
.................... unsigned int16 key_timeout=1000; 
.................... int8 delaykey=0; 
.................... int8 keydebug_en=0; 
.................... int8 enable_getpin=0; 
.................... int8 count_strobe_kb=100; 
.................... int8 key_count_ms=0; 
.................... int8 KP_mode=0,kp_st=0; 
.................... int16 count_kp=0; 
.................... int8 type_KB=0; 
.................... #define key_numbyte  50 
....................  
.................... int8 key_data[key_numbyte]; 
.................... int8 delaycharaction=0; 
.................... void kbd_init() { 
.................... } 
.................... //==================== 
.................... void delay_kb(int32 tim) 
.................... { 
....................    int32 i; 
....................    for(i=0;i<tim;i++); 
.................... } 
.................... //==================== 
....................  
.................... int8 kbd_getc() { 
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    static BYTE col; 
....................    BYTE kchar; 
....................    BYTE row; 
....................    //kchar='t';//'\0'; 
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
*
23B8:  MOVLB  1
23BA:  INCF   x47,F
23BC:  MOVF   x47,W
23BE:  SUBLW  01
23C0:  BTFSC  FD8.0
23C2:  BRA    256A
....................        switch (col) { 
23C4:  MOVF   x4A,W
23C6:  ADDLW  FB
23C8:  BC    244C
23CA:  ADDLW  05
23CC:  MOVLB  0
23CE:  GOTO   2574
....................          case 0   :  
....................                     output_low(COL0); 
23D2:  BCF    F92.5
23D4:  BCF    F89.5
....................                     output_high(COL1); 
23D6:  BCF    F92.3
23D8:  BSF    F89.3
....................                     output_high(COL2); 
23DA:  BCF    F92.2
23DC:  BSF    F89.2
....................                     output_high(COL3); 
23DE:  BCF    F92.1
23E0:  BSF    F89.1
....................                     output_high(COL4); 
23E2:  BCF    F92.0
23E4:  BSF    F89.0
....................                     break; 
23E6:  MOVLB  1
23E8:  BRA    244C
....................          case 1   :  
....................                     output_low(COL1); 
23EA:  BCF    F92.3
23EC:  BCF    F89.3
....................                     output_high(COL0); 
23EE:  BCF    F92.5
23F0:  BSF    F89.5
....................                     output_high(COL2); 
23F2:  BCF    F92.2
23F4:  BSF    F89.2
....................                     output_high(COL3); 
23F6:  BCF    F92.1
23F8:  BSF    F89.1
....................                     output_high(COL4); 
23FA:  BCF    F92.0
23FC:  BSF    F89.0
....................                     break; 
23FE:  MOVLB  1
2400:  BRA    244C
....................          case 2   :  
....................                     output_low(COL2); 
2402:  BCF    F92.2
2404:  BCF    F89.2
....................                     output_high(COL1); 
2406:  BCF    F92.3
2408:  BSF    F89.3
....................                     output_high(COL0); 
240A:  BCF    F92.5
240C:  BSF    F89.5
....................                     output_high(COL3); 
240E:  BCF    F92.1
2410:  BSF    F89.1
....................                     output_high(COL4); 
2412:  BCF    F92.0
2414:  BSF    F89.0
....................                     break; 
2416:  MOVLB  1
2418:  BRA    244C
....................          case 3   :  
....................                     output_low(COL3); 
241A:  BCF    F92.1
241C:  BCF    F89.1
....................                     output_high(COL1); 
241E:  BCF    F92.3
2420:  BSF    F89.3
....................                     output_high(COL2); 
2422:  BCF    F92.2
2424:  BSF    F89.2
....................                     output_high(COL0); 
2426:  BCF    F92.5
2428:  BSF    F89.5
....................                     output_high(COL4); 
242A:  BCF    F92.0
242C:  BSF    F89.0
....................                     break; 
242E:  MOVLB  1
2430:  BRA    244C
....................          case 4   :  
....................                     output_low(COL4); 
2432:  BCF    F92.0
2434:  BCF    F89.0
....................                     output_high(COL1); 
2436:  BCF    F92.3
2438:  BSF    F89.3
....................                     output_high(COL2); 
243A:  BCF    F92.2
243C:  BSF    F89.2
....................                     output_high(COL3); 
243E:  BCF    F92.1
2440:  BSF    F89.1
....................                     output_high(COL0); 
2442:  BCF    F92.5
2444:  BSF    F89.5
....................                     break; 
2446:  MOVLB  1
2448:  BRA    244C
244A:  MOVLB  1
....................        } 
....................  
....................        if(kbd_down)  
244C:  BTFSS  x48.0
244E:  BRA    24CE
....................        { 
....................          if(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3)) 
2450:  BSF    F93.4
2452:  MOVLW  00
2454:  BTFSC  F81.4
2456:  MOVLW  01
2458:  MOVLB  A
245A:  MOVWF  xB8
245C:  BSF    F93.5
245E:  MOVLW  00
2460:  BTFSC  F81.5
2462:  MOVLW  01
2464:  ANDWF  xB8,F
2466:  BSF    F93.6
2468:  MOVLW  00
246A:  BTFSC  F81.6
246C:  MOVLW  01
246E:  ANDWF  xB8,F
2470:  BSF    F93.7
2472:  MOVLW  00
2474:  BTFSC  F81.7
2476:  MOVLW  01
2478:  ANDWF  xB8,W
247A:  BZ    24CA
....................          { 
....................             kchar=last_key; 
247C:  MOVFF  149,AB6
....................             if(keydebug_en==0) 
2480:  MOVLB  1
2482:  MOVF   x0B,F
2484:  BNZ   24B8
....................             { 
....................               //count_timer0=0; 
....................               key_timeout=0; 
2486:  CLRF   x09
2488:  CLRF   x08
....................               charac_timeout=0; 
248A:  MOVLB  0
248C:  CLRF   xFC
248E:  CLRF   xFB
....................             
....................                 
....................                if(key_count_ms<key_numbyte)key_data[key_count_ms++]=kchar; 
2490:  MOVLB  1
2492:  MOVF   x0E,W
2494:  SUBLW  31
2496:  BNC   24AC
2498:  MOVF   x0E,W
249A:  INCF   x0E,F
249C:  CLRF   03
249E:  ADDLW  14
24A0:  MOVWF  FE9
24A2:  MOVLW  01
24A4:  ADDWFC 03,W
24A6:  MOVWF  FEA
24A8:  MOVFF  AB6,FEF
....................                fputc(kchar,COM2); 
24AC:  MOVFF  AB6,ADF
24B0:  MOVLB  0
24B2:  CALL   075A
....................             } 
24B6:  BRA    24C2
....................                else fputc(kchar,COM2); 
24B8:  MOVFF  AB6,ADF
24BC:  MOVLB  0
24BE:  CALL   075A
....................            kbd_down=FALSE; 
24C2:  MOVLB  1
24C4:  BCF    x48.0
....................            last_key=0; 
24C6:  CLRF   x49
24C8:  MOVLB  A
....................          } 
....................        } else 
24CA:  BRA    2566
24CC:  MOVLB  1
....................          { 
....................              if(!(input(ROW0)&input(ROW1)&input(ROW2)&input(ROW3))) 
24CE:  BSF    F93.4
24D0:  MOVLW  00
24D2:  BTFSC  F81.4
24D4:  MOVLW  01
24D6:  MOVLB  A
24D8:  MOVWF  xB8
24DA:  BSF    F93.5
24DC:  MOVLW  00
24DE:  BTFSC  F81.5
24E0:  MOVLW  01
24E2:  ANDWF  xB8,F
24E4:  BSF    F93.6
24E6:  MOVLW  00
24E8:  BTFSC  F81.6
24EA:  MOVLW  01
24EC:  ANDWF  xB8,F
24EE:  BSF    F93.7
24F0:  MOVLW  00
24F2:  BTFSC  F81.7
24F4:  MOVLW  01
24F6:  ANDWF  xB8,W
24F8:  BNZ   2558
....................              { 
....................                 //set_tris_a(0xff); 
....................                 //delay_ms(100); 
....................                 if(input(ROW0)==0) 
24FA:  BSF    F93.4
24FC:  BTFSC  F81.4
24FE:  BRA    2504
....................                   row=0; 
2500:  CLRF   xB7
2502:  BRA    2526
....................                 else if(input(ROW1)==0) 
2504:  BSF    F93.5
2506:  BTFSC  F81.5
2508:  BRA    2510
....................                   row=1; 
250A:  MOVLW  01
250C:  MOVWF  xB7
250E:  BRA    2526
....................                 else if(input(ROW2)==0) 
2510:  BSF    F93.6
2512:  BTFSC  F81.6
2514:  BRA    251C
....................                   row=2; 
2516:  MOVLW  02
2518:  MOVWF  xB7
251A:  BRA    2526
....................                 else if(input(ROW3)==0) 
251C:  BSF    F93.7
251E:  BTFSC  F81.7
2520:  BRA    2526
....................                   row=3; 
2522:  MOVLW  03
2524:  MOVWF  xB7
....................                 /*else if(input(ROW4)==0)  
....................                   row=4;*/ 
....................                 last_key =KEYS[row][col]; 
2526:  MOVF   xB7,W
2528:  MULLW  05
252A:  MOVF   FF3,W
252C:  CLRF   xB9
252E:  MOVWF  xB8
2530:  CLRF   03
2532:  MOVLB  1
2534:  MOVF   x4A,W
2536:  MOVLB  A
2538:  ADDWF  xB8,W
253A:  MOVWF  01
253C:  MOVF   xB9,W
253E:  ADDWFC 03,F
2540:  MOVF   01,W
2542:  MOVLB  0
2544:  CALL   00E8
2548:  MOVFF  FE8,149
....................                 kbd_down = TRUE; 
254C:  MOVLB  1
254E:  BSF    x48.0
....................                 set_tris_a(0xff); 
2550:  MOVLW  FF
2552:  MOVWF  F92
....................                 //lcd_gotoxy(0,1); 
....................                 //lcd_putc(last_key); 
....................              } else  
2554:  BRA    2564
2556:  MOVLB  A
....................                { 
....................                   ++col; 
2558:  MOVLB  1
255A:  INCF   x4A,F
....................                   if(col==5) col=0; 
255C:  MOVF   x4A,W
255E:  SUBLW  05
2560:  BNZ   2564
2562:  CLRF   x4A
2564:  MOVLB  A
....................                } 
....................          } 
....................       kbd_call_count=0; 
2566:  MOVLB  1
2568:  CLRF   x47
....................    } 
....................   return(kchar); 
256A:  MOVLB  A
256C:  MOVFF  AB6,01
2570:  MOVLB  0
2572:  RETURN 0
.................... } 
.................... //=========================== 
.................... //!if((input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 0; 
.................... //!if((input(COL0)==1)&&(input(COL1)==0)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 1; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==0)&&(input(COL3)==1)&&(input(COL4)==1)) col[i] = 2; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==0)&&(input(COL4)==1)) col[i] = 3; 
.................... //!if((input(COL0)==1)&&(input(COL1)==1)&&(input(COL2)==1)&&(input(COL3)==1)&&(input(COL4)==0)) col[i] = 4; 
.................... //! 
.................... //=========================== 
.................... int8 read_col(int8 col) 
.................... { 
....................    int8 adc; 
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|sAN11|VSS_VDD); 
*
2598:  MOVLW  E0
259A:  MOVLB  F
259C:  MOVWF  x48
259E:  BCF    FC2.6
25A0:  BCF    FC2.7
25A2:  MOVF   x49,W
25A4:  ANDLW  E0
25A6:  IORLW  17
25A8:  MOVWF  x49
....................    switch(col) 
25AA:  MOVLB  A
25AC:  MOVF   xD3,W
25AE:  ADDLW  FA
25B0:  BC    267C
25B2:  ADDLW  06
25B4:  MOVLB  0
25B6:  GOTO   2680
....................    { 
....................       case 0: 
....................         set_adc_channel(4); 
25BA:  MOVLW  10
25BC:  MOVWF  01
25BE:  MOVF   FC2,W
25C0:  ANDLW  C3
25C2:  IORWF  01,W
25C4:  MOVWF  FC2
....................         adc=read_adc(); 
25C6:  BSF    FC2.1
25C8:  BTFSC  FC2.1
25CA:  BRA    25C8
25CC:  MOVFF  FC4,AD4
....................         return adc; 
25D0:  MOVLB  A
25D2:  MOVFF  AD4,01
25D6:  BRA    267C
....................       break; 
25D8:  BRA    267C
....................       case 1: 
....................         set_adc_channel(3); 
25DA:  MOVLW  0C
25DC:  MOVWF  01
25DE:  MOVF   FC2,W
25E0:  ANDLW  C3
25E2:  IORWF  01,W
25E4:  MOVWF  FC2
....................         adc=read_adc(); 
25E6:  BSF    FC2.1
25E8:  BTFSC  FC2.1
25EA:  BRA    25E8
25EC:  MOVFF  FC4,AD4
....................         return adc; 
25F0:  MOVLB  A
25F2:  MOVFF  AD4,01
25F6:  BRA    267C
....................       break; 
25F8:  BRA    267C
....................       case 2: 
....................         set_adc_channel(2); 
25FA:  MOVLW  08
25FC:  MOVWF  01
25FE:  MOVF   FC2,W
2600:  ANDLW  C3
2602:  IORWF  01,W
2604:  MOVWF  FC2
....................         adc=read_adc(); 
2606:  BSF    FC2.1
2608:  BTFSC  FC2.1
260A:  BRA    2608
260C:  MOVFF  FC4,AD4
....................         return adc; 
2610:  MOVLB  A
2612:  MOVFF  AD4,01
2616:  BRA    267C
....................       break; 
2618:  BRA    267C
....................       case 3: 
....................         set_adc_channel(1); 
261A:  MOVLW  04
261C:  MOVWF  01
261E:  MOVF   FC2,W
2620:  ANDLW  C3
2622:  IORWF  01,W
2624:  MOVWF  FC2
....................         adc=read_adc(); 
2626:  BSF    FC2.1
2628:  BTFSC  FC2.1
262A:  BRA    2628
262C:  MOVFF  FC4,AD4
....................         return adc; 
2630:  MOVLB  A
2632:  MOVFF  AD4,01
2636:  BRA    267C
....................       break; 
2638:  BRA    267C
....................       case 4: 
....................         set_adc_channel(0); 
263A:  MOVLW  00
263C:  MOVWF  01
263E:  MOVF   FC2,W
2640:  ANDLW  C3
2642:  IORWF  01,W
2644:  MOVWF  FC2
....................         adc=read_adc(); 
2646:  BSF    FC2.1
2648:  BTFSC  FC2.1
264A:  BRA    2648
264C:  MOVFF  FC4,AD4
....................         return adc; 
2650:  MOVLB  A
2652:  MOVFF  AD4,01
2656:  BRA    267C
....................       break;      
2658:  BRA    267C
....................       case 5: 
....................         set_adc_channel(11); 
265A:  MOVLW  2C
265C:  MOVWF  01
265E:  MOVF   FC2,W
2660:  ANDLW  C3
2662:  IORWF  01,W
2664:  MOVWF  FC2
....................         adc=read_adc(); 
2666:  BSF    FC2.1
2668:  BTFSC  FC2.1
266A:  BRA    2668
266C:  MOVFF  FC4,AD4
....................         return adc; 
2670:  MOVLB  A
2672:  MOVFF  AD4,01
2676:  BRA    267C
....................       break;      
2678:  BRA    267C
267A:  MOVLB  A
....................    } 
267C:  MOVLB  0
267E:  RETURN 0
.................... } 
....................  
.................... //=========================== 
.................... int8 check_col() 
*
27FA:  MOVLB  A
27FC:  CLRF   xBE
27FE:  CLRF   xBD
2800:  CLRF   xBC
2802:  CLRF   xBB
2804:  CLRF   xC2
2806:  CLRF   xC1
2808:  CLRF   xC0
280A:  CLRF   xBF
280C:  CLRF   xC6
280E:  CLRF   xC5
2810:  CLRF   xC4
2812:  CLRF   xC3
2814:  CLRF   xCA
2816:  CLRF   xC9
2818:  CLRF   xC8
281A:  CLRF   xC7
281C:  CLRF   xCE
281E:  CLRF   xCD
2820:  CLRF   xCC
2822:  CLRF   xCB
.................... { 
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
2824:  CLRF   xBA
2826:  CLRF   xB9
2828:  MOVF   xBA,W
282A:  SUBLW  01
282C:  BNC   28AA
282E:  BNZ   2836
2830:  MOVF   xB9,W
2832:  SUBLW  F3
2834:  BNC   28AA
....................    { 
....................       col_0=read_col(0)+col_0; 
2836:  CLRF   xD3
2838:  MOVLB  0
283A:  RCALL  2598
283C:  MOVF   01,W
283E:  MOVLB  A
2840:  ADDWF  xBB,F
2842:  MOVLW  00
2844:  ADDWFC xBC,F
2846:  ADDWFC xBD,F
2848:  ADDWFC xBE,F
....................       col_1=read_col(1)+col_1; 
284A:  MOVLW  01
284C:  MOVWF  xD3
284E:  MOVLB  0
2850:  RCALL  2598
2852:  MOVF   01,W
2854:  MOVLB  A
2856:  ADDWF  xBF,F
2858:  MOVLW  00
285A:  ADDWFC xC0,F
285C:  ADDWFC xC1,F
285E:  ADDWFC xC2,F
....................       col_2=read_col(2)+col_2; 
2860:  MOVLW  02
2862:  MOVWF  xD3
2864:  MOVLB  0
2866:  RCALL  2598
2868:  MOVF   01,W
286A:  MOVLB  A
286C:  ADDWF  xC3,F
286E:  MOVLW  00
2870:  ADDWFC xC4,F
2872:  ADDWFC xC5,F
2874:  ADDWFC xC6,F
....................       col_3=read_col(3)+col_3; 
2876:  MOVLW  03
2878:  MOVWF  xD3
287A:  MOVLB  0
287C:  RCALL  2598
287E:  MOVF   01,W
2880:  MOVLB  A
2882:  ADDWF  xC7,F
2884:  MOVLW  00
2886:  ADDWFC xC8,F
2888:  ADDWFC xC9,F
288A:  ADDWFC xCA,F
....................       col_4=read_col(4)+col_4; 
288C:  MOVLW  04
288E:  MOVWF  xD3
2890:  MOVLB  0
2892:  RCALL  2598
2894:  MOVF   01,W
2896:  MOVLB  A
2898:  ADDWF  xCB,F
289A:  MOVLW  00
289C:  ADDWFC xCC,F
289E:  ADDWFC xCD,F
28A0:  ADDWFC xCE,F
28A2:  INCF   xB9,F
28A4:  BTFSC  FD8.2
28A6:  INCF   xBA,F
28A8:  BRA    2828
....................    } 
....................    col_0=col_0/500; 
28AA:  BCF    FD8.1
28AC:  MOVFF  ABE,AE2
28B0:  MOVFF  ABD,AE1
28B4:  MOVFF  ABC,AE0
28B8:  MOVFF  ABB,ADF
28BC:  CLRF   xE6
28BE:  CLRF   xE5
28C0:  MOVLW  01
28C2:  MOVWF  xE4
28C4:  MOVLW  F4
28C6:  MOVWF  xE3
28C8:  MOVLB  0
28CA:  RCALL  26A6
28CC:  MOVFF  03,ABE
28D0:  MOVFF  02,ABD
28D4:  MOVFF  01,ABC
28D8:  MOVFF  00,ABB
....................    col_1=col_1/500; 
28DC:  BCF    FD8.1
28DE:  MOVFF  AC2,AE2
28E2:  MOVFF  AC1,AE1
28E6:  MOVFF  AC0,AE0
28EA:  MOVFF  ABF,ADF
28EE:  MOVLB  A
28F0:  CLRF   xE6
28F2:  CLRF   xE5
28F4:  MOVLW  01
28F6:  MOVWF  xE4
28F8:  MOVLW  F4
28FA:  MOVWF  xE3
28FC:  MOVLB  0
28FE:  RCALL  26A6
2900:  MOVFF  03,AC2
2904:  MOVFF  02,AC1
2908:  MOVFF  01,AC0
290C:  MOVFF  00,ABF
....................    col_2=col_2/500; 
2910:  BCF    FD8.1
2912:  MOVFF  AC6,AE2
2916:  MOVFF  AC5,AE1
291A:  MOVFF  AC4,AE0
291E:  MOVFF  AC3,ADF
2922:  MOVLB  A
2924:  CLRF   xE6
2926:  CLRF   xE5
2928:  MOVLW  01
292A:  MOVWF  xE4
292C:  MOVLW  F4
292E:  MOVWF  xE3
2930:  MOVLB  0
2932:  RCALL  26A6
2934:  MOVFF  03,AC6
2938:  MOVFF  02,AC5
293C:  MOVFF  01,AC4
2940:  MOVFF  00,AC3
....................    col_3=col_3/500; 
2944:  BCF    FD8.1
2946:  MOVFF  ACA,AE2
294A:  MOVFF  AC9,AE1
294E:  MOVFF  AC8,AE0
2952:  MOVFF  AC7,ADF
2956:  MOVLB  A
2958:  CLRF   xE6
295A:  CLRF   xE5
295C:  MOVLW  01
295E:  MOVWF  xE4
2960:  MOVLW  F4
2962:  MOVWF  xE3
2964:  MOVLB  0
2966:  RCALL  26A6
2968:  MOVFF  03,ACA
296C:  MOVFF  02,AC9
2970:  MOVFF  01,AC8
2974:  MOVFF  00,AC7
....................    col_4=col_4/500; 
2978:  BCF    FD8.1
297A:  MOVFF  ACE,AE2
297E:  MOVFF  ACD,AE1
2982:  MOVFF  ACC,AE0
2986:  MOVFF  ACB,ADF
298A:  MOVLB  A
298C:  CLRF   xE6
298E:  CLRF   xE5
2990:  MOVLW  01
2992:  MOVWF  xE4
2994:  MOVLW  F4
2996:  MOVWF  xE3
2998:  MOVLB  0
299A:  RCALL  26A6
299C:  MOVFF  03,ACE
29A0:  MOVFF  02,ACD
29A4:  MOVFF  01,ACC
29A8:  MOVFF  00,ACB
....................    if(keydebug_en) 
29AC:  MOVLB  1
29AE:  MOVF   x0B,F
29B0:  BTFSC  FD8.2
29B2:  BRA    2B30
....................    { 
....................       fprintf(COM2,"\r\n");      
29B4:  MOVLW  0D
29B6:  MOVLB  A
29B8:  MOVWF  xDF
29BA:  MOVLB  0
29BC:  CALL   075A
29C0:  MOVLW  0A
29C2:  MOVLB  A
29C4:  MOVWF  xDF
29C6:  MOVLB  0
29C8:  CALL   075A
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
29CC:  MOVLW  26
29CE:  MOVWF  FF6
29D0:  MOVLW  04
29D2:  MOVWF  FF7
29D4:  MOVLW  07
29D6:  MOVLB  A
29D8:  MOVWF  xD3
29DA:  MOVLB  0
29DC:  CALL   1718
29E0:  MOVLW  41
29E2:  MOVWF  FE9
29E4:  MOVFF  ABE,AD6
29E8:  MOVFF  ABD,AD5
29EC:  MOVFF  ABC,AD4
29F0:  MOVFF  ABB,AD3
29F4:  RCALL  273A
29F6:  MOVLW  0D
29F8:  MOVLB  A
29FA:  MOVWF  xDF
29FC:  MOVLB  0
29FE:  CALL   075A
2A02:  MOVLW  0A
2A04:  MOVLB  A
2A06:  MOVWF  xDF
2A08:  MOVLB  0
2A0A:  CALL   075A
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
2A0E:  MOVLW  34
2A10:  MOVWF  FF6
2A12:  MOVLW  04
2A14:  MOVWF  FF7
2A16:  MOVLW  07
2A18:  MOVLB  A
2A1A:  MOVWF  xD3
2A1C:  MOVLB  0
2A1E:  CALL   1718
2A22:  MOVLW  41
2A24:  MOVWF  FE9
2A26:  MOVFF  AC2,AD6
2A2A:  MOVFF  AC1,AD5
2A2E:  MOVFF  AC0,AD4
2A32:  MOVFF  ABF,AD3
2A36:  RCALL  273A
2A38:  MOVLW  0D
2A3A:  MOVLB  A
2A3C:  MOVWF  xDF
2A3E:  MOVLB  0
2A40:  CALL   075A
2A44:  MOVLW  0A
2A46:  MOVLB  A
2A48:  MOVWF  xDF
2A4A:  MOVLB  0
2A4C:  CALL   075A
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
2A50:  MOVLW  42
2A52:  MOVWF  FF6
2A54:  MOVLW  04
2A56:  MOVWF  FF7
2A58:  MOVLW  07
2A5A:  MOVLB  A
2A5C:  MOVWF  xD3
2A5E:  MOVLB  0
2A60:  CALL   1718
2A64:  MOVLW  41
2A66:  MOVWF  FE9
2A68:  MOVFF  AC6,AD6
2A6C:  MOVFF  AC5,AD5
2A70:  MOVFF  AC4,AD4
2A74:  MOVFF  AC3,AD3
2A78:  RCALL  273A
2A7A:  MOVLW  0D
2A7C:  MOVLB  A
2A7E:  MOVWF  xDF
2A80:  MOVLB  0
2A82:  CALL   075A
2A86:  MOVLW  0A
2A88:  MOVLB  A
2A8A:  MOVWF  xDF
2A8C:  MOVLB  0
2A8E:  CALL   075A
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
2A92:  MOVLW  50
2A94:  MOVWF  FF6
2A96:  MOVLW  04
2A98:  MOVWF  FF7
2A9A:  MOVLW  07
2A9C:  MOVLB  A
2A9E:  MOVWF  xD3
2AA0:  MOVLB  0
2AA2:  CALL   1718
2AA6:  MOVLW  41
2AA8:  MOVWF  FE9
2AAA:  MOVFF  ACA,AD6
2AAE:  MOVFF  AC9,AD5
2AB2:  MOVFF  AC8,AD4
2AB6:  MOVFF  AC7,AD3
2ABA:  RCALL  273A
2ABC:  MOVLW  0D
2ABE:  MOVLB  A
2AC0:  MOVWF  xDF
2AC2:  MOVLB  0
2AC4:  CALL   075A
2AC8:  MOVLW  0A
2ACA:  MOVLB  A
2ACC:  MOVWF  xDF
2ACE:  MOVLB  0
2AD0:  CALL   075A
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
2AD4:  MOVLW  5E
2AD6:  MOVWF  FF6
2AD8:  MOVLW  04
2ADA:  MOVWF  FF7
2ADC:  MOVLW  07
2ADE:  MOVLB  A
2AE0:  MOVWF  xD3
2AE2:  MOVLB  0
2AE4:  CALL   1718
2AE8:  MOVLW  41
2AEA:  MOVWF  FE9
2AEC:  MOVFF  ACE,AD6
2AF0:  MOVFF  ACD,AD5
2AF4:  MOVFF  ACC,AD4
2AF8:  MOVFF  ACB,AD3
2AFC:  RCALL  273A
2AFE:  MOVLW  0D
2B00:  MOVLB  A
2B02:  MOVWF  xDF
2B04:  MOVLB  0
2B06:  CALL   075A
2B0A:  MOVLW  0A
2B0C:  MOVLB  A
2B0E:  MOVWF  xDF
2B10:  MOVLB  0
2B12:  CALL   075A
....................       fprintf(COM2,"\r\n"); 
2B16:  MOVLW  0D
2B18:  MOVLB  A
2B1A:  MOVWF  xDF
2B1C:  MOVLB  0
2B1E:  CALL   075A
2B22:  MOVLW  0A
2B24:  MOVLB  A
2B26:  MOVWF  xDF
2B28:  MOVLB  0
2B2A:  CALL   075A
2B2E:  MOVLB  1
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 0; 
2B30:  MOVLB  A
2B32:  MOVF   xBE,F
2B34:  BNZ   2B44
2B36:  MOVF   xBD,F
2B38:  BNZ   2B44
2B3A:  MOVF   xBC,F
2B3C:  BNZ   2B44
2B3E:  MOVF   xBB,W
2B40:  SUBLW  05
2B42:  BC    2BA4
2B44:  MOVF   xBE,F
2B46:  BNZ   2BA4
2B48:  MOVF   xBD,F
2B4A:  BNZ   2BA4
2B4C:  MOVF   xBC,F
2B4E:  BNZ   2BA4
2B50:  MOVF   xBB,W
2B52:  SUBLW  3B
2B54:  BNC   2BA4
2B56:  MOVF   xC2,F
2B58:  BNZ   2B68
2B5A:  MOVF   xC1,F
2B5C:  BNZ   2B68
2B5E:  MOVF   xC0,F
2B60:  BNZ   2B68
2B62:  MOVF   xBF,W
2B64:  SUBLW  64
2B66:  BC    2BA4
2B68:  MOVF   xC6,F
2B6A:  BNZ   2B7A
2B6C:  MOVF   xC5,F
2B6E:  BNZ   2B7A
2B70:  MOVF   xC4,F
2B72:  BNZ   2B7A
2B74:  MOVF   xC3,W
2B76:  SUBLW  64
2B78:  BC    2BA4
2B7A:  MOVF   xCA,F
2B7C:  BNZ   2B8C
2B7E:  MOVF   xC9,F
2B80:  BNZ   2B8C
2B82:  MOVF   xC8,F
2B84:  BNZ   2B8C
2B86:  MOVF   xC7,W
2B88:  SUBLW  64
2B8A:  BC    2BA4
2B8C:  MOVF   xCE,F
2B8E:  BNZ   2B9E
2B90:  MOVF   xCD,F
2B92:  BNZ   2B9E
2B94:  MOVF   xCC,F
2B96:  BNZ   2B9E
2B98:  MOVF   xCB,W
2B9A:  SUBLW  64
2B9C:  BC    2BA4
2B9E:  MOVLW  00
2BA0:  MOVWF  01
2BA2:  BRA    2E22
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)) return 1;  
2BA4:  MOVF   xC2,F
2BA6:  BNZ   2BB6
2BA8:  MOVF   xC1,F
2BAA:  BNZ   2BB6
2BAC:  MOVF   xC0,F
2BAE:  BNZ   2BB6
2BB0:  MOVF   xBF,W
2BB2:  SUBLW  05
2BB4:  BC    2C16
2BB6:  MOVF   xC2,F
2BB8:  BNZ   2C16
2BBA:  MOVF   xC1,F
2BBC:  BNZ   2C16
2BBE:  MOVF   xC0,F
2BC0:  BNZ   2C16
2BC2:  MOVF   xBF,W
2BC4:  SUBLW  3B
2BC6:  BNC   2C16
2BC8:  MOVF   xBE,F
2BCA:  BNZ   2BDA
2BCC:  MOVF   xBD,F
2BCE:  BNZ   2BDA
2BD0:  MOVF   xBC,F
2BD2:  BNZ   2BDA
2BD4:  MOVF   xBB,W
2BD6:  SUBLW  64
2BD8:  BC    2C16
2BDA:  MOVF   xC6,F
2BDC:  BNZ   2BEC
2BDE:  MOVF   xC5,F
2BE0:  BNZ   2BEC
2BE2:  MOVF   xC4,F
2BE4:  BNZ   2BEC
2BE6:  MOVF   xC3,W
2BE8:  SUBLW  64
2BEA:  BC    2C16
2BEC:  MOVF   xCA,F
2BEE:  BNZ   2BFE
2BF0:  MOVF   xC9,F
2BF2:  BNZ   2BFE
2BF4:  MOVF   xC8,F
2BF6:  BNZ   2BFE
2BF8:  MOVF   xC7,W
2BFA:  SUBLW  64
2BFC:  BC    2C16
2BFE:  MOVF   xCE,F
2C00:  BNZ   2C10
2C02:  MOVF   xCD,F
2C04:  BNZ   2C10
2C06:  MOVF   xCC,F
2C08:  BNZ   2C10
2C0A:  MOVF   xCB,W
2C0C:  SUBLW  64
2C0E:  BC    2C16
2C10:  MOVLW  01
2C12:  MOVWF  01
2C14:  BRA    2E22
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)) return 2;  
2C16:  MOVF   xC6,F
2C18:  BNZ   2C28
2C1A:  MOVF   xC5,F
2C1C:  BNZ   2C28
2C1E:  MOVF   xC4,F
2C20:  BNZ   2C28
2C22:  MOVF   xC3,W
2C24:  SUBLW  05
2C26:  BC    2C88
2C28:  MOVF   xC6,F
2C2A:  BNZ   2C88
2C2C:  MOVF   xC5,F
2C2E:  BNZ   2C88
2C30:  MOVF   xC4,F
2C32:  BNZ   2C88
2C34:  MOVF   xC3,W
2C36:  SUBLW  3B
2C38:  BNC   2C88
2C3A:  MOVF   xC2,F
2C3C:  BNZ   2C4C
2C3E:  MOVF   xC1,F
2C40:  BNZ   2C4C
2C42:  MOVF   xC0,F
2C44:  BNZ   2C4C
2C46:  MOVF   xBF,W
2C48:  SUBLW  64
2C4A:  BC    2C88
2C4C:  MOVF   xBE,F
2C4E:  BNZ   2C5E
2C50:  MOVF   xBD,F
2C52:  BNZ   2C5E
2C54:  MOVF   xBC,F
2C56:  BNZ   2C5E
2C58:  MOVF   xBB,W
2C5A:  SUBLW  64
2C5C:  BC    2C88
2C5E:  MOVF   xCA,F
2C60:  BNZ   2C70
2C62:  MOVF   xC9,F
2C64:  BNZ   2C70
2C66:  MOVF   xC8,F
2C68:  BNZ   2C70
2C6A:  MOVF   xC7,W
2C6C:  SUBLW  64
2C6E:  BC    2C88
2C70:  MOVF   xCE,F
2C72:  BNZ   2C82
2C74:  MOVF   xCD,F
2C76:  BNZ   2C82
2C78:  MOVF   xCC,F
2C7A:  BNZ   2C82
2C7C:  MOVF   xCB,W
2C7E:  SUBLW  64
2C80:  BC    2C88
2C82:  MOVLW  02
2C84:  MOVWF  01
2C86:  BRA    2E22
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)) return 3; 
2C88:  MOVF   xCA,F
2C8A:  BNZ   2C9A
2C8C:  MOVF   xC9,F
2C8E:  BNZ   2C9A
2C90:  MOVF   xC8,F
2C92:  BNZ   2C9A
2C94:  MOVF   xC7,W
2C96:  SUBLW  05
2C98:  BC    2CFA
2C9A:  MOVF   xCA,F
2C9C:  BNZ   2CFA
2C9E:  MOVF   xC9,F
2CA0:  BNZ   2CFA
2CA2:  MOVF   xC8,F
2CA4:  BNZ   2CFA
2CA6:  MOVF   xC7,W
2CA8:  SUBLW  3B
2CAA:  BNC   2CFA
2CAC:  MOVF   xC2,F
2CAE:  BNZ   2CBE
2CB0:  MOVF   xC1,F
2CB2:  BNZ   2CBE
2CB4:  MOVF   xC0,F
2CB6:  BNZ   2CBE
2CB8:  MOVF   xBF,W
2CBA:  SUBLW  64
2CBC:  BC    2CFA
2CBE:  MOVF   xC6,F
2CC0:  BNZ   2CD0
2CC2:  MOVF   xC5,F
2CC4:  BNZ   2CD0
2CC6:  MOVF   xC4,F
2CC8:  BNZ   2CD0
2CCA:  MOVF   xC3,W
2CCC:  SUBLW  64
2CCE:  BC    2CFA
2CD0:  MOVF   xBE,F
2CD2:  BNZ   2CE2
2CD4:  MOVF   xBD,F
2CD6:  BNZ   2CE2
2CD8:  MOVF   xBC,F
2CDA:  BNZ   2CE2
2CDC:  MOVF   xBB,W
2CDE:  SUBLW  64
2CE0:  BC    2CFA
2CE2:  MOVF   xCE,F
2CE4:  BNZ   2CF4
2CE6:  MOVF   xCD,F
2CE8:  BNZ   2CF4
2CEA:  MOVF   xCC,F
2CEC:  BNZ   2CF4
2CEE:  MOVF   xCB,W
2CF0:  SUBLW  64
2CF2:  BC    2CFA
2CF4:  MOVLW  03
2CF6:  MOVWF  01
2CF8:  BRA    2E22
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)) return 4;  
2CFA:  MOVF   xCE,F
2CFC:  BNZ   2D0C
2CFE:  MOVF   xCD,F
2D00:  BNZ   2D0C
2D02:  MOVF   xCC,F
2D04:  BNZ   2D0C
2D06:  MOVF   xCB,W
2D08:  SUBLW  05
2D0A:  BC    2D6C
2D0C:  MOVF   xCE,F
2D0E:  BNZ   2D6C
2D10:  MOVF   xCD,F
2D12:  BNZ   2D6C
2D14:  MOVF   xCC,F
2D16:  BNZ   2D6C
2D18:  MOVF   xCB,W
2D1A:  SUBLW  3B
2D1C:  BNC   2D6C
2D1E:  MOVF   xC2,F
2D20:  BNZ   2D30
2D22:  MOVF   xC1,F
2D24:  BNZ   2D30
2D26:  MOVF   xC0,F
2D28:  BNZ   2D30
2D2A:  MOVF   xBF,W
2D2C:  SUBLW  64
2D2E:  BC    2D6C
2D30:  MOVF   xC6,F
2D32:  BNZ   2D42
2D34:  MOVF   xC5,F
2D36:  BNZ   2D42
2D38:  MOVF   xC4,F
2D3A:  BNZ   2D42
2D3C:  MOVF   xC3,W
2D3E:  SUBLW  64
2D40:  BC    2D6C
2D42:  MOVF   xCA,F
2D44:  BNZ   2D54
2D46:  MOVF   xC9,F
2D48:  BNZ   2D54
2D4A:  MOVF   xC8,F
2D4C:  BNZ   2D54
2D4E:  MOVF   xC7,W
2D50:  SUBLW  64
2D52:  BC    2D6C
2D54:  MOVF   xBE,F
2D56:  BNZ   2D66
2D58:  MOVF   xBD,F
2D5A:  BNZ   2D66
2D5C:  MOVF   xBC,F
2D5E:  BNZ   2D66
2D60:  MOVF   xBB,W
2D62:  SUBLW  64
2D64:  BC    2D6C
2D66:  MOVLW  04
2D68:  MOVWF  01
2D6A:  BRA    2E22
....................     
....................    if((col_4>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)) return 4; 
2D6C:  MOVF   xCE,F
2D6E:  BNZ   2D80
2D70:  MOVF   xCD,F
2D72:  BNZ   2D80
2D74:  MOVF   xCC,F
2D76:  BNZ   2D80
2D78:  MOVF   xCB,W
2D7A:  SUBLW  C8
2D7C:  BTFSC  FD8.0
2D7E:  BRA    2E1E
2D80:  MOVF   xBE,F
2D82:  BTFSS  FD8.2
2D84:  BRA    2E1E
2D86:  MOVF   xBD,F
2D88:  BTFSS  FD8.2
2D8A:  BRA    2E1E
2D8C:  MOVF   xBC,F
2D8E:  BTFSS  FD8.2
2D90:  BRA    2E1E
2D92:  MOVF   xBB,W
2D94:  SUBLW  B3
2D96:  BNC   2E1E
2D98:  MOVF   xBE,F
2D9A:  BNZ   2DAA
2D9C:  MOVF   xBD,F
2D9E:  BNZ   2DAA
2DA0:  MOVF   xBC,F
2DA2:  BNZ   2DAA
2DA4:  MOVF   xBB,W
2DA6:  SUBLW  64
2DA8:  BC    2E1E
2DAA:  MOVF   xC2,F
2DAC:  BNZ   2E1E
2DAE:  MOVF   xC1,F
2DB0:  BNZ   2E1E
2DB2:  MOVF   xC0,F
2DB4:  BNZ   2E1E
2DB6:  MOVF   xBF,W
2DB8:  SUBLW  B3
2DBA:  BNC   2E1E
2DBC:  MOVF   xC2,F
2DBE:  BNZ   2DCE
2DC0:  MOVF   xC1,F
2DC2:  BNZ   2DCE
2DC4:  MOVF   xC0,F
2DC6:  BNZ   2DCE
2DC8:  MOVF   xBF,W
2DCA:  SUBLW  64
2DCC:  BC    2E1E
2DCE:  MOVF   xC6,F
2DD0:  BNZ   2E1E
2DD2:  MOVF   xC5,F
2DD4:  BNZ   2E1E
2DD6:  MOVF   xC4,F
2DD8:  BNZ   2E1E
2DDA:  MOVF   xC3,W
2DDC:  SUBLW  B3
2DDE:  BNC   2E1E
2DE0:  MOVF   xC6,F
2DE2:  BNZ   2DF2
2DE4:  MOVF   xC5,F
2DE6:  BNZ   2DF2
2DE8:  MOVF   xC4,F
2DEA:  BNZ   2DF2
2DEC:  MOVF   xC3,W
2DEE:  SUBLW  64
2DF0:  BC    2E1E
2DF2:  MOVF   xCA,F
2DF4:  BNZ   2E1E
2DF6:  MOVF   xC9,F
2DF8:  BNZ   2E1E
2DFA:  MOVF   xC8,F
2DFC:  BNZ   2E1E
2DFE:  MOVF   xC7,W
2E00:  SUBLW  B3
2E02:  BNC   2E1E
2E04:  MOVF   xCA,F
2E06:  BNZ   2E16
2E08:  MOVF   xC9,F
2E0A:  BNZ   2E16
2E0C:  MOVF   xC8,F
2E0E:  BNZ   2E16
2E10:  MOVF   xC7,W
2E12:  SUBLW  64
2E14:  BC    2E1E
2E16:  MOVLW  04
2E18:  MOVWF  01
2E1A:  BRA    2E22
2E1C:  BRA    2E22
....................    /*// thong so cho mach o nha 
....................    if((col_0>25)&&(col_0<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 0; 
....................    if((col_1>25)&&(col_1<50)&&(col_0>50)&&(col_2>50)&&(col_3>50)&&(col_4>50)) return 1;  
....................    if((col_2>25)&&(col_2<50)&&(col_1>50)&&(col_0>50)&&(col_3>50)&&(col_4>50)) return 2;  
....................    if((col_3>25)&&(col_3<50)&&(col_1>50)&&(col_2>50)&&(col_0>50)&&(col_4>50)) return 3; 
....................    if((col_4>25)&&(col_4<50)&&(col_1>50)&&(col_2>50)&&(col_3>50)&&(col_0>50)) return 4; */ 
....................     
.................... //!   if((col_0<35)&&(col_0>col_1)&&(col_0>col_2)&&(col_0>col_3)&&(col_0>col_4)) return 0; 
.................... //!   if((col_1<35)&&(col_1>col_0)&&(col_1>col_2)&&(col_1>col_3)&&(col_1>col_4)) return 1; 
.................... //!   if((col_2<35)&&(col_2>col_0)&&(col_2>col_1)&&(col_2>col_3)&&(col_2>col_4)) return 2; 
.................... //!   if((col_3<35)&&(col_3>col_0)&&(col_3>col_1)&&(col_3>col_2)&&(col_3>col_4)) return 3; 
.................... //!   if((col_4<35)&&(col_4>col_0)&&(col_4>col_1)&&(col_4>col_3)&&(col_4>col_2)) return 4; 
....................    else return 0xff; 
2E1E:  MOVLW  FF
2E20:  MOVWF  01
2E22:  MOVLB  0
2E24:  GOTO   3670 (RETURN)
.................... } 
.................... //=========================================== 
.................... int8 new_check_col() 
2E28:  MOVLB  A
2E2A:  CLRF   xBE
2E2C:  CLRF   xBD
2E2E:  CLRF   xBC
2E30:  CLRF   xBB
2E32:  CLRF   xC2
2E34:  CLRF   xC1
2E36:  CLRF   xC0
2E38:  CLRF   xBF
2E3A:  CLRF   xC6
2E3C:  CLRF   xC5
2E3E:  CLRF   xC4
2E40:  CLRF   xC3
2E42:  CLRF   xCA
2E44:  CLRF   xC9
2E46:  CLRF   xC8
2E48:  CLRF   xC7
2E4A:  CLRF   xCE
2E4C:  CLRF   xCD
2E4E:  CLRF   xCC
2E50:  CLRF   xCB
2E52:  CLRF   xD2
2E54:  CLRF   xD1
2E56:  CLRF   xD0
2E58:  CLRF   xCF
.................... { 
....................    int16 i; 
....................    int32 col_0=0,col_1=0,col_2=0,col_3=0,col_4=0,col_5=0; 
....................    ///for(i=0;i<50;i++)col[i]=0; 
....................     
....................    for(i=0;i<500;i++) 
2E5A:  CLRF   xBA
2E5C:  CLRF   xB9
2E5E:  MOVF   xBA,W
2E60:  SUBLW  01
2E62:  BNC   2F02
2E64:  BNZ   2E6C
2E66:  MOVF   xB9,W
2E68:  SUBLW  F3
2E6A:  BNC   2F02
....................    { 
....................       col_0=read_col(0)+col_0; 
2E6C:  CLRF   xD3
2E6E:  MOVLB  0
2E70:  CALL   2598
2E74:  MOVF   01,W
2E76:  MOVLB  A
2E78:  ADDWF  xBB,F
2E7A:  MOVLW  00
2E7C:  ADDWFC xBC,F
2E7E:  ADDWFC xBD,F
2E80:  ADDWFC xBE,F
....................       col_1=read_col(1)+col_1; 
2E82:  MOVLW  01
2E84:  MOVWF  xD3
2E86:  MOVLB  0
2E88:  CALL   2598
2E8C:  MOVF   01,W
2E8E:  MOVLB  A
2E90:  ADDWF  xBF,F
2E92:  MOVLW  00
2E94:  ADDWFC xC0,F
2E96:  ADDWFC xC1,F
2E98:  ADDWFC xC2,F
....................       col_2=read_col(2)+col_2; 
2E9A:  MOVLW  02
2E9C:  MOVWF  xD3
2E9E:  MOVLB  0
2EA0:  CALL   2598
2EA4:  MOVF   01,W
2EA6:  MOVLB  A
2EA8:  ADDWF  xC3,F
2EAA:  MOVLW  00
2EAC:  ADDWFC xC4,F
2EAE:  ADDWFC xC5,F
2EB0:  ADDWFC xC6,F
....................       col_3=read_col(3)+col_3; 
2EB2:  MOVLW  03
2EB4:  MOVWF  xD3
2EB6:  MOVLB  0
2EB8:  CALL   2598
2EBC:  MOVF   01,W
2EBE:  MOVLB  A
2EC0:  ADDWF  xC7,F
2EC2:  MOVLW  00
2EC4:  ADDWFC xC8,F
2EC6:  ADDWFC xC9,F
2EC8:  ADDWFC xCA,F
....................       col_4=read_col(4)+col_4; 
2ECA:  MOVLW  04
2ECC:  MOVWF  xD3
2ECE:  MOVLB  0
2ED0:  CALL   2598
2ED4:  MOVF   01,W
2ED6:  MOVLB  A
2ED8:  ADDWF  xCB,F
2EDA:  MOVLW  00
2EDC:  ADDWFC xCC,F
2EDE:  ADDWFC xCD,F
2EE0:  ADDWFC xCE,F
....................       col_5=read_col(5)+col_5; 
2EE2:  MOVLW  05
2EE4:  MOVWF  xD3
2EE6:  MOVLB  0
2EE8:  CALL   2598
2EEC:  MOVF   01,W
2EEE:  MOVLB  A
2EF0:  ADDWF  xCF,F
2EF2:  MOVLW  00
2EF4:  ADDWFC xD0,F
2EF6:  ADDWFC xD1,F
2EF8:  ADDWFC xD2,F
2EFA:  INCF   xB9,F
2EFC:  BTFSC  FD8.2
2EFE:  INCF   xBA,F
2F00:  BRA    2E5E
....................    } 
....................    col_0=col_0/500; 
2F02:  BCF    FD8.1
2F04:  MOVFF  ABE,AE2
2F08:  MOVFF  ABD,AE1
2F0C:  MOVFF  ABC,AE0
2F10:  MOVFF  ABB,ADF
2F14:  CLRF   xE6
2F16:  CLRF   xE5
2F18:  MOVLW  01
2F1A:  MOVWF  xE4
2F1C:  MOVLW  F4
2F1E:  MOVWF  xE3
2F20:  MOVLB  0
2F22:  CALL   26A6
2F26:  MOVFF  03,ABE
2F2A:  MOVFF  02,ABD
2F2E:  MOVFF  01,ABC
2F32:  MOVFF  00,ABB
....................    col_1=col_1/500; 
2F36:  BCF    FD8.1
2F38:  MOVFF  AC2,AE2
2F3C:  MOVFF  AC1,AE1
2F40:  MOVFF  AC0,AE0
2F44:  MOVFF  ABF,ADF
2F48:  MOVLB  A
2F4A:  CLRF   xE6
2F4C:  CLRF   xE5
2F4E:  MOVLW  01
2F50:  MOVWF  xE4
2F52:  MOVLW  F4
2F54:  MOVWF  xE3
2F56:  MOVLB  0
2F58:  CALL   26A6
2F5C:  MOVFF  03,AC2
2F60:  MOVFF  02,AC1
2F64:  MOVFF  01,AC0
2F68:  MOVFF  00,ABF
....................    col_2=col_2/500; 
2F6C:  BCF    FD8.1
2F6E:  MOVFF  AC6,AE2
2F72:  MOVFF  AC5,AE1
2F76:  MOVFF  AC4,AE0
2F7A:  MOVFF  AC3,ADF
2F7E:  MOVLB  A
2F80:  CLRF   xE6
2F82:  CLRF   xE5
2F84:  MOVLW  01
2F86:  MOVWF  xE4
2F88:  MOVLW  F4
2F8A:  MOVWF  xE3
2F8C:  MOVLB  0
2F8E:  CALL   26A6
2F92:  MOVFF  03,AC6
2F96:  MOVFF  02,AC5
2F9A:  MOVFF  01,AC4
2F9E:  MOVFF  00,AC3
....................    col_3=col_3/500; 
2FA2:  BCF    FD8.1
2FA4:  MOVFF  ACA,AE2
2FA8:  MOVFF  AC9,AE1
2FAC:  MOVFF  AC8,AE0
2FB0:  MOVFF  AC7,ADF
2FB4:  MOVLB  A
2FB6:  CLRF   xE6
2FB8:  CLRF   xE5
2FBA:  MOVLW  01
2FBC:  MOVWF  xE4
2FBE:  MOVLW  F4
2FC0:  MOVWF  xE3
2FC2:  MOVLB  0
2FC4:  CALL   26A6
2FC8:  MOVFF  03,ACA
2FCC:  MOVFF  02,AC9
2FD0:  MOVFF  01,AC8
2FD4:  MOVFF  00,AC7
....................    col_4=col_4/500; 
2FD8:  BCF    FD8.1
2FDA:  MOVFF  ACE,AE2
2FDE:  MOVFF  ACD,AE1
2FE2:  MOVFF  ACC,AE0
2FE6:  MOVFF  ACB,ADF
2FEA:  MOVLB  A
2FEC:  CLRF   xE6
2FEE:  CLRF   xE5
2FF0:  MOVLW  01
2FF2:  MOVWF  xE4
2FF4:  MOVLW  F4
2FF6:  MOVWF  xE3
2FF8:  MOVLB  0
2FFA:  CALL   26A6
2FFE:  MOVFF  03,ACE
3002:  MOVFF  02,ACD
3006:  MOVFF  01,ACC
300A:  MOVFF  00,ACB
....................    col_5=col_5/500; 
300E:  BCF    FD8.1
3010:  MOVFF  AD2,AE2
3014:  MOVFF  AD1,AE1
3018:  MOVFF  AD0,AE0
301C:  MOVFF  ACF,ADF
3020:  MOVLB  A
3022:  CLRF   xE6
3024:  CLRF   xE5
3026:  MOVLW  01
3028:  MOVWF  xE4
302A:  MOVLW  F4
302C:  MOVWF  xE3
302E:  MOVLB  0
3030:  CALL   26A6
3034:  MOVFF  03,AD2
3038:  MOVFF  02,AD1
303C:  MOVFF  01,AD0
3040:  MOVFF  00,ACF
....................    if(keydebug_en) 
3044:  MOVLB  1
3046:  MOVF   x0B,F
3048:  BTFSC  FD8.2
304A:  BRA    3216
....................    { 
....................       fprintf(COM2,"\r\n");      
304C:  MOVLW  0D
304E:  MOVLB  A
3050:  MOVWF  xDF
3052:  MOVLB  0
3054:  CALL   075A
3058:  MOVLW  0A
305A:  MOVLB  A
305C:  MOVWF  xDF
305E:  MOVLB  0
3060:  CALL   075A
....................       fprintf(COM2,"col0 = %lu\r\n",col_0);      
3064:  MOVLW  6C
3066:  MOVWF  FF6
3068:  MOVLW  04
306A:  MOVWF  FF7
306C:  MOVLW  07
306E:  MOVLB  A
3070:  MOVWF  xD3
3072:  MOVLB  0
3074:  CALL   1718
3078:  MOVLW  41
307A:  MOVWF  FE9
307C:  MOVFF  ABE,AD6
3080:  MOVFF  ABD,AD5
3084:  MOVFF  ABC,AD4
3088:  MOVFF  ABB,AD3
308C:  CALL   273A
3090:  MOVLW  0D
3092:  MOVLB  A
3094:  MOVWF  xDF
3096:  MOVLB  0
3098:  CALL   075A
309C:  MOVLW  0A
309E:  MOVLB  A
30A0:  MOVWF  xDF
30A2:  MOVLB  0
30A4:  CALL   075A
....................       fprintf(COM2,"col1 = %lu\r\n",col_1);       
30A8:  MOVLW  7A
30AA:  MOVWF  FF6
30AC:  MOVLW  04
30AE:  MOVWF  FF7
30B0:  MOVLW  07
30B2:  MOVLB  A
30B4:  MOVWF  xD3
30B6:  MOVLB  0
30B8:  CALL   1718
30BC:  MOVLW  41
30BE:  MOVWF  FE9
30C0:  MOVFF  AC2,AD6
30C4:  MOVFF  AC1,AD5
30C8:  MOVFF  AC0,AD4
30CC:  MOVFF  ABF,AD3
30D0:  CALL   273A
30D4:  MOVLW  0D
30D6:  MOVLB  A
30D8:  MOVWF  xDF
30DA:  MOVLB  0
30DC:  CALL   075A
30E0:  MOVLW  0A
30E2:  MOVLB  A
30E4:  MOVWF  xDF
30E6:  MOVLB  0
30E8:  CALL   075A
....................       fprintf(COM2,"col2 = %lu\r\n",col_2);      
30EC:  MOVLW  88
30EE:  MOVWF  FF6
30F0:  MOVLW  04
30F2:  MOVWF  FF7
30F4:  MOVLW  07
30F6:  MOVLB  A
30F8:  MOVWF  xD3
30FA:  MOVLB  0
30FC:  CALL   1718
3100:  MOVLW  41
3102:  MOVWF  FE9
3104:  MOVFF  AC6,AD6
3108:  MOVFF  AC5,AD5
310C:  MOVFF  AC4,AD4
3110:  MOVFF  AC3,AD3
3114:  CALL   273A
3118:  MOVLW  0D
311A:  MOVLB  A
311C:  MOVWF  xDF
311E:  MOVLB  0
3120:  CALL   075A
3124:  MOVLW  0A
3126:  MOVLB  A
3128:  MOVWF  xDF
312A:  MOVLB  0
312C:  CALL   075A
....................       fprintf(COM2,"col3 = %lu\r\n",col_3);      
3130:  MOVLW  96
3132:  MOVWF  FF6
3134:  MOVLW  04
3136:  MOVWF  FF7
3138:  MOVLW  07
313A:  MOVLB  A
313C:  MOVWF  xD3
313E:  MOVLB  0
3140:  CALL   1718
3144:  MOVLW  41
3146:  MOVWF  FE9
3148:  MOVFF  ACA,AD6
314C:  MOVFF  AC9,AD5
3150:  MOVFF  AC8,AD4
3154:  MOVFF  AC7,AD3
3158:  CALL   273A
315C:  MOVLW  0D
315E:  MOVLB  A
3160:  MOVWF  xDF
3162:  MOVLB  0
3164:  CALL   075A
3168:  MOVLW  0A
316A:  MOVLB  A
316C:  MOVWF  xDF
316E:  MOVLB  0
3170:  CALL   075A
....................       fprintf(COM2,"col4 = %lu\r\n",col_4); 
3174:  MOVLW  A4
3176:  MOVWF  FF6
3178:  MOVLW  04
317A:  MOVWF  FF7
317C:  MOVLW  07
317E:  MOVLB  A
3180:  MOVWF  xD3
3182:  MOVLB  0
3184:  CALL   1718
3188:  MOVLW  41
318A:  MOVWF  FE9
318C:  MOVFF  ACE,AD6
3190:  MOVFF  ACD,AD5
3194:  MOVFF  ACC,AD4
3198:  MOVFF  ACB,AD3
319C:  CALL   273A
31A0:  MOVLW  0D
31A2:  MOVLB  A
31A4:  MOVWF  xDF
31A6:  MOVLB  0
31A8:  CALL   075A
31AC:  MOVLW  0A
31AE:  MOVLB  A
31B0:  MOVWF  xDF
31B2:  MOVLB  0
31B4:  CALL   075A
....................       fprintf(COM2,"col5 = %lu\r\n",col_5); 
31B8:  MOVLW  B2
31BA:  MOVWF  FF6
31BC:  MOVLW  04
31BE:  MOVWF  FF7
31C0:  MOVLW  07
31C2:  MOVLB  A
31C4:  MOVWF  xD3
31C6:  MOVLB  0
31C8:  CALL   1718
31CC:  MOVLW  41
31CE:  MOVWF  FE9
31D0:  MOVFF  AD2,AD6
31D4:  MOVFF  AD1,AD5
31D8:  MOVFF  AD0,AD4
31DC:  MOVFF  ACF,AD3
31E0:  CALL   273A
31E4:  MOVLW  0D
31E6:  MOVLB  A
31E8:  MOVWF  xDF
31EA:  MOVLB  0
31EC:  CALL   075A
31F0:  MOVLW  0A
31F2:  MOVLB  A
31F4:  MOVWF  xDF
31F6:  MOVLB  0
31F8:  CALL   075A
....................       fprintf(COM2,"\r\n"); 
31FC:  MOVLW  0D
31FE:  MOVLB  A
3200:  MOVWF  xDF
3202:  MOVLB  0
3204:  CALL   075A
3208:  MOVLW  0A
320A:  MOVLB  A
320C:  MOVWF  xDF
320E:  MOVLB  0
3210:  CALL   075A
3214:  MOVLB  1
....................    } 
....................    //*/ 
....................    if((col_0>5)&&(col_0<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 0; 
3216:  MOVLB  A
3218:  MOVF   xBE,F
321A:  BNZ   322A
321C:  MOVF   xBD,F
321E:  BNZ   322A
3220:  MOVF   xBC,F
3222:  BNZ   322A
3224:  MOVF   xBB,W
3226:  SUBLW  05
3228:  BC    329C
322A:  MOVF   xBE,F
322C:  BNZ   329C
322E:  MOVF   xBD,F
3230:  BNZ   329C
3232:  MOVF   xBC,F
3234:  BNZ   329C
3236:  MOVF   xBB,W
3238:  SUBLW  3B
323A:  BNC   329C
323C:  MOVF   xC2,F
323E:  BNZ   324E
3240:  MOVF   xC1,F
3242:  BNZ   324E
3244:  MOVF   xC0,F
3246:  BNZ   324E
3248:  MOVF   xBF,W
324A:  SUBLW  64
324C:  BC    329C
324E:  MOVF   xC6,F
3250:  BNZ   3260
3252:  MOVF   xC5,F
3254:  BNZ   3260
3256:  MOVF   xC4,F
3258:  BNZ   3260
325A:  MOVF   xC3,W
325C:  SUBLW  64
325E:  BC    329C
3260:  MOVF   xCA,F
3262:  BNZ   3272
3264:  MOVF   xC9,F
3266:  BNZ   3272
3268:  MOVF   xC8,F
326A:  BNZ   3272
326C:  MOVF   xC7,W
326E:  SUBLW  64
3270:  BC    329C
3272:  MOVF   xCE,F
3274:  BNZ   3284
3276:  MOVF   xCD,F
3278:  BNZ   3284
327A:  MOVF   xCC,F
327C:  BNZ   3284
327E:  MOVF   xCB,W
3280:  SUBLW  64
3282:  BC    329C
3284:  MOVF   xD2,F
3286:  BNZ   3296
3288:  MOVF   xD1,F
328A:  BNZ   3296
328C:  MOVF   xD0,F
328E:  BNZ   3296
3290:  MOVF   xCF,W
3292:  SUBLW  64
3294:  BC    329C
3296:  MOVLW  00
3298:  MOVWF  01
329A:  BRA    3614
....................    if((col_1>5)&&(col_1<60)&&(col_0>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 1;  
329C:  MOVF   xC2,F
329E:  BNZ   32AE
32A0:  MOVF   xC1,F
32A2:  BNZ   32AE
32A4:  MOVF   xC0,F
32A6:  BNZ   32AE
32A8:  MOVF   xBF,W
32AA:  SUBLW  05
32AC:  BC    3320
32AE:  MOVF   xC2,F
32B0:  BNZ   3320
32B2:  MOVF   xC1,F
32B4:  BNZ   3320
32B6:  MOVF   xC0,F
32B8:  BNZ   3320
32BA:  MOVF   xBF,W
32BC:  SUBLW  3B
32BE:  BNC   3320
32C0:  MOVF   xBE,F
32C2:  BNZ   32D2
32C4:  MOVF   xBD,F
32C6:  BNZ   32D2
32C8:  MOVF   xBC,F
32CA:  BNZ   32D2
32CC:  MOVF   xBB,W
32CE:  SUBLW  64
32D0:  BC    3320
32D2:  MOVF   xC6,F
32D4:  BNZ   32E4
32D6:  MOVF   xC5,F
32D8:  BNZ   32E4
32DA:  MOVF   xC4,F
32DC:  BNZ   32E4
32DE:  MOVF   xC3,W
32E0:  SUBLW  64
32E2:  BC    3320
32E4:  MOVF   xCA,F
32E6:  BNZ   32F6
32E8:  MOVF   xC9,F
32EA:  BNZ   32F6
32EC:  MOVF   xC8,F
32EE:  BNZ   32F6
32F0:  MOVF   xC7,W
32F2:  SUBLW  64
32F4:  BC    3320
32F6:  MOVF   xCE,F
32F8:  BNZ   3308
32FA:  MOVF   xCD,F
32FC:  BNZ   3308
32FE:  MOVF   xCC,F
3300:  BNZ   3308
3302:  MOVF   xCB,W
3304:  SUBLW  64
3306:  BC    3320
3308:  MOVF   xD2,F
330A:  BNZ   331A
330C:  MOVF   xD1,F
330E:  BNZ   331A
3310:  MOVF   xD0,F
3312:  BNZ   331A
3314:  MOVF   xCF,W
3316:  SUBLW  64
3318:  BC    3320
331A:  MOVLW  01
331C:  MOVWF  01
331E:  BRA    3614
....................    if((col_2>5)&&(col_2<60)&&(col_1>100)&&(col_0>100)&&(col_3>100)&&(col_4>100)&&(col_5>100)) return 2;  
3320:  MOVF   xC6,F
3322:  BNZ   3332
3324:  MOVF   xC5,F
3326:  BNZ   3332
3328:  MOVF   xC4,F
332A:  BNZ   3332
332C:  MOVF   xC3,W
332E:  SUBLW  05
3330:  BC    33A4
3332:  MOVF   xC6,F
3334:  BNZ   33A4
3336:  MOVF   xC5,F
3338:  BNZ   33A4
333A:  MOVF   xC4,F
333C:  BNZ   33A4
333E:  MOVF   xC3,W
3340:  SUBLW  3B
3342:  BNC   33A4
3344:  MOVF   xC2,F
3346:  BNZ   3356
3348:  MOVF   xC1,F
334A:  BNZ   3356
334C:  MOVF   xC0,F
334E:  BNZ   3356
3350:  MOVF   xBF,W
3352:  SUBLW  64
3354:  BC    33A4
3356:  MOVF   xBE,F
3358:  BNZ   3368
335A:  MOVF   xBD,F
335C:  BNZ   3368
335E:  MOVF   xBC,F
3360:  BNZ   3368
3362:  MOVF   xBB,W
3364:  SUBLW  64
3366:  BC    33A4
3368:  MOVF   xCA,F
336A:  BNZ   337A
336C:  MOVF   xC9,F
336E:  BNZ   337A
3370:  MOVF   xC8,F
3372:  BNZ   337A
3374:  MOVF   xC7,W
3376:  SUBLW  64
3378:  BC    33A4
337A:  MOVF   xCE,F
337C:  BNZ   338C
337E:  MOVF   xCD,F
3380:  BNZ   338C
3382:  MOVF   xCC,F
3384:  BNZ   338C
3386:  MOVF   xCB,W
3388:  SUBLW  64
338A:  BC    33A4
338C:  MOVF   xD2,F
338E:  BNZ   339E
3390:  MOVF   xD1,F
3392:  BNZ   339E
3394:  MOVF   xD0,F
3396:  BNZ   339E
3398:  MOVF   xCF,W
339A:  SUBLW  64
339C:  BC    33A4
339E:  MOVLW  02
33A0:  MOVWF  01
33A2:  BRA    3614
....................    if((col_3>5)&&(col_3<60)&&(col_1>100)&&(col_2>100)&&(col_0>100)&&(col_4>100)&&(col_5>100)) return 3; 
33A4:  MOVF   xCA,F
33A6:  BNZ   33B6
33A8:  MOVF   xC9,F
33AA:  BNZ   33B6
33AC:  MOVF   xC8,F
33AE:  BNZ   33B6
33B0:  MOVF   xC7,W
33B2:  SUBLW  05
33B4:  BC    3428
33B6:  MOVF   xCA,F
33B8:  BNZ   3428
33BA:  MOVF   xC9,F
33BC:  BNZ   3428
33BE:  MOVF   xC8,F
33C0:  BNZ   3428
33C2:  MOVF   xC7,W
33C4:  SUBLW  3B
33C6:  BNC   3428
33C8:  MOVF   xC2,F
33CA:  BNZ   33DA
33CC:  MOVF   xC1,F
33CE:  BNZ   33DA
33D0:  MOVF   xC0,F
33D2:  BNZ   33DA
33D4:  MOVF   xBF,W
33D6:  SUBLW  64
33D8:  BC    3428
33DA:  MOVF   xC6,F
33DC:  BNZ   33EC
33DE:  MOVF   xC5,F
33E0:  BNZ   33EC
33E2:  MOVF   xC4,F
33E4:  BNZ   33EC
33E6:  MOVF   xC3,W
33E8:  SUBLW  64
33EA:  BC    3428
33EC:  MOVF   xBE,F
33EE:  BNZ   33FE
33F0:  MOVF   xBD,F
33F2:  BNZ   33FE
33F4:  MOVF   xBC,F
33F6:  BNZ   33FE
33F8:  MOVF   xBB,W
33FA:  SUBLW  64
33FC:  BC    3428
33FE:  MOVF   xCE,F
3400:  BNZ   3410
3402:  MOVF   xCD,F
3404:  BNZ   3410
3406:  MOVF   xCC,F
3408:  BNZ   3410
340A:  MOVF   xCB,W
340C:  SUBLW  64
340E:  BC    3428
3410:  MOVF   xD2,F
3412:  BNZ   3422
3414:  MOVF   xD1,F
3416:  BNZ   3422
3418:  MOVF   xD0,F
341A:  BNZ   3422
341C:  MOVF   xCF,W
341E:  SUBLW  64
3420:  BC    3428
3422:  MOVLW  03
3424:  MOVWF  01
3426:  BRA    3614
....................    if((col_4>5)&&(col_4<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_0>100)&&(col_5>100)) return 4;  
3428:  MOVF   xCE,F
342A:  BNZ   343A
342C:  MOVF   xCD,F
342E:  BNZ   343A
3430:  MOVF   xCC,F
3432:  BNZ   343A
3434:  MOVF   xCB,W
3436:  SUBLW  05
3438:  BC    34AC
343A:  MOVF   xCE,F
343C:  BNZ   34AC
343E:  MOVF   xCD,F
3440:  BNZ   34AC
3442:  MOVF   xCC,F
3444:  BNZ   34AC
3446:  MOVF   xCB,W
3448:  SUBLW  3B
344A:  BNC   34AC
344C:  MOVF   xC2,F
344E:  BNZ   345E
3450:  MOVF   xC1,F
3452:  BNZ   345E
3454:  MOVF   xC0,F
3456:  BNZ   345E
3458:  MOVF   xBF,W
345A:  SUBLW  64
345C:  BC    34AC
345E:  MOVF   xC6,F
3460:  BNZ   3470
3462:  MOVF   xC5,F
3464:  BNZ   3470
3466:  MOVF   xC4,F
3468:  BNZ   3470
346A:  MOVF   xC3,W
346C:  SUBLW  64
346E:  BC    34AC
3470:  MOVF   xCA,F
3472:  BNZ   3482
3474:  MOVF   xC9,F
3476:  BNZ   3482
3478:  MOVF   xC8,F
347A:  BNZ   3482
347C:  MOVF   xC7,W
347E:  SUBLW  64
3480:  BC    34AC
3482:  MOVF   xBE,F
3484:  BNZ   3494
3486:  MOVF   xBD,F
3488:  BNZ   3494
348A:  MOVF   xBC,F
348C:  BNZ   3494
348E:  MOVF   xBB,W
3490:  SUBLW  64
3492:  BC    34AC
3494:  MOVF   xD2,F
3496:  BNZ   34A6
3498:  MOVF   xD1,F
349A:  BNZ   34A6
349C:  MOVF   xD0,F
349E:  BNZ   34A6
34A0:  MOVF   xCF,W
34A2:  SUBLW  64
34A4:  BC    34AC
34A6:  MOVLW  04
34A8:  MOVWF  01
34AA:  BRA    3614
....................    if((col_5>5)&&(col_5<60)&&(col_1>100)&&(col_2>100)&&(col_3>100)&&(col_4>100)&&(col_0>100)) return 5;  
34AC:  MOVF   xD2,F
34AE:  BNZ   34BE
34B0:  MOVF   xD1,F
34B2:  BNZ   34BE
34B4:  MOVF   xD0,F
34B6:  BNZ   34BE
34B8:  MOVF   xCF,W
34BA:  SUBLW  05
34BC:  BC    3530
34BE:  MOVF   xD2,F
34C0:  BNZ   3530
34C2:  MOVF   xD1,F
34C4:  BNZ   3530
34C6:  MOVF   xD0,F
34C8:  BNZ   3530
34CA:  MOVF   xCF,W
34CC:  SUBLW  3B
34CE:  BNC   3530
34D0:  MOVF   xC2,F
34D2:  BNZ   34E2
34D4:  MOVF   xC1,F
34D6:  BNZ   34E2
34D8:  MOVF   xC0,F
34DA:  BNZ   34E2
34DC:  MOVF   xBF,W
34DE:  SUBLW  64
34E0:  BC    3530
34E2:  MOVF   xC6,F
34E4:  BNZ   34F4
34E6:  MOVF   xC5,F
34E8:  BNZ   34F4
34EA:  MOVF   xC4,F
34EC:  BNZ   34F4
34EE:  MOVF   xC3,W
34F0:  SUBLW  64
34F2:  BC    3530
34F4:  MOVF   xCA,F
34F6:  BNZ   3506
34F8:  MOVF   xC9,F
34FA:  BNZ   3506
34FC:  MOVF   xC8,F
34FE:  BNZ   3506
3500:  MOVF   xC7,W
3502:  SUBLW  64
3504:  BC    3530
3506:  MOVF   xCE,F
3508:  BNZ   3518
350A:  MOVF   xCD,F
350C:  BNZ   3518
350E:  MOVF   xCC,F
3510:  BNZ   3518
3512:  MOVF   xCB,W
3514:  SUBLW  64
3516:  BC    3530
3518:  MOVF   xBE,F
351A:  BNZ   352A
351C:  MOVF   xBD,F
351E:  BNZ   352A
3520:  MOVF   xBC,F
3522:  BNZ   352A
3524:  MOVF   xBB,W
3526:  SUBLW  64
3528:  BC    3530
352A:  MOVLW  05
352C:  MOVWF  01
352E:  BRA    3614
....................     
....................    if((col_5>200)&&(col_0<180)&&(col_0>100)&&(col_1<180)&&(col_1>100)&&(col_2<180)&&(col_2>100)&&(col_3<180)&&(col_3>100)&&(col_4<180)&&(col_4>100)) return 5; 
3530:  MOVF   xD2,F
3532:  BNZ   3544
3534:  MOVF   xD1,F
3536:  BNZ   3544
3538:  MOVF   xD0,F
353A:  BNZ   3544
353C:  MOVF   xCF,W
353E:  SUBLW  C8
3540:  BTFSC  FD8.0
3542:  BRA    3610
3544:  MOVF   xBE,F
3546:  BTFSS  FD8.2
3548:  BRA    3610
354A:  MOVF   xBD,F
354C:  BTFSS  FD8.2
354E:  BRA    3610
3550:  MOVF   xBC,F
3552:  BTFSS  FD8.2
3554:  BRA    3610
3556:  MOVF   xBB,W
3558:  SUBLW  B3
355A:  BTFSS  FD8.0
355C:  BRA    3610
355E:  MOVF   xBE,F
3560:  BNZ   3572
3562:  MOVF   xBD,F
3564:  BNZ   3572
3566:  MOVF   xBC,F
3568:  BNZ   3572
356A:  MOVF   xBB,W
356C:  SUBLW  64
356E:  BTFSC  FD8.0
3570:  BRA    3610
3572:  MOVF   xC2,F
3574:  BTFSS  FD8.2
3576:  BRA    3610
3578:  MOVF   xC1,F
357A:  BTFSS  FD8.2
357C:  BRA    3610
357E:  MOVF   xC0,F
3580:  BTFSS  FD8.2
3582:  BRA    3610
3584:  MOVF   xBF,W
3586:  SUBLW  B3
3588:  BNC   3610
358A:  MOVF   xC2,F
358C:  BNZ   359C
358E:  MOVF   xC1,F
3590:  BNZ   359C
3592:  MOVF   xC0,F
3594:  BNZ   359C
3596:  MOVF   xBF,W
3598:  SUBLW  64
359A:  BC    3610
359C:  MOVF   xC6,F
359E:  BNZ   3610
35A0:  MOVF   xC5,F
35A2:  BNZ   3610
35A4:  MOVF   xC4,F
35A6:  BNZ   3610
35A8:  MOVF   xC3,W
35AA:  SUBLW  B3
35AC:  BNC   3610
35AE:  MOVF   xC6,F
35B0:  BNZ   35C0
35B2:  MOVF   xC5,F
35B4:  BNZ   35C0
35B6:  MOVF   xC4,F
35B8:  BNZ   35C0
35BA:  MOVF   xC3,W
35BC:  SUBLW  64
35BE:  BC    3610
35C0:  MOVF   xCA,F
35C2:  BNZ   3610
35C4:  MOVF   xC9,F
35C6:  BNZ   3610
35C8:  MOVF   xC8,F
35CA:  BNZ   3610
35CC:  MOVF   xC7,W
35CE:  SUBLW  B3
35D0:  BNC   3610
35D2:  MOVF   xCA,F
35D4:  BNZ   35E4
35D6:  MOVF   xC9,F
35D8:  BNZ   35E4
35DA:  MOVF   xC8,F
35DC:  BNZ   35E4
35DE:  MOVF   xC7,W
35E0:  SUBLW  64
35E2:  BC    3610
35E4:  MOVF   xCE,F
35E6:  BNZ   3610
35E8:  MOVF   xCD,F
35EA:  BNZ   3610
35EC:  MOVF   xCC,F
35EE:  BNZ   3610
35F0:  MOVF   xCB,W
35F2:  SUBLW  B3
35F4:  BNC   3610
35F6:  MOVF   xCE,F
35F8:  BNZ   3608
35FA:  MOVF   xCD,F
35FC:  BNZ   3608
35FE:  MOVF   xCC,F
3600:  BNZ   3608
3602:  MOVF   xCB,W
3604:  SUBLW  64
3606:  BC    3610
3608:  MOVLW  05
360A:  MOVWF  01
360C:  BRA    3614
360E:  BRA    3614
....................    else return 0xff; 
3610:  MOVLW  FF
3612:  MOVWF  01
3614:  MOVLB  0
3616:  GOTO   367C (RETURN)
.................... } 
....................  
.................... //========================== 
.................... int8 KB_count=0; 
....................  
.................... int8 kbd_getc_slv(){ 
361A:  MOVLW  20
361C:  MOVLB  A
361E:  MOVWF  xB7
....................    static BYTE kbd_call_count; 
....................    static int1 kbd_down; 
....................    static char last_key; 
....................    BYTE col; 
....................    BYTE kchar=' '; 
....................    BYTE row; 
....................     if((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)) 
3620:  BSF    F93.4
3622:  BTFSS  F81.4
3624:  BRA    3638
3626:  BSF    F93.5
3628:  BTFSS  F81.5
362A:  BRA    3638
362C:  BSF    F93.6
362E:  BTFSS  F81.6
3630:  BRA    3638
3632:  BSF    F93.7
3634:  BTFSC  F81.7
3636:  BRA    37A4
....................     { 
....................        if(input(ROW0)==0) 
3638:  BSF    F93.4
363A:  BTFSC  F81.4
363C:  BRA    3642
....................          row=0; 
363E:  CLRF   xB8
3640:  BRA    3664
....................        else if(input(ROW1)==0) 
3642:  BSF    F93.5
3644:  BTFSC  F81.5
3646:  BRA    364E
....................          row=1; 
3648:  MOVLW  01
364A:  MOVWF  xB8
364C:  BRA    3664
....................        else if(input(ROW2)==0) 
364E:  BSF    F93.6
3650:  BTFSC  F81.6
3652:  BRA    365A
....................          row=2; 
3654:  MOVLW  02
3656:  MOVWF  xB8
3658:  BRA    3664
....................        else if(input(ROW3)==0) 
365A:  BSF    F93.7
365C:  BTFSC  F81.7
365E:  BRA    3664
....................          row=3;      
3660:  MOVLW  03
3662:  MOVWF  xB8
....................        if(type_KB==0)col=check_col(); 
3664:  MOVLB  1
3666:  MOVF   x13,F
3668:  BNZ   3676
366A:  MOVLB  0
366C:  GOTO   27FA
3670:  MOVFF  01,AB6
3674:  BRA    3680
....................          else col=new_check_col(); 
3676:  MOVLB  0
3678:  GOTO   2E28
367C:  MOVFF  01,AB6
....................        //fprintf(COM2,"\r\nrow = %d\r\n",row); 
....................        //fprintf(COM2,"col = %d\r\n",col); 
....................        if(col!=0xff) 
3680:  MOVLB  A
3682:  INCFSZ xB6,W
3684:  BRA    3688
3686:  BRA    3774
....................        { 
....................          if(type_KB==0)kchar = KEYS[row][col]; 
3688:  MOVLB  1
368A:  MOVF   x13,F
368C:  BNZ   36B6
368E:  MOVLB  A
3690:  MOVF   xB8,W
3692:  MULLW  05
3694:  MOVF   FF3,W
3696:  CLRF   xBA
3698:  MOVWF  xB9
369A:  CLRF   03
369C:  MOVF   xB6,W
369E:  ADDWF  xB9,W
36A0:  MOVWF  01
36A2:  MOVF   xBA,W
36A4:  ADDWFC 03,F
36A6:  MOVF   01,W
36A8:  MOVLB  0
36AA:  CALL   00E8
36AE:  MOVWF  01
36B0:  MOVFF  FE8,AB7
36B4:  BRA    36DA
....................            else kchar =newKEYS[row][col]; 
36B6:  MOVLB  A
36B8:  MOVF   xB8,W
36BA:  MULLW  06
36BC:  MOVF   FF3,W
36BE:  CLRF   xBA
36C0:  MOVWF  xB9
36C2:  CLRF   03
36C4:  MOVF   xB6,W
36C6:  ADDWF  xB9,W
36C8:  MOVWF  01
36CA:  MOVF   xBA,W
36CC:  ADDWFC 03,F
36CE:  MOVF   01,W
36D0:  MOVLB  0
36D2:  CALL   010C
36D6:  MOVFF  FE8,AB7
....................          //fprintf(COM2,"kchar %c\r\n",kchar); 
....................          if(keydebug_en==0) 
36DA:  MOVLB  1
36DC:  MOVF   x0B,F
36DE:  BNZ   3766
....................             { 
....................               charac_timeout=0; 
36E0:  MOVLB  0
36E2:  CLRF   xFC
36E4:  CLRF   xFB
....................                if(key_count_ms<key_numbyte)key_data[key_count_ms++]=kchar; 
36E6:  MOVLB  1
36E8:  MOVF   x0E,W
36EA:  SUBLW  31
36EC:  BNC   3702
36EE:  MOVF   x0E,W
36F0:  INCF   x0E,F
36F2:  CLRF   03
36F4:  ADDLW  14
36F6:  MOVWF  FE9
36F8:  MOVLW  01
36FA:  ADDWFC 03,W
36FC:  MOVWF  FEA
36FE:  MOVFF  AB7,FEF
....................                fprintf(COM2,"key data[%d] %c\r\n",key_count_ms,kchar); 
3702:  MOVLW  C0
3704:  MOVWF  FF6
3706:  MOVLW  04
3708:  MOVWF  FF7
370A:  MOVLW  09
370C:  MOVLB  A
370E:  MOVWF  xD3
3710:  MOVLB  0
3712:  CALL   1718
3716:  MOVFF  10E,ABF
371A:  MOVLW  18
371C:  MOVLB  A
371E:  MOVWF  xC0
3720:  MOVLB  0
3722:  CALL   1836
3726:  MOVLW  5D
3728:  MOVLB  A
372A:  MOVWF  xDF
372C:  MOVLB  0
372E:  CALL   075A
3732:  MOVLW  20
3734:  MOVLB  A
3736:  MOVWF  xDF
3738:  MOVLB  0
373A:  CALL   075A
373E:  MOVFF  AB7,ADF
3742:  CALL   075A
3746:  MOVLW  0D
3748:  MOVLB  A
374A:  MOVWF  xDF
374C:  MOVLB  0
374E:  CALL   075A
3752:  MOVLW  0A
3754:  MOVLB  A
3756:  MOVWF  xDF
3758:  MOVLB  0
375A:  CALL   075A
....................                count_checking=0; 
375E:  MOVLB  1
3760:  CLRF   x07
3762:  CLRF   x06
....................             } 
3764:  BRA    3772
....................                else fputc(kchar,COM2); 
3766:  MOVFF  AB7,ADF
376A:  MOVLB  0
376C:  CALL   075A
3770:  MOVLB  1
3772:  MOVLB  A
....................        } 
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
3774:  BSF    F93.4
3776:  BTFSS  F81.4
3778:  BRA    3774
377A:  BSF    F93.5
377C:  BTFSS  F81.5
377E:  BRA    3774
3780:  BSF    F93.6
3782:  BTFSS  F81.6
3784:  BRA    3774
3786:  BSF    F93.7
3788:  BTFSS  F81.7
378A:  BRA    3774
....................        while((input(ROW0)==0)||(input(ROW1)==0)||(input(ROW2)==0)||(input(ROW3)==0)); 
378C:  BSF    F93.4
378E:  BTFSS  F81.4
3790:  BRA    378C
3792:  BSF    F93.5
3794:  BTFSS  F81.5
3796:  BRA    378C
3798:  BSF    F93.6
379A:  BTFSS  F81.6
379C:  BRA    378C
379E:  BSF    F93.7
37A0:  BTFSS  F81.7
37A2:  BRA    378C
....................     } 
....................   set_tris_a(0xff);     
37A4:  MOVLW  FF
37A6:  MOVWF  F92
....................   return(kchar); 
37A8:  MOVFF  AB7,01
37AC:  MOVLB  0
37AE:  RETURN 0
.................... }//*/ 
.................... //============================================ 
....................  
.................... //=========================== 
.................... void save_key_new() 
.................... { 
....................    int i; 
....................    int16 temp; 
....................    if(ptr_card_key<EEPROM_SIZE_key) 
*
4490:  MOVF   27,F
4492:  BTFSS  FD8.2
4494:  BRA    45E0
4496:  MOVF   26,F
4498:  BTFSS  FD8.2
449A:  BRA    45E0
449C:  MOVF   25,W
449E:  SUBLW  FF
44A0:  BTFSS  FD8.0
44A2:  BRA    45E0
44A4:  BNZ   44AE
44A6:  MOVF   24,W
44A8:  SUBLW  FE
44AA:  BTFSS  FD8.0
44AC:  BRA    45E0
....................    { 
....................       //rtc_get_date(date,mon,year,day); 
....................       //rtc_get_time(h,min,sec); 
....................       //countcard=get_countcard(); 
....................       //countcard=countcard+1; 
....................       //save_coutcard(countcard); 
....................       if((key_data[0]!=0)||(key_count_ms>0)) 
44AE:  MOVLB  1
44B0:  MOVF   x14,F
44B2:  BNZ   44B8
44B4:  MOVF   x0E,F
44B6:  BZ    458E
....................       { 
....................          temp=get_countcard(); 
44B8:  MOVLB  0
44BA:  CALL   3A02
44BE:  MOVFF  02,AB8
44C2:  MOVFF  01,AB7
....................          ptr_card_key=(int32)(((temp)*key_numbyte)+EEPROM_KEY_ST); 
44C6:  MOVFF  AB8,ABC
44CA:  MOVFF  AB7,ABB
44CE:  MOVLB  A
44D0:  CLRF   xBE
44D2:  MOVLW  32
44D4:  MOVWF  xBD
44D6:  MOVLB  0
44D8:  CALL   3A52
44DC:  MOVFF  02,ABA
44E0:  MOVFF  01,AB9
44E4:  MOVLW  46
44E6:  MOVLB  A
44E8:  ADDWF  xB9,F
44EA:  MOVLW  AA
44EC:  ADDWFC xBA,F
44EE:  MOVLW  01
44F0:  ADDWF  xB9,W
44F2:  MOVWF  01
44F4:  MOVLW  00
44F6:  ADDWFC xBA,W
44F8:  MOVFF  01,24
44FC:  MOVWF  25
44FE:  CLRF   26
4500:  CLRF   27
....................          for(i=0;i<key_numbyte-5;i++) 
4502:  CLRF   xB6
4504:  MOVF   xB6,W
4506:  SUBLW  2C
4508:  BNC   4564
....................          { 
....................             temp=key_data[i]; 
450A:  CLRF   03
450C:  MOVF   xB6,W
450E:  ADDLW  14
4510:  MOVWF  FE9
4512:  MOVLW  01
4514:  ADDWFC 03,W
4516:  MOVWF  FEA
4518:  CLRF   xB8
451A:  MOVFF  FEF,AB7
....................             write_ext_eeprom((long int)ptr_card_key++,temp); 
451E:  MOVFF  27,03
4522:  MOVFF  26,02
4526:  MOVFF  25,01
452A:  MOVFF  24,00
452E:  MOVLW  01
4530:  ADDWF  24,F
4532:  BTFSC  FD8.0
4534:  INCF   25,F
4536:  BTFSC  FD8.2
4538:  INCF   26,F
453A:  BTFSC  FD8.2
453C:  INCF   27,F
453E:  MOVFF  01,ABA
4542:  MOVFF  00,AB9
4546:  MOVFF  01,AC8
454A:  MOVFF  00,AC7
454E:  MOVFF  AB7,AC9
4552:  MOVLB  0
4554:  RCALL  3E74
....................             //delay_us(100); 
....................             fputc(temp,COM2); 
4556:  MOVFF  AB7,ADF
455A:  CALL   075A
455E:  MOVLB  A
4560:  INCF   xB6,F
4562:  BRA    4504
....................          } 
....................          write_ext_eeprom((long int)ptr_card_key,0); 
4564:  MOVFF  25,AC8
4568:  MOVFF  24,AC7
456C:  CLRF   xC9
456E:  MOVLB  0
4570:  RCALL  3E74
....................          save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
4572:  MOVFF  27,ABC
4576:  MOVFF  26,ABB
457A:  MOVFF  25,ABA
457E:  MOVFF  24,AB9
4582:  MOVLW  1E
4584:  MOVLB  A
4586:  MOVWF  xBD
4588:  MOVLB  0
458A:  RCALL  3F7A
458C:  MOVLB  1
....................          //fprintf(COM2," save_ptrcard_key=%lu\n\r",get_ptrcard(strobe_ptrcard_key)); 
....................       } 
....................       //key_count=0; 
....................       key_count_ms=0; 
458E:  CLRF   x0E
....................       del_buf(key_numbyte,key_data); 
4590:  MOVLW  32
4592:  MOVLB  A
4594:  MOVWF  xC5
4596:  MOVLW  01
4598:  MOVWF  xC7
459A:  MOVLW  14
459C:  MOVWF  xC6
459E:  MOVLB  0
45A0:  CALL   3A74
....................       fprintf(COM2,"\r\n"); 
45A4:  MOVLW  0D
45A6:  MOVLB  A
45A8:  MOVWF  xDF
45AA:  MOVLB  0
45AC:  CALL   075A
45B0:  MOVLW  0A
45B2:  MOVLB  A
45B4:  MOVWF  xDF
45B6:  MOVLB  0
45B8:  CALL   075A
....................       fprintf(COM2,"Done PIN"); 
45BC:  MOVLW  D2
45BE:  MOVWF  FF6
45C0:  MOVLW  04
45C2:  MOVWF  FF7
45C4:  CALL   07A0
....................       fprintf(COM2,"\r\n"); 
45C8:  MOVLW  0D
45CA:  MOVLB  A
45CC:  MOVWF  xDF
45CE:  MOVLB  0
45D0:  CALL   075A
45D4:  MOVLW  0A
45D6:  MOVLB  A
45D8:  MOVWF  xDF
45DA:  MOVLB  0
45DC:  CALL   075A
....................    } 
45E0:  GOTO   48A6 (RETURN)
.................... } 
.................... //=========================================== 
.................... void key_press() 
.................... { 
....................    int8 col; 
....................    int32 KB_count_timeout=0; 
....................    fprintf(COM2,"\r\n"); 
....................    fprintf(COM2,"Key"); 
....................    //fprintf(COM2,"\r\n"); 
....................    KB_count_timeout=0; 
....................    while(1) 
....................    { 
....................       
....................       if(KB_count_timeout<150000)KB_count_timeout++; 
....................       if(KB_count_timeout==150000) 
....................       { 
....................          KB_count_timeout++; 
....................           
....................          break;             
....................       }   
....................    } 
.................... } 
.................... //=========================================== 
....................  
.................... #include <uart_tool.c> 
....................  
.................... #define NO_ECHO         0 
.................... #define EN_ECHO         1 
.................... #define STAR_ECHO       2 
.................... #define FAUX            0 
.................... #define VRAI            1 
.................... //========================= 
.................... unsigned char buffer_uart[100]; 
.................... int8 UART_index=0; 
.................... int8 sms_unread_flag=0; 
.................... //========================= 
.................... //========================= 
.................... unsigned int USART_getstring(unsigned int8 echo, unsigned int8 nbcarmax,char* chaine) 
.................... { 
....................    int8 c,i; 
....................    unsigned int16 nbcar=0; 
....................    unsigned int8 fini=FAUX; 
....................        
....................    while(nbcar<nbcarmax&&!fini) 
....................    { 
....................       c = fgetc(COM2);//getc(); 
....................       switch(c) 
....................       { 
....................          case 0x7f:    
....................             if(nbcar>0)   
....................             { 
....................                fputc(0x7f,COM2);//fputc(cdata, stream) 
....................                nbcar--; 
....................                fgetc(COM2);//getc(); 
....................             } 
....................             else fputc(0x07,COM2);    
....................          break;  
....................          case 0x0D:   
....................                keydebug_en=0; 
....................                set_tris_a(0xff); 
....................                for(i=nbcar;i<nbcarmax;i++) 
....................                { 
....................                  chaine[i]=0; 
....................                } 
....................                if(nbcar==0)return(FAUX); 
....................                fini=VRAI; 
....................          break; 
....................          default: 
....................             if(c>=32 && c<=126 && nbcar<(nbcarmax-1))   
....................             { 
....................                chaine[nbcar]=c; 
....................                nbcar++; 
....................                if(echo==EN_ECHO) fputc(c,COM2); 
....................                   else if(echo==STAR_ECHO) fputc('*',COM2); 
....................             } 
....................         // else 
....................             //putc(0x07);  
....................       } 
....................        
....................    } 
....................    return(nbcar); 
.................... } 
.................... //=================================== 
.................... int8 stringcomp(int8 *a, int8 *b) 
*
57A2:  MOVFF  A8F,A93
57A6:  MOVFF  A8E,A92
57AA:  MOVFF  A91,A95
57AE:  MOVFF  A90,A94
.................... { 
....................    int8 *aa=a; 
....................    int8 *bb=b; 
....................  
....................    while(*aa !=0x00 && *bb !=0x00) 
57B2:  MOVFF  A93,03
57B6:  MOVLB  A
57B8:  MOVFF  A92,FE9
57BC:  MOVFF  A93,FEA
57C0:  MOVF   FEF,F
57C2:  BZ    580A
57C4:  MOVFF  A95,03
57C8:  MOVFF  A94,FE9
57CC:  MOVFF  A95,FEA
57D0:  MOVF   FEF,F
57D2:  BZ    580A
....................    { 
....................       if(*aa!=*bb) 
57D4:  MOVFF  A92,FE9
57D8:  MOVFF  A93,FEA
57DC:  MOVFF  FEF,A96
57E0:  MOVFF  A95,03
57E4:  MOVFF  A94,FE9
57E8:  MOVFF  A95,FEA
57EC:  MOVF   FEF,W
57EE:  SUBWF  x96,W
57F0:  BZ    57F8
....................          return(1); 
57F2:  MOVLW  01
57F4:  MOVWF  01
57F6:  BRA    5836
....................       aa++; 
57F8:  INCF   x92,F
57FA:  BTFSC  FD8.2
57FC:  INCF   x93,F
....................       bb++; 
57FE:  INCF   x94,F
5800:  BTFSC  FD8.2
5802:  INCF   x95,F
5804:  MOVLB  0
5806:  BRA    57B2
5808:  MOVLB  A
....................    } 
....................    if(*aa!=*bb)return(1); 
580A:  MOVFF  A93,03
580E:  MOVFF  A92,FE9
5812:  MOVFF  A93,FEA
5816:  MOVFF  FEF,A96
581A:  MOVFF  A95,03
581E:  MOVFF  A94,FE9
5822:  MOVFF  A95,FEA
5826:  MOVF   FEF,W
5828:  SUBWF  x96,W
582A:  BZ    5832
582C:  MOVLW  01
582E:  MOVWF  01
5830:  BRA    5836
....................    return(0); 
5832:  MOVLW  00
5834:  MOVWF  01
5836:  MOVLB  0
5838:  RETURN 0
.................... } 
.................... //==================================== 
.................... unsigned int16 strtoi(char *str) 
.................... { 
....................    unsigned int8 val = 0, digit; 
....................    char c; 
....................  
....................    while ((c = *str++) != 0x00)  
....................    { 
....................         if (c >= '0' && c <= '9') 
....................             digit = (unsigned int) (c - '0'); 
....................         else 
....................             break; 
....................  
....................         val = (val * 10) + digit; 
....................     } 
....................  
....................     return val; 
.................... } 
....................  
.................... int8 receiver_state=0,booting_done=0; 
.................... int16 over_byte=0; 
.................... #include <GSM.c>  
.................... #include "STRING.H" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... //#include "myRS485.C" 
....................  
.................... #define        EMERGOFF       PIN_A7 
.................... #define        config_sms           0 
.................... #define        reading_sms_cmd      1 
.................... #define        MSG_avai             2 
.................... #define        analyze_sms          3 
.................... #define        checking_MN          4 
.................... #define        doing_sms            5 
.................... #define        delete_MSG           6 
.................... #define        pre_cmd              7 
.................... #define        MSG_sending          8 
.................... #define        check_st             9 
.................... #define        config               10 
.................... #define        autosending          11 
.................... #define        idle                 12 
.................... #define        data_analyze         13 
.................... #define        SIM_reply            14 
.................... #define        check_comunication   15 
.................... #define        phone_activity_status 16 
.................... #define        check_inbox          17 
.................... #define        checking_MN0         18 
.................... #define        autosending1         19 
.................... #define        reset_module         20 
.................... #if defined(twonumber) 
....................    #define        second_number_en     21 
.................... #endif    
....................  
.................... //#define     IGT            PIN_A6 
....................  
.................... //#define     batmb    sendto485(0,0x11,1) 
.................... //#define     tatmb    sendto485(0,0x11,0) 
....................  
....................  
.................... unsigned int8 msg_data_sending[280]; 
.................... int8 sim_bug[50]; 
.................... unsigned int8 msg_buffer1[20]; 
.................... unsigned int8 msg_buffer2[50]; 
.................... unsigned int8 reply_buffer[280]; 
.................... unsigned int8 datetime[25]; 
.................... unsigned int8 mobilenumb[26]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; 
.................... //unsigned int8 buf_checkMBN[16]; 
.................... int16 count_polling=0; 
.................... int8 SIM_state=0,MSG_sending_st=0; 
.................... int16 timing_wait=100; 
.................... int8 auto_sending=0; 
.................... int8 send_oneMSG=0; 
.................... int8 SIM_reply_st=0; 
.................... int8 checking_sim=0; 
.................... int8 count_checking_nw=0; 
.................... int8 firstime_pw=0; 
.................... #if defined(twonumber) 
....................   int8 two_number_sending=0;  
....................    
.................... #endif 
.................... //unsigned int8 com_buffer1[20]="it is OK"; 
.................... //============================================== 
.................... void earse_buffer_uart(unsigned int8 numbuf) 
.................... { 
....................    unsigned int8 i; 
....................    for(i=0;i<numbuf;i++) 
....................    { 
....................        buffer_uart[i]=0; 
....................    } 
.................... } 
.................... //============================================== 
.................... void sim900_init() 
.................... { 
....................    fprintf(COM1,"AT\r\n"); 
....................    delay_ms(500); 
....................    fprintf(COM1,"AT+CMGF=1\r\n"); 
....................    delay_ms(500); 
....................    //del_buf(26,mobilenumb); 
....................    //strcpy(mobilenumb,"+84903219082"); 
.................... } 
.................... //============================================== 
.................... int8 get_datasim900(int8 *datin) 
.................... { 
....................    int8 c,i,index=0; 
....................    int8 testtemp[20]; 
....................    while(index<5) 
....................    { 
....................       c = getc(); 
....................       index++; 
....................       fprintf(COM2,"%c", c);  
....................    } 
....................    for(i=0;i<15;i++) 
....................    { 
....................       fprintf(COM2,"%c", testtemp[i]); 
....................    } 
....................    fprintf(COM2,"%u\r\n", index);//*/ 
....................    return 0; 
.................... } 
.................... //============================================== 
.................... int8 check_module() 
.................... { 
....................    int8 temp=0,i; 
....................    earse_buffer_uart(10); 
....................    fprintf(COM1,"AT\r\n"); 
....................    delay_ms(200); 
....................    fprintf(COM1,"AT\r\n"); 
....................    delay_ms(200); 
....................    fprintf(COM1,"AT\r\n"); 
....................    delay_ms(200); 
....................    fprintf(COM1,"AT\r\n"); 
....................    delay_ms(200); 
....................    fprintf(COM1,"AT\r\n"); 
....................    UART_index=0; 
....................    delay_ms(200); 
....................    //fputc('c',COM2); 
....................    //fprintf("MSG is OK\r\n"); 
....................    for(i=0;i<10;i++) 
....................    { 
....................       //fputc(buffer_uart[i],COM2); 
....................       if((buffer_uart[i]=='O')&&(buffer_uart[i+1]=='K')) 
....................       { 
....................          i=10; 
....................          temp=1; 
....................          return(temp); 
....................       } 
....................          else temp=0; 
....................    } 
....................    UART_index=0; 
....................    return(temp); 
.................... } 
.................... //============================================== 
.................... void power_on() 
.................... { 
....................    /*while(temp==0) 
....................    { 
....................       temp = check_module(); 
....................       if(temp==0) 
....................       { 
....................          output_high(EMERGOFF); 
....................          delay_ms(3000); 
....................          output_low(EMERGOFF); 
....................          delay_ms(3000); 
....................       } 
....................          else break; 
....................    }*/ 
....................          output_high(EMERGOFF); 
....................          delay_ms(3000); 
....................          output_low(EMERGOFF); 
....................          delay_ms(3000); 
.................... } 
.................... //============================================== 
.................... void power_off() 
.................... { 
....................    fprintf(COM1,"AT+CPOWD\r\n"); 
.................... } 
.................... //============================================== 
.................... unsigned int8 mymemcmp(void * s1,char *s2,size_t n) 
.................... { 
....................    char *su1, *su2; 
....................    unsigned int8 temp=0,i=0; 
....................    for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
....................    { 
....................       if(*su1!=*su2) 
....................       { 
....................          temp=1; 
....................          if(*su1>*su2) 
....................          { 
....................             if((i==0)&&(*su1==(*su2)+32)) temp = 0; 
....................                //else temp = 0; 
....................          } 
....................             else  
....................                { 
....................                   if((i==0)&&(*su2==(*su1)+32)) temp = 0; 
....................                     // else temp = 0; 
....................                } 
....................       } 
....................       i++; 
....................    } 
....................    return (temp); 
.................... } 
.................... //============================================== 
.................... int8 pre_msg(int8 *datin,int8 *datout,int16 index) 
*
5F36:  MOVLB  A
5F38:  CLRF   x95
.................... { 
....................    int8 i,len=0; 
....................    len = strlen(datin); 
5F3A:  MOVFF  A8F,A97
5F3E:  MOVFF  A8E,A96
5F42:  MOVLB  0
5F44:  RCALL  5EFC
5F46:  MOVFF  01,A95
....................    for(i=0;i<len;i++)datout[index++]=datin[i]; 
5F4A:  MOVLB  A
5F4C:  CLRF   x94
5F4E:  MOVF   x95,W
5F50:  SUBWF  x94,W
5F52:  BC    5F98
5F54:  MOVFF  A93,03
5F58:  MOVF   x92,W
5F5A:  INCF   x92,F
5F5C:  BTFSC  FD8.2
5F5E:  INCF   x93,F
5F60:  MOVWF  x96
5F62:  MOVFF  03,A97
5F66:  MOVF   x90,W
5F68:  ADDWF  x96,W
5F6A:  MOVWF  01
5F6C:  MOVF   x91,W
5F6E:  ADDWFC 03,W
5F70:  MOVWF  03
5F72:  MOVFF  01,A98
5F76:  MOVWF  x99
5F78:  MOVF   x94,W
5F7A:  ADDWF  x8E,W
5F7C:  MOVWF  FE9
5F7E:  MOVLW  00
5F80:  ADDWFC x8F,W
5F82:  MOVWF  FEA
5F84:  MOVFF  FEF,A9A
5F88:  MOVFF  03,FEA
5F8C:  MOVFF  01,FE9
5F90:  MOVFF  A9A,FEF
5F94:  INCF   x94,F
5F96:  BRA    5F4E
....................    return index; 
5F98:  MOVF   x92,W
5F9A:  MOVWF  01
5F9C:  MOVLB  0
5F9E:  RETURN 0
.................... } 
.................... //============================================== 
.................... void delete_sms(char number_sms) 
.................... { 
....................    switch(number_sms) 
....................    { 
....................        case  1: 
....................             fprintf(COM1,"AT+CMGD=1\r\n");  
....................        break; 
....................        case  2: 
....................             fprintf(COM1,"AT+CMGD=2\r\n"); 
....................        break; 
....................        case  3: 
....................             fprintf(COM1,"AT+CMGD=3\r\n"); 
....................        break; 
....................        case  4: 
....................             fprintf(COM1,"AT+CMGD=4\r\n");        
....................        break; 
....................        case  5: 
....................             fprintf(COM1,"AT+CMGD=5\r\n"); 
....................        break; 
....................        case  6: 
....................             fprintf(COM1,"AT+CMGD=6\r\n"); 
....................        break; 
....................        case  7: 
....................              fprintf(COM1,"AT+CMGD=7\r\n"); 
....................        break;        
....................        case  8: 
....................             fprintf(COM1,"AT+CMGD=8\r\n"); 
....................        break;        
....................    } 
....................    delay_ms(500); 
.................... } 
.................... //============================================== 
.................... void del_multi_sms(int8 num_sms) 
.................... { 
....................    int8 i; 
....................    for(i=1;i<=num_sms;i++) 
....................    { 
....................      delete_sms(i);  
....................      delay_ms(100); 
....................    } 
.................... } 
.................... //============================================== 
.................... //============================================== 
.................... void send_sms(unsigned int8* mobile_num,unsigned int8* MSG) 
.................... { 
....................       unsigned int8 i=0,strl=0; 
....................       strl= strlen(MSG);   
....................       fprintf(COM1,"AT+CMGS="); 
....................       delay_ms(500); 
....................       fputc('"',COM1); 
....................       while((mobile_num[i]!=0)&&(i<20)) 
....................       { 
....................          //fputc(mobile_num[i],COM2); 
....................          //putc(mobile_num[i]); 
....................          fputc(mobile_num[i],COM1); 
....................          i++; 
....................       } 
....................       fputc('"',COM1); 
....................       fprintf(COM1,"\r\n"); 
....................       delay_ms(500);         
....................       for(i=0;i<strl;i++) 
....................       { 
....................          fputc(MSG[i],COM1); 
....................       } 
....................       delay_ms(500); 
....................       fputc(26,COM1); 
.................... } 
.................... //============================================= 
.................... //============================================== 
.................... void reading_sms() 
.................... { 
....................    unsigned int8 i; 
....................    for(i=0;i<16;i++) mobilenumb[i]=0; 
....................    earse_buffer_uart(200); 
....................    printf("AT+CMGF=1\r\n"); 
....................    printf("AT+CMGR=1\r\n");  
....................    UART_index=0;  
....................    delay_ms(1000); 
....................    for(i=0;i<200;i++) 
....................    { 
....................       if((buffer_uart[i]=='a')&&(buffer_uart[i+1]=='d')&&(buffer_uart[i+2]=='m')&&(buffer_uart[i+3]=='i')&&(buffer_uart[i+4]=='n')&&(buffer_uart[i+5]==' ')) 
....................       { 
....................          write_ext_eeprom(strobe_mobile_num1,buffer_uart[i+6]); 
....................          fputc(buffer_uart[i+6],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+1,buffer_uart[i+7]); 
....................          fputc(buffer_uart[i+7],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+2,buffer_uart[i+8]); 
....................          fputc(buffer_uart[i+8],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+3,buffer_uart[i+9]); 
....................          fputc(buffer_uart[i+9],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+4,buffer_uart[i+10]); 
....................          fputc(buffer_uart[i+10],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+5,buffer_uart[i+11]); 
....................          fputc(buffer_uart[i+11],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+6,buffer_uart[i+12]); 
....................          fputc(buffer_uart[i+12],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+7,buffer_uart[i+13]); 
....................          fputc(buffer_uart[i+13],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+8,buffer_uart[i+14]); 
....................          fputc(buffer_uart[i+14],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+9,buffer_uart[i+15]); 
....................          fputc(buffer_uart[i+15],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+10,buffer_uart[i+16]); 
....................          fputc(buffer_uart[i+16],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+11,buffer_uart[i+17]); 
....................          fputc(buffer_uart[i+17],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+12,buffer_uart[i+18]); 
....................          fputc(buffer_uart[i+18],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+13,buffer_uart[i+19]); 
....................          fputc(buffer_uart[i+19],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+14,buffer_uart[i+20]); 
....................          fputc(buffer_uart[i+20],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+15,buffer_uart[i+21]); 
....................          fputc(buffer_uart[i+21],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+16,buffer_uart[i+22]); 
....................          fputc(buffer_uart[i+22],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+17,buffer_uart[i+23]); 
....................          fputc(buffer_uart[i+23],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+18,buffer_uart[i+24]); 
....................          fputc(buffer_uart[i+24],COM2);          
....................          write_ext_eeprom(strobe_mobile_num1+19,buffer_uart[i+25]); 
....................          fputc(buffer_uart[i+25],COM2); 
....................          write_ext_eeprom(strobe_mobile_num1+20,buffer_uart[i+26]); 
....................          fputc(buffer_uart[i+26],COM2);          
....................          fprintf(COM2,"\r\n"); 
....................          EEPROM_read(strobe_mobile_num1,20,mobilenumb); 
....................          i=250; 
....................          sms_unread_flag=0; 
....................          strcpy (msg_data_sending, "done"); 
....................          send_sms(mobilenumb,msg_data_sending); 
....................          delay_ms(5000); 
....................          delete_sms(1); 
....................          delay_ms(5000); 
....................          UART_index=0; 
....................       } 
....................         else  
....................          { 
....................             if(i>198)  
....................             { 
....................                delay_ms(5000); 
....................                delete_sms(1); 
....................                delay_ms(5000); 
....................                UART_index=0; 
....................                sms_unread_flag=0; 
....................                EEPROM_read(strobe_mobile_num1,20,mobilenumb); 
....................             } 
....................          } 
....................    } 
.................... } 
.................... //============================================== 
.................... /*void del_buf(int8 lenght, unsigned int8 *inputdat) 
.................... { 
....................    int8 i; 
....................    for(i=0;i<lenght;i++) 
....................    { 
....................       inputdat[i]=0; 
....................    } 
.................... }*/ 
.................... //============================================================ 
.................... int8 checking_msg_avai() 
.................... { 
....................    int8 i; 
....................    /*for(i=0;i<100;i++) 
....................    { 
....................       fprintf(COM2,"%c", buffer_uart[i]); 
....................    } 
....................    fprintf(COM2,"%u\r\n", UART_index);//*/ 
....................    for(i=0;i<20;i++) 
....................    { 
....................       if((buffer_uart[i]=='O')&&(buffer_uart[i+1]=='K')) return 1; 
....................    } 
....................    return 0; 
.................... } 
.................... //============================================================ 
.................... int8 SMS_coming() 
*
6512:  MOVLB  A
6514:  CLRF   x8F
.................... { 
.................... //+CMTI: "SM",25 
....................    int8 i,st=0; 
....................    //int8 msg_temp[20],msg_temp1[20]; 
....................    //strncpy(msg_temp1,buffer_uart,20); 
....................    //strcpy(msg_temp,"+CMTI:"); 
....................    for(i=0;i<20;i++) 
6516:  CLRF   x8E
6518:  MOVF   x8E,W
651A:  SUBLW  13
651C:  BTFSS  FD8.0
651E:  BRA    662A
....................    { 
....................       if((buffer_uart[0+i]=='+')&&(buffer_uart[1+i]=='C')&&(buffer_uart[2+i]=='M')&&(buffer_uart[3+i]=='T')&&(buffer_uart[4+i]=='I')&&(buffer_uart[5+i]==':'))  
6520:  CLRF   03
6522:  MOVF   x8E,W
6524:  ADDLW  4E
6526:  MOVWF  FE9
6528:  MOVLW  01
652A:  ADDWFC 03,W
652C:  MOVWF  FEA
652E:  MOVF   FEF,W
6530:  SUBLW  2B
6532:  BTFSS  FD8.2
6534:  BRA    6624
6536:  MOVLW  01
6538:  ADDWF  x8E,W
653A:  CLRF   03
653C:  ADDLW  4E
653E:  MOVWF  FE9
6540:  MOVLW  01
6542:  ADDWFC 03,W
6544:  MOVWF  FEA
6546:  MOVF   FEF,W
6548:  SUBLW  43
654A:  BNZ   6624
654C:  MOVLW  02
654E:  ADDWF  x8E,W
6550:  CLRF   03
6552:  ADDLW  4E
6554:  MOVWF  FE9
6556:  MOVLW  01
6558:  ADDWFC 03,W
655A:  MOVWF  FEA
655C:  MOVF   FEF,W
655E:  SUBLW  4D
6560:  BNZ   6624
6562:  MOVLW  03
6564:  ADDWF  x8E,W
6566:  CLRF   03
6568:  ADDLW  4E
656A:  MOVWF  FE9
656C:  MOVLW  01
656E:  ADDWFC 03,W
6570:  MOVWF  FEA
6572:  MOVF   FEF,W
6574:  SUBLW  54
6576:  BNZ   6624
6578:  MOVLW  04
657A:  ADDWF  x8E,W
657C:  CLRF   03
657E:  ADDLW  4E
6580:  MOVWF  FE9
6582:  MOVLW  01
6584:  ADDWFC 03,W
6586:  MOVWF  FEA
6588:  MOVF   FEF,W
658A:  SUBLW  49
658C:  BNZ   6624
658E:  MOVLW  05
6590:  ADDWF  x8E,W
6592:  CLRF   03
6594:  ADDLW  4E
6596:  MOVWF  FE9
6598:  MOVLW  01
659A:  ADDWFC 03,W
659C:  MOVWF  FEA
659E:  MOVF   FEF,W
65A0:  SUBLW  3A
65A2:  BNZ   6624
....................       {  
....................          fprintf(COM2,"\n\rNew SMS %lu\n\r",over_byte); 
65A4:  MOVLW  9E
65A6:  MOVWF  FF6
65A8:  MOVLW  05
65AA:  MOVWF  FF7
65AC:  CLRF   19
65AE:  BTFSC  FF2.7
65B0:  BSF    19.7
65B2:  BCF    FF2.7
65B4:  MOVLW  0A
65B6:  MOVWF  xD3
65B8:  MOVLB  0
65BA:  CALL   1718
65BE:  BTFSC  19.7
65C0:  BSF    FF2.7
65C2:  MOVLW  10
65C4:  MOVWF  FE9
65C6:  CLRF   19
65C8:  BTFSC  FF2.7
65CA:  BSF    19.7
65CC:  BCF    FF2.7
65CE:  MOVFF  1B7,ABD
65D2:  MOVFF  1B6,ABC
65D6:  CALL   1742
65DA:  BTFSC  19.7
65DC:  BSF    FF2.7
65DE:  CLRF   19
65E0:  BTFSC  FF2.7
65E2:  BSF    19.7
65E4:  BCF    FF2.7
65E6:  MOVLW  0A
65E8:  MOVLB  A
65EA:  MOVWF  xDF
65EC:  MOVLB  0
65EE:  CALL   075A
65F2:  BTFSC  19.7
65F4:  BSF    FF2.7
65F6:  CLRF   19
65F8:  BTFSC  FF2.7
65FA:  BSF    19.7
65FC:  BCF    FF2.7
65FE:  MOVLW  0D
6600:  MOVLB  A
6602:  MOVWF  xDF
6604:  MOVLB  0
6606:  CALL   075A
660A:  BTFSC  19.7
660C:  BSF    FF2.7
....................          //output_high(PIN_C2); 
....................          //SIM_state=reading_sms_cmd; 
....................          SIM_state=config_sms; 
660E:  MOVLB  4
6610:  CLRF   x95
....................          over_byte=0; 
6612:  MOVLB  1
6614:  CLRF   xB7
6616:  CLRF   xB6
....................          st = 2; 
6618:  MOVLW  02
661A:  MOVLB  A
661C:  MOVWF  x8F
....................          i=23; 
661E:  MOVLW  17
6620:  MOVWF  x8E
....................       } 
6622:  BRA    6626
....................          else st=0; 
6624:  CLRF   x8F
6626:  INCF   x8E,F
6628:  BRA    6518
....................     //fprintf(COM2,"%c",'t');   
....................     //fprintf(COM2,"%c",buffer_uart[i]);  
....................    } 
....................    for(i=0;i<20;i++) 
662A:  CLRF   x8E
662C:  MOVF   x8E,W
662E:  SUBLW  13
6630:  BNC   66E4
....................    { 
....................       if((buffer_uart[0+i]=='+')&&(buffer_uart[1+i]=='C')&&(buffer_uart[2+i]=='M')&&(buffer_uart[3+i]=='G')&&(buffer_uart[4+i]=='R')&&(buffer_uart[5+i]==':'))  
6632:  CLRF   03
6634:  MOVF   x8E,W
6636:  ADDLW  4E
6638:  MOVWF  FE9
663A:  MOVLW  01
663C:  ADDWFC 03,W
663E:  MOVWF  FEA
6640:  MOVF   FEF,W
6642:  SUBLW  2B
6644:  BNZ   66DE
6646:  MOVLW  01
6648:  ADDWF  x8E,W
664A:  CLRF   03
664C:  ADDLW  4E
664E:  MOVWF  FE9
6650:  MOVLW  01
6652:  ADDWFC 03,W
6654:  MOVWF  FEA
6656:  MOVF   FEF,W
6658:  SUBLW  43
665A:  BNZ   66DE
665C:  MOVLW  02
665E:  ADDWF  x8E,W
6660:  CLRF   03
6662:  ADDLW  4E
6664:  MOVWF  FE9
6666:  MOVLW  01
6668:  ADDWFC 03,W
666A:  MOVWF  FEA
666C:  MOVF   FEF,W
666E:  SUBLW  4D
6670:  BNZ   66DE
6672:  MOVLW  03
6674:  ADDWF  x8E,W
6676:  CLRF   03
6678:  ADDLW  4E
667A:  MOVWF  FE9
667C:  MOVLW  01
667E:  ADDWFC 03,W
6680:  MOVWF  FEA
6682:  MOVF   FEF,W
6684:  SUBLW  47
6686:  BNZ   66DE
6688:  MOVLW  04
668A:  ADDWF  x8E,W
668C:  CLRF   03
668E:  ADDLW  4E
6690:  MOVWF  FE9
6692:  MOVLW  01
6694:  ADDWFC 03,W
6696:  MOVWF  FEA
6698:  MOVF   FEF,W
669A:  SUBLW  52
669C:  BNZ   66DE
669E:  MOVLW  05
66A0:  ADDWF  x8E,W
66A2:  CLRF   03
66A4:  ADDLW  4E
66A6:  MOVWF  FE9
66A8:  MOVLW  01
66AA:  ADDWFC 03,W
66AC:  MOVWF  FEA
66AE:  MOVF   FEF,W
66B0:  SUBLW  3A
66B2:  BNZ   66DE
....................       {  
....................          fprintf(COM2,"\n\rREC UNREAD\n\r"); 
66B4:  MOVLW  AE
66B6:  MOVWF  FF6
66B8:  MOVLW  05
66BA:  MOVWF  FF7
66BC:  CLRF   19
66BE:  BTFSC  FF2.7
66C0:  BSF    19.7
66C2:  BCF    FF2.7
66C4:  MOVLB  0
66C6:  CALL   07A0
66CA:  BTFSC  19.7
66CC:  BSF    FF2.7
....................          //output_high(PIN_C2); 
....................          //SIM_state=reading_sms_cmd; 
....................          SIM_state=config_sms; 
66CE:  MOVLB  4
66D0:  CLRF   x95
....................          st = 2; 
66D2:  MOVLW  02
66D4:  MOVLB  A
66D6:  MOVWF  x8F
....................          i=23; 
66D8:  MOVLW  17
66DA:  MOVWF  x8E
....................       } 
66DC:  BRA    66E0
....................          else st=0; 
66DE:  CLRF   x8F
66E0:  INCF   x8E,F
66E2:  BRA    662C
....................     //fprintf(COM2,"%c",'t');   
....................     //fprintf(COM2,"%c",buffer_uart[i]);  
....................    } 
....................    for(i=0;i<20;i++) 
66E4:  CLRF   x8E
66E6:  MOVF   x8E,W
66E8:  SUBLW  13
66EA:  BNC   67C2
....................    { 
....................       if((buffer_uart[0+i]=='R')&&(buffer_uart[1+i]=='I')&&(buffer_uart[2+i]=='N')&&(buffer_uart[3+i]=='G'))  
66EC:  CLRF   03
66EE:  MOVF   x8E,W
66F0:  ADDLW  4E
66F2:  MOVWF  FE9
66F4:  MOVLW  01
66F6:  ADDWFC 03,W
66F8:  MOVWF  FEA
66FA:  MOVF   FEF,W
66FC:  SUBLW  52
66FE:  BNZ   67BC
6700:  MOVLW  01
6702:  ADDWF  x8E,W
6704:  CLRF   03
6706:  ADDLW  4E
6708:  MOVWF  FE9
670A:  MOVLW  01
670C:  ADDWFC 03,W
670E:  MOVWF  FEA
6710:  MOVF   FEF,W
6712:  SUBLW  49
6714:  BNZ   67BC
6716:  MOVLW  02
6718:  ADDWF  x8E,W
671A:  CLRF   03
671C:  ADDLW  4E
671E:  MOVWF  FE9
6720:  MOVLW  01
6722:  ADDWFC 03,W
6724:  MOVWF  FEA
6726:  MOVF   FEF,W
6728:  SUBLW  4E
672A:  BNZ   67BC
672C:  MOVLW  03
672E:  ADDWF  x8E,W
6730:  CLRF   03
6732:  ADDLW  4E
6734:  MOVWF  FE9
6736:  MOVLW  01
6738:  ADDWFC 03,W
673A:  MOVWF  FEA
673C:  MOVF   FEF,W
673E:  SUBLW  47
6740:  BNZ   67BC
....................       {  
....................          fprintf(COM2,"\n\rRING %lu\n\r",over_byte); 
6742:  MOVLW  BE
6744:  MOVWF  FF6
6746:  MOVLW  05
6748:  MOVWF  FF7
674A:  CLRF   19
674C:  BTFSC  FF2.7
674E:  BSF    19.7
6750:  BCF    FF2.7
6752:  MOVLW  07
6754:  MOVWF  xD3
6756:  MOVLB  0
6758:  CALL   1718
675C:  BTFSC  19.7
675E:  BSF    FF2.7
6760:  MOVLW  10
6762:  MOVWF  FE9
6764:  CLRF   19
6766:  BTFSC  FF2.7
6768:  BSF    19.7
676A:  BCF    FF2.7
676C:  MOVFF  1B7,ABD
6770:  MOVFF  1B6,ABC
6774:  CALL   1742
6778:  BTFSC  19.7
677A:  BSF    FF2.7
677C:  CLRF   19
677E:  BTFSC  FF2.7
6780:  BSF    19.7
6782:  BCF    FF2.7
6784:  MOVLW  0A
6786:  MOVLB  A
6788:  MOVWF  xDF
678A:  MOVLB  0
678C:  CALL   075A
6790:  BTFSC  19.7
6792:  BSF    FF2.7
6794:  CLRF   19
6796:  BTFSC  FF2.7
6798:  BSF    19.7
679A:  BCF    FF2.7
679C:  MOVLW  0D
679E:  MOVLB  A
67A0:  MOVWF  xDF
67A2:  MOVLB  0
67A4:  CALL   075A
67A8:  BTFSC  19.7
67AA:  BSF    FF2.7
....................          output_high(LED); 
67AC:  BCF    F92.6
67AE:  BSF    F89.6
....................          st = 1; 
67B0:  MOVLW  01
67B2:  MOVLB  A
67B4:  MOVWF  x8F
....................          i=23; 
67B6:  MOVLW  17
67B8:  MOVWF  x8E
....................       } 
67BA:  BRA    67BE
....................          else st=0; 
67BC:  CLRF   x8F
67BE:  INCF   x8E,F
67C0:  BRA    66E6
....................    } 
....................    for(i=0;i<20;i++) 
67C2:  CLRF   x8E
67C4:  MOVF   x8E,W
67C6:  SUBLW  13
67C8:  BTFSS  FD8.0
67CA:  BRA    69B6
....................    { 
....................       if((buffer_uart[0+i]=='+')&&(buffer_uart[1+i]=='C')&&(buffer_uart[2+i]=='P')&&(buffer_uart[3+i]=='A')&&(buffer_uart[4+i]=='S')&&(buffer_uart[5+i]==':'))  
67CC:  CLRF   03
67CE:  MOVF   x8E,W
67D0:  ADDLW  4E
67D2:  MOVWF  FE9
67D4:  MOVLW  01
67D6:  ADDWFC 03,W
67D8:  MOVWF  FEA
67DA:  MOVF   FEF,W
67DC:  SUBLW  2B
67DE:  BTFSS  FD8.2
67E0:  BRA    69B0
67E2:  MOVLW  01
67E4:  ADDWF  x8E,W
67E6:  CLRF   03
67E8:  ADDLW  4E
67EA:  MOVWF  FE9
67EC:  MOVLW  01
67EE:  ADDWFC 03,W
67F0:  MOVWF  FEA
67F2:  MOVF   FEF,W
67F4:  SUBLW  43
67F6:  BTFSS  FD8.2
67F8:  BRA    69B0
67FA:  MOVLW  02
67FC:  ADDWF  x8E,W
67FE:  CLRF   03
6800:  ADDLW  4E
6802:  MOVWF  FE9
6804:  MOVLW  01
6806:  ADDWFC 03,W
6808:  MOVWF  FEA
680A:  MOVF   FEF,W
680C:  SUBLW  50
680E:  BTFSS  FD8.2
6810:  BRA    69B0
6812:  MOVLW  03
6814:  ADDWF  x8E,W
6816:  CLRF   03
6818:  ADDLW  4E
681A:  MOVWF  FE9
681C:  MOVLW  01
681E:  ADDWFC 03,W
6820:  MOVWF  FEA
6822:  MOVF   FEF,W
6824:  SUBLW  41
6826:  BTFSS  FD8.2
6828:  BRA    69B0
682A:  MOVLW  04
682C:  ADDWF  x8E,W
682E:  CLRF   03
6830:  ADDLW  4E
6832:  MOVWF  FE9
6834:  MOVLW  01
6836:  ADDWFC 03,W
6838:  MOVWF  FEA
683A:  MOVF   FEF,W
683C:  SUBLW  53
683E:  BTFSS  FD8.2
6840:  BRA    69B0
6842:  MOVLW  05
6844:  ADDWF  x8E,W
6846:  CLRF   03
6848:  ADDLW  4E
684A:  MOVWF  FE9
684C:  MOVLW  01
684E:  ADDWFC 03,W
6850:  MOVWF  FEA
6852:  MOVF   FEF,W
6854:  SUBLW  3A
6856:  BTFSS  FD8.2
6858:  BRA    69B0
....................       {  
....................          if(buffer_uart[7+i]=='0')  
685A:  MOVLW  07
685C:  ADDWF  x8E,W
685E:  CLRF   03
6860:  ADDLW  4E
6862:  MOVWF  FE9
6864:  MOVLW  01
6866:  ADDWFC 03,W
6868:  MOVWF  FEA
686A:  MOVF   FEF,W
686C:  SUBLW  30
686E:  BNZ   68E8
....................          { 
....................             fprintf(COM2,"Ready (MT allows commands from TA/TE)%lu\n\r",over_byte); 
6870:  MOVLW  CC
6872:  MOVWF  FF6
6874:  MOVLW  05
6876:  MOVWF  FF7
6878:  CLRF   19
687A:  BTFSC  FF2.7
687C:  BSF    19.7
687E:  BCF    FF2.7
6880:  MOVLW  25
6882:  MOVWF  xD3
6884:  MOVLB  0
6886:  CALL   1718
688A:  BTFSC  19.7
688C:  BSF    FF2.7
688E:  MOVLW  10
6890:  MOVWF  FE9
6892:  CLRF   19
6894:  BTFSC  FF2.7
6896:  BSF    19.7
6898:  BCF    FF2.7
689A:  MOVFF  1B7,ABD
689E:  MOVFF  1B6,ABC
68A2:  CALL   1742
68A6:  BTFSC  19.7
68A8:  BSF    FF2.7
68AA:  CLRF   19
68AC:  BTFSC  FF2.7
68AE:  BSF    19.7
68B0:  BCF    FF2.7
68B2:  MOVLW  0A
68B4:  MOVLB  A
68B6:  MOVWF  xDF
68B8:  MOVLB  0
68BA:  CALL   075A
68BE:  BTFSC  19.7
68C0:  BSF    FF2.7
68C2:  CLRF   19
68C4:  BTFSC  FF2.7
68C6:  BSF    19.7
68C8:  BCF    FF2.7
68CA:  MOVLW  0D
68CC:  MOVLB  A
68CE:  MOVWF  xDF
68D0:  MOVLB  0
68D2:  CALL   075A
68D6:  BTFSC  19.7
68D8:  BSF    FF2.7
....................             SIM_state= check_inbox; 
68DA:  MOVLW  11
68DC:  MOVLB  4
68DE:  MOVWF  x95
....................             over_byte=0; 
68E0:  MOVLB  1
68E2:  CLRF   xB7
68E4:  CLRF   xB6
68E6:  MOVLB  A
....................          } 
....................          if(buffer_uart[7+i]=='2') 
68E8:  MOVLW  07
68EA:  ADDWF  x8E,W
68EC:  CLRF   03
68EE:  ADDLW  4E
68F0:  MOVWF  FE9
68F2:  MOVLW  01
68F4:  ADDWFC 03,W
68F6:  MOVWF  FEA
68F8:  MOVF   FEF,W
68FA:  SUBLW  32
68FC:  BNZ   6942
....................          { 
....................             fprintf(COM2,"No network\n\r"); 
68FE:  MOVLW  F8
6900:  MOVWF  FF6
6902:  MOVLW  05
6904:  MOVWF  FF7
6906:  CLRF   19
6908:  BTFSC  FF2.7
690A:  BSF    19.7
690C:  BCF    FF2.7
690E:  MOVLB  0
6910:  CALL   07A0
6914:  BTFSC  19.7
6916:  BSF    FF2.7
....................             #if defined(SIM900) 
....................                booting_done=0; 
6918:  MOVLB  1
691A:  CLRF   xB5
....................                output_low(rst_sim); 
691C:  BCF    F94.1
691E:  BCF    F8B.1
....................                fprintf(COM2,"reseting module SIM\n\r"); 
6920:  MOVLW  06
6922:  MOVWF  FF6
6924:  MOVLW  06
6926:  MOVWF  FF7
6928:  CLRF   19
692A:  BTFSC  FF2.7
692C:  BSF    19.7
692E:  BCF    FF2.7
6930:  MOVLB  0
6932:  CALL   07A0
6936:  BTFSC  19.7
6938:  BSF    FF2.7
....................             #endif    
....................             SIM_state=check_comunication; 
693A:  MOVLW  0F
693C:  MOVLB  4
693E:  MOVWF  x95
6940:  MOVLB  A
....................          } 
....................          if(buffer_uart[7+i]=='3') fprintf(COM2,"Ringing\n\r"); 
6942:  MOVLW  07
6944:  ADDWF  x8E,W
6946:  CLRF   03
6948:  ADDLW  4E
694A:  MOVWF  FE9
694C:  MOVLW  01
694E:  ADDWFC 03,W
6950:  MOVWF  FEA
6952:  MOVF   FEF,W
6954:  SUBLW  33
6956:  BNZ   6974
6958:  MOVLW  1C
695A:  MOVWF  FF6
695C:  MOVLW  06
695E:  MOVWF  FF7
6960:  CLRF   19
6962:  BTFSC  FF2.7
6964:  BSF    19.7
6966:  BCF    FF2.7
6968:  MOVLB  0
696A:  CALL   07A0
696E:  BTFSC  19.7
6970:  BSF    FF2.7
6972:  MOVLB  A
....................          if(buffer_uart[7+i]=='4') fprintf(COM2,"Call in progress\n\r"); 
6974:  MOVLW  07
6976:  ADDWF  x8E,W
6978:  CLRF   03
697A:  ADDLW  4E
697C:  MOVWF  FE9
697E:  MOVLW  01
6980:  ADDWFC 03,W
6982:  MOVWF  FEA
6984:  MOVF   FEF,W
6986:  SUBLW  34
6988:  BNZ   69A6
698A:  MOVLW  26
698C:  MOVWF  FF6
698E:  MOVLW  06
6990:  MOVWF  FF7
6992:  CLRF   19
6994:  BTFSC  FF2.7
6996:  BSF    19.7
6998:  BCF    FF2.7
699A:  MOVLB  0
699C:  CALL   07A0
69A0:  BTFSC  19.7
69A2:  BSF    FF2.7
69A4:  MOVLB  A
....................          st = 3; 
69A6:  MOVLW  03
69A8:  MOVWF  x8F
....................          i=23; 
69AA:  MOVLW  17
69AC:  MOVWF  x8E
....................       } 
69AE:  BRA    69B2
....................          else st=0; 
69B0:  CLRF   x8F
69B2:  INCF   x8E,F
69B4:  BRA    67C4
....................    } 
....................    for(i=0;i<20;i++) 
69B6:  CLRF   x8E
69B8:  MOVF   x8E,W
69BA:  SUBLW  13
69BC:  BTFSS  FD8.0
69BE:  BRA    6AB6
....................    { 
....................       if((buffer_uart[0+i]=='U')&&(buffer_uart[1+i]=='N')&&(buffer_uart[2+i]=='D')&&(buffer_uart[3+i]=='E')&&(buffer_uart[4+i]=='R')&&(buffer_uart[5+i]=='-')&&(buffer_uart[6+i]=='V')&&(buffer_uart[7+i]=='O')&&(buffer_uart[8+i]=='L'))  
69C0:  CLRF   03
69C2:  MOVF   x8E,W
69C4:  ADDLW  4E
69C6:  MOVWF  FE9
69C8:  MOVLW  01
69CA:  ADDWFC 03,W
69CC:  MOVWF  FEA
69CE:  MOVF   FEF,W
69D0:  SUBLW  55
69D2:  BTFSS  FD8.2
69D4:  BRA    6AB0
69D6:  MOVLW  01
69D8:  ADDWF  x8E,W
69DA:  CLRF   03
69DC:  ADDLW  4E
69DE:  MOVWF  FE9
69E0:  MOVLW  01
69E2:  ADDWFC 03,W
69E4:  MOVWF  FEA
69E6:  MOVF   FEF,W
69E8:  SUBLW  4E
69EA:  BNZ   6AB0
69EC:  MOVLW  02
69EE:  ADDWF  x8E,W
69F0:  CLRF   03
69F2:  ADDLW  4E
69F4:  MOVWF  FE9
69F6:  MOVLW  01
69F8:  ADDWFC 03,W
69FA:  MOVWF  FEA
69FC:  MOVF   FEF,W
69FE:  SUBLW  44
6A00:  BNZ   6AB0
6A02:  MOVLW  03
6A04:  ADDWF  x8E,W
6A06:  CLRF   03
6A08:  ADDLW  4E
6A0A:  MOVWF  FE9
6A0C:  MOVLW  01
6A0E:  ADDWFC 03,W
6A10:  MOVWF  FEA
6A12:  MOVF   FEF,W
6A14:  SUBLW  45
6A16:  BNZ   6AB0
6A18:  MOVLW  04
6A1A:  ADDWF  x8E,W
6A1C:  CLRF   03
6A1E:  ADDLW  4E
6A20:  MOVWF  FE9
6A22:  MOVLW  01
6A24:  ADDWFC 03,W
6A26:  MOVWF  FEA
6A28:  MOVF   FEF,W
6A2A:  SUBLW  52
6A2C:  BNZ   6AB0
6A2E:  MOVLW  05
6A30:  ADDWF  x8E,W
6A32:  CLRF   03
6A34:  ADDLW  4E
6A36:  MOVWF  FE9
6A38:  MOVLW  01
6A3A:  ADDWFC 03,W
6A3C:  MOVWF  FEA
6A3E:  MOVF   FEF,W
6A40:  SUBLW  2D
6A42:  BNZ   6AB0
6A44:  MOVLW  06
6A46:  ADDWF  x8E,W
6A48:  CLRF   03
6A4A:  ADDLW  4E
6A4C:  MOVWF  FE9
6A4E:  MOVLW  01
6A50:  ADDWFC 03,W
6A52:  MOVWF  FEA
6A54:  MOVF   FEF,W
6A56:  SUBLW  56
6A58:  BNZ   6AB0
6A5A:  MOVLW  07
6A5C:  ADDWF  x8E,W
6A5E:  CLRF   03
6A60:  ADDLW  4E
6A62:  MOVWF  FE9
6A64:  MOVLW  01
6A66:  ADDWFC 03,W
6A68:  MOVWF  FEA
6A6A:  MOVF   FEF,W
6A6C:  SUBLW  4F
6A6E:  BNZ   6AB0
6A70:  MOVLW  08
6A72:  ADDWF  x8E,W
6A74:  CLRF   03
6A76:  ADDLW  4E
6A78:  MOVWF  FE9
6A7A:  MOVLW  01
6A7C:  ADDWFC 03,W
6A7E:  MOVWF  FEA
6A80:  MOVF   FEF,W
6A82:  SUBLW  4C
6A84:  BNZ   6AB0
....................       {  
....................          fprintf(COM2,"\n\rUNDER-VOLTAGE WARNNING\n\r"); 
6A86:  MOVLW  3A
6A88:  MOVWF  FF6
6A8A:  MOVLW  06
6A8C:  MOVWF  FF7
6A8E:  CLRF   19
6A90:  BTFSC  FF2.7
6A92:  BSF    19.7
6A94:  BCF    FF2.7
6A96:  MOVLB  0
6A98:  CALL   07A0
6A9C:  BTFSC  19.7
6A9E:  BSF    FF2.7
....................          //SIM_state=reading_sms_cmd; 
....................          SIM_state=config_sms; 
6AA0:  MOVLB  4
6AA2:  CLRF   x95
....................          st = 4; 
6AA4:  MOVLW  04
6AA6:  MOVLB  A
6AA8:  MOVWF  x8F
....................          i=23; 
6AAA:  MOVLW  17
6AAC:  MOVWF  x8E
....................       } 
6AAE:  BRA    6AB2
....................          else st=0; 
6AB0:  CLRF   x8F
6AB2:  INCF   x8E,F
6AB4:  BRA    69B8
....................    } 
....................    for(i=0;i<20;i++) 
6AB6:  CLRF   x8E
6AB8:  MOVF   x8E,W
6ABA:  SUBLW  13
6ABC:  BTFSS  FD8.0
6ABE:  BRA    6BB6
....................    { 
....................       if((buffer_uart[0+i]=='O')&&(buffer_uart[1+i]=='V')&&(buffer_uart[2+i]=='E')&&(buffer_uart[3+i]=='R')&&(buffer_uart[4+i]=='-')&&(buffer_uart[5+i]=='V')&&(buffer_uart[6+i]=='O')&&(buffer_uart[7+i]=='L')&&(buffer_uart[8+i]=='T'))  
6AC0:  CLRF   03
6AC2:  MOVF   x8E,W
6AC4:  ADDLW  4E
6AC6:  MOVWF  FE9
6AC8:  MOVLW  01
6ACA:  ADDWFC 03,W
6ACC:  MOVWF  FEA
6ACE:  MOVF   FEF,W
6AD0:  SUBLW  4F
6AD2:  BTFSS  FD8.2
6AD4:  BRA    6BB0
6AD6:  MOVLW  01
6AD8:  ADDWF  x8E,W
6ADA:  CLRF   03
6ADC:  ADDLW  4E
6ADE:  MOVWF  FE9
6AE0:  MOVLW  01
6AE2:  ADDWFC 03,W
6AE4:  MOVWF  FEA
6AE6:  MOVF   FEF,W
6AE8:  SUBLW  56
6AEA:  BNZ   6BB0
6AEC:  MOVLW  02
6AEE:  ADDWF  x8E,W
6AF0:  CLRF   03
6AF2:  ADDLW  4E
6AF4:  MOVWF  FE9
6AF6:  MOVLW  01
6AF8:  ADDWFC 03,W
6AFA:  MOVWF  FEA
6AFC:  MOVF   FEF,W
6AFE:  SUBLW  45
6B00:  BNZ   6BB0
6B02:  MOVLW  03
6B04:  ADDWF  x8E,W
6B06:  CLRF   03
6B08:  ADDLW  4E
6B0A:  MOVWF  FE9
6B0C:  MOVLW  01
6B0E:  ADDWFC 03,W
6B10:  MOVWF  FEA
6B12:  MOVF   FEF,W
6B14:  SUBLW  52
6B16:  BNZ   6BB0
6B18:  MOVLW  04
6B1A:  ADDWF  x8E,W
6B1C:  CLRF   03
6B1E:  ADDLW  4E
6B20:  MOVWF  FE9
6B22:  MOVLW  01
6B24:  ADDWFC 03,W
6B26:  MOVWF  FEA
6B28:  MOVF   FEF,W
6B2A:  SUBLW  2D
6B2C:  BNZ   6BB0
6B2E:  MOVLW  05
6B30:  ADDWF  x8E,W
6B32:  CLRF   03
6B34:  ADDLW  4E
6B36:  MOVWF  FE9
6B38:  MOVLW  01
6B3A:  ADDWFC 03,W
6B3C:  MOVWF  FEA
6B3E:  MOVF   FEF,W
6B40:  SUBLW  56
6B42:  BNZ   6BB0
6B44:  MOVLW  06
6B46:  ADDWF  x8E,W
6B48:  CLRF   03
6B4A:  ADDLW  4E
6B4C:  MOVWF  FE9
6B4E:  MOVLW  01
6B50:  ADDWFC 03,W
6B52:  MOVWF  FEA
6B54:  MOVF   FEF,W
6B56:  SUBLW  4F
6B58:  BNZ   6BB0
6B5A:  MOVLW  07
6B5C:  ADDWF  x8E,W
6B5E:  CLRF   03
6B60:  ADDLW  4E
6B62:  MOVWF  FE9
6B64:  MOVLW  01
6B66:  ADDWFC 03,W
6B68:  MOVWF  FEA
6B6A:  MOVF   FEF,W
6B6C:  SUBLW  4C
6B6E:  BNZ   6BB0
6B70:  MOVLW  08
6B72:  ADDWF  x8E,W
6B74:  CLRF   03
6B76:  ADDLW  4E
6B78:  MOVWF  FE9
6B7A:  MOVLW  01
6B7C:  ADDWFC 03,W
6B7E:  MOVWF  FEA
6B80:  MOVF   FEF,W
6B82:  SUBLW  54
6B84:  BNZ   6BB0
....................       {  
....................          fprintf(COM2,"\n\rOVER-VOLTAGE POWER DOWN\n\r"); 
6B86:  MOVLW  56
6B88:  MOVWF  FF6
6B8A:  MOVLW  06
6B8C:  MOVWF  FF7
6B8E:  CLRF   19
6B90:  BTFSC  FF2.7
6B92:  BSF    19.7
6B94:  BCF    FF2.7
6B96:  MOVLB  0
6B98:  CALL   07A0
6B9C:  BTFSC  19.7
6B9E:  BSF    FF2.7
....................          //SIM_state=reading_sms_cmd; 
....................          SIM_state=config_sms; 
6BA0:  MOVLB  4
6BA2:  CLRF   x95
....................          st = 4; 
6BA4:  MOVLW  04
6BA6:  MOVLB  A
6BA8:  MOVWF  x8F
....................          i=23; 
6BAA:  MOVLW  17
6BAC:  MOVWF  x8E
....................       } 
6BAE:  BRA    6BB2
....................          else st=0; 
6BB0:  CLRF   x8F
6BB2:  INCF   x8E,F
6BB4:  BRA    6AB8
....................    } 
....................  
....................    UART_index=0; 
6BB6:  MOVLB  1
6BB8:  CLRF   xB2
....................    memset(buffer_uart,0,sizeof(buffer_uart));  
6BBA:  MOVLW  01
6BBC:  MOVWF  FEA
6BBE:  MOVLW  4E
6BC0:  MOVWF  FE9
6BC2:  CLRF   00
6BC4:  CLRF   02
6BC6:  MOVLW  64
6BC8:  MOVWF  01
6BCA:  MOVLB  0
6BCC:  CALL   4476
....................    return st; 
6BD0:  MOVLB  A
6BD2:  MOVFF  A8F,01
6BD6:  MOVLB  0
6BD8:  GOTO   97A6 (RETURN)
.................... } 
.................... //============================================================ 
.................... unsigned int8 analyzing_msg(char* MSG,char* mobile_number) 
*
5402:  MOVLB  A
5404:  CLRF   x92
5406:  CLRF   x93
5408:  CLRF   x94
540A:  CLRF   x95
540C:  CLRF   x96
540E:  CLRF   x97
5410:  CLRF   x98
5412:  CLRF   19
5414:  BTFSC  FF2.7
5416:  BSF    19.7
5418:  BCF    FF2.7
.................... { 
....................    unsigned int8 i=0,a=0,b=0,d=0,u=0,v=0; 
....................    unsigned int8 st=0,temp; 
....................    del_buf(50,MSG); 
541A:  MOVLW  32
541C:  MOVWF  xC5
541E:  MOVFF  A8F,AC7
5422:  MOVFF  A8E,AC6
5426:  MOVLB  0
5428:  CALL   3A74
542C:  BTFSC  19.7
542E:  BSF    FF2.7
5430:  CLRF   19
5432:  BTFSC  FF2.7
5434:  BSF    19.7
5436:  BCF    FF2.7
....................    del_buf(20,mobile_number); 
5438:  MOVLW  14
543A:  MOVLB  A
543C:  MOVWF  xC5
543E:  MOVFF  A91,AC7
5442:  MOVFF  A90,AC6
5446:  MOVLB  0
5448:  CALL   3A74
544C:  BTFSC  19.7
544E:  BSF    FF2.7
....................    for(i=0;i<100;i++) 
5450:  MOVLB  A
5452:  CLRF   x92
5454:  MOVF   x92,W
5456:  SUBLW  63
5458:  BNC   5488
....................    { 
....................       fprintf(COM2,"%c",buffer_uart[i]);  
545A:  CLRF   03
545C:  MOVF   x92,W
545E:  ADDLW  4E
5460:  MOVWF  FE9
5462:  MOVLW  01
5464:  ADDWFC 03,W
5466:  MOVWF  FEA
5468:  MOVFF  FEF,A9A
546C:  CLRF   19
546E:  BTFSC  FF2.7
5470:  BSF    19.7
5472:  BCF    FF2.7
5474:  MOVFF  A9A,ADF
5478:  MOVLB  0
547A:  CALL   075A
547E:  BTFSC  19.7
5480:  BSF    FF2.7
5482:  MOVLB  A
5484:  INCF   x92,F
5486:  BRA    5454
....................    } 
....................    for(i=0;i<100;i++) 
5488:  CLRF   x92
548A:  MOVF   x92,W
548C:  SUBLW  63
548E:  BTFSS  FD8.0
5490:  BRA    5698
....................    { 
....................       if((buffer_uart[i]=='+')&&(buffer_uart[i+1]=='C')&&(buffer_uart[i+2]=='M')&&(buffer_uart[i+3]=='G')&&(buffer_uart[i+4]=='R')&&(buffer_uart[i+5]==':')&&(buffer_uart[i+6]==' ')&&(buffer_uart[i+7]=='0')&&(buffer_uart[i+8]==',')&&(buffer_uart[i+9]==',')&&(buffer_uart[i+10]=='0'))  
5492:  CLRF   03
5494:  MOVF   x92,W
5496:  ADDLW  4E
5498:  MOVWF  FE9
549A:  MOVLW  01
549C:  ADDWFC 03,W
549E:  MOVWF  FEA
54A0:  MOVF   FEF,W
54A2:  SUBLW  2B
54A4:  BTFSS  FD8.2
54A6:  BRA    55D4
54A8:  MOVLW  01
54AA:  ADDWF  x92,W
54AC:  CLRF   03
54AE:  ADDLW  4E
54B0:  MOVWF  FE9
54B2:  MOVLW  01
54B4:  ADDWFC 03,W
54B6:  MOVWF  FEA
54B8:  MOVF   FEF,W
54BA:  SUBLW  43
54BC:  BTFSS  FD8.2
54BE:  BRA    55D4
54C0:  MOVLW  02
54C2:  ADDWF  x92,W
54C4:  CLRF   03
54C6:  ADDLW  4E
54C8:  MOVWF  FE9
54CA:  MOVLW  01
54CC:  ADDWFC 03,W
54CE:  MOVWF  FEA
54D0:  MOVF   FEF,W
54D2:  SUBLW  4D
54D4:  BTFSS  FD8.2
54D6:  BRA    55D4
54D8:  MOVLW  03
54DA:  ADDWF  x92,W
54DC:  CLRF   03
54DE:  ADDLW  4E
54E0:  MOVWF  FE9
54E2:  MOVLW  01
54E4:  ADDWFC 03,W
54E6:  MOVWF  FEA
54E8:  MOVF   FEF,W
54EA:  SUBLW  47
54EC:  BTFSS  FD8.2
54EE:  BRA    55D4
54F0:  MOVLW  04
54F2:  ADDWF  x92,W
54F4:  CLRF   03
54F6:  ADDLW  4E
54F8:  MOVWF  FE9
54FA:  MOVLW  01
54FC:  ADDWFC 03,W
54FE:  MOVWF  FEA
5500:  MOVF   FEF,W
5502:  SUBLW  52
5504:  BNZ   55D4
5506:  MOVLW  05
5508:  ADDWF  x92,W
550A:  CLRF   03
550C:  ADDLW  4E
550E:  MOVWF  FE9
5510:  MOVLW  01
5512:  ADDWFC 03,W
5514:  MOVWF  FEA
5516:  MOVF   FEF,W
5518:  SUBLW  3A
551A:  BNZ   55D4
551C:  MOVLW  06
551E:  ADDWF  x92,W
5520:  CLRF   03
5522:  ADDLW  4E
5524:  MOVWF  FE9
5526:  MOVLW  01
5528:  ADDWFC 03,W
552A:  MOVWF  FEA
552C:  MOVF   FEF,W
552E:  SUBLW  20
5530:  BNZ   55D4
5532:  MOVLW  07
5534:  ADDWF  x92,W
5536:  CLRF   03
5538:  ADDLW  4E
553A:  MOVWF  FE9
553C:  MOVLW  01
553E:  ADDWFC 03,W
5540:  MOVWF  FEA
5542:  MOVF   FEF,W
5544:  SUBLW  30
5546:  BNZ   55D4
5548:  MOVLW  08
554A:  ADDWF  x92,W
554C:  CLRF   03
554E:  ADDLW  4E
5550:  MOVWF  FE9
5552:  MOVLW  01
5554:  ADDWFC 03,W
5556:  MOVWF  FEA
5558:  MOVF   FEF,W
555A:  SUBLW  2C
555C:  BNZ   55D4
555E:  MOVLW  09
5560:  ADDWF  x92,W
5562:  CLRF   03
5564:  ADDLW  4E
5566:  MOVWF  FE9
5568:  MOVLW  01
556A:  ADDWFC 03,W
556C:  MOVWF  FEA
556E:  MOVF   FEF,W
5570:  SUBLW  2C
5572:  BNZ   55D4
5574:  MOVLW  0A
5576:  ADDWF  x92,W
5578:  CLRF   03
557A:  ADDLW  4E
557C:  MOVWF  FE9
557E:  MOVLW  01
5580:  ADDWFC 03,W
5582:  MOVWF  FEA
5584:  MOVF   FEF,W
5586:  SUBLW  30
5588:  BNZ   55D4
....................       { 
....................          st=0; 
558A:  CLRF   x98
....................          i=200; 
558C:  MOVLW  C8
558E:  MOVWF  x92
5590:  CLRF   19
5592:  BTFSC  FF2.7
5594:  BSF    19.7
5596:  BCF    FF2.7
....................          del_buf(100,MSG); 
5598:  MOVLW  64
559A:  MOVWF  xC5
559C:  MOVFF  A8F,AC7
55A0:  MOVFF  A8E,AC6
55A4:  MOVLB  0
55A6:  CALL   3A74
55AA:  BTFSC  19.7
55AC:  BSF    FF2.7
55AE:  CLRF   19
55B0:  BTFSC  FF2.7
55B2:  BSF    19.7
55B4:  BCF    FF2.7
....................          del_buf(16,mobile_number); 
55B6:  MOVLW  10
55B8:  MOVLB  A
55BA:  MOVWF  xC5
55BC:  MOVFF  A91,AC7
55C0:  MOVFF  A90,AC6
55C4:  MOVLB  0
55C6:  CALL   3A74
55CA:  BTFSC  19.7
55CC:  BSF    FF2.7
....................          count_spam=0; 
55CE:  MOVLB  1
55D0:  CLRF   x04
55D2:  MOVLB  A
....................          //output_toggle(pin_a5); 
....................       } 
....................          //else st=2; 
....................      temp = buffer_uart[i]; 
55D4:  CLRF   03
55D6:  MOVF   x92,W
55D8:  ADDLW  4E
55DA:  MOVWF  FE9
55DC:  MOVLW  01
55DE:  ADDWFC 03,W
55E0:  MOVWF  FEA
55E2:  MOVFF  FEF,A99
....................      if((a==3))  
55E6:  MOVF   x93,W
55E8:  SUBLW  03
55EA:  BNZ   5610
....................      { 
....................        if((temp>47)&&(temp<58)||temp=='+') mobile_number[i-b] = temp; 
55EC:  MOVF   x99,W
55EE:  SUBLW  2F
55F0:  BC    55F8
55F2:  MOVF   x99,W
55F4:  SUBLW  39
55F6:  BC    55FE
55F8:  MOVF   x99,W
55FA:  SUBLW  2B
55FC:  BNZ   5610
55FE:  MOVF   x94,W
5600:  SUBWF  x92,W
5602:  ADDWF  x90,W
5604:  MOVWF  FE9
5606:  MOVLW  00
5608:  ADDWFC x91,W
560A:  MOVWF  FEA
560C:  MOVFF  A99,FEF
....................      } 
....................      if(d==2) 
5610:  MOVF   x95,W
5612:  SUBLW  02
5614:  BNZ   562C
....................      { 
....................          MSG[i-b] = temp; 
5616:  MOVF   x94,W
5618:  SUBWF  x92,W
561A:  ADDWF  x8E,W
561C:  MOVWF  FE9
561E:  MOVLW  00
5620:  ADDWFC x8F,W
5622:  MOVWF  FEA
5624:  MOVFF  A99,FEF
....................          st=1; 
5628:  MOVLW  01
562A:  MOVWF  x98
....................      } 
....................      if(u==2) 
562C:  MOVF   x96,W
562E:  SUBLW  02
5630:  BNZ   5646
....................      { 
....................          datetime[i-v]=temp; 
5632:  MOVF   x97,W
5634:  SUBWF  x92,W
5636:  CLRF   03
5638:  ADDLW  60
563A:  MOVWF  FE9
563C:  MOVLW  04
563E:  ADDWFC 03,W
5640:  MOVWF  FEA
5642:  MOVFF  A99,FEF
....................      } 
....................       //else st=2; 
....................      if(temp==34)  
5646:  MOVF   x99,W
5648:  SUBLW  22
564A:  BNZ   5660
....................      { 
....................          if(a<6)a++; 
564C:  MOVF   x93,W
564E:  SUBLW  05
5650:  BNC   5654
5652:  INCF   x93,F
....................          if(a==3) b = i+1; 
5654:  MOVF   x93,W
5656:  SUBLW  03
5658:  BNZ   5660
565A:  MOVLW  01
565C:  ADDWF  x92,W
565E:  MOVWF  x94
....................      } 
....................      if(a==6) 
5660:  MOVF   x93,W
5662:  SUBLW  06
5664:  BNZ   5694
....................      { 
....................          if((temp==13)||(temp==10))  
5666:  MOVF   x99,W
5668:  SUBLW  0D
566A:  BZ    5672
566C:  MOVF   x99,W
566E:  SUBLW  0A
5670:  BNZ   5680
....................          { 
....................             d++; 
5672:  INCF   x95,F
....................             if(d==2) b = i+1; 
5674:  MOVF   x95,W
5676:  SUBLW  02
5678:  BNZ   5680
567A:  MOVLW  01
567C:  ADDWF  x92,W
567E:  MOVWF  x94
....................          } 
....................          if(temp==34)  
5680:  MOVF   x99,W
5682:  SUBLW  22
5684:  BNZ   5694
....................          { 
....................             u++; 
5686:  INCF   x96,F
....................             if(u==2)v=i+1; 
5688:  MOVF   x96,W
568A:  SUBLW  02
568C:  BNZ   5694
568E:  MOVLW  01
5690:  ADDWF  x92,W
5692:  MOVWF  x97
....................          } 
....................      } 
5694:  INCF   x92,F
5696:  BRA    548A
....................      //if((temp==',')&&(a==6)) 
....................     // { 
....................          //if(c<2)c++; 
....................      //} 
....................    } 
....................    return(st); 
5698:  MOVFF  A98,01
569C:  MOVLB  0
569E:  GOTO   747C (RETURN)
.................... } 
.................... //================================ 
.................... int8 ascii2int(int8 num1,int8 num2) 
.................... { 
....................    int8 temp; 
....................    temp=(num1-48)*10 + (num2-48); 
*
583A:  MOVLW  30
583C:  MOVLB  A
583E:  SUBWF  x8F,W
5840:  MULLW  0A
5842:  MOVFF  FF3,A92
5846:  MOVLW  30
5848:  SUBWF  x90,W
584A:  ADDWF  x92,W
584C:  MOVWF  x91
....................    return temp; 
584E:  MOVFF  A91,01
5852:  MOVLB  0
5854:  RETURN 0
.................... } 
.................... //================================ 
.................... void updatetime2ds1307() 
.................... { 
....................    int8 temp; 
....................    year=ascii2int(datetime[0],datetime[1]); 
*
59EC:  MOVFF  460,A8F
59F0:  MOVFF  461,A90
59F4:  RCALL  583A
59F6:  MOVFF  01,FE
....................    mon=ascii2int(datetime[3],datetime[4]); 
59FA:  MOVFF  463,A8F
59FE:  MOVFF  464,A90
5A02:  RCALL  583A
5A04:  MOVFF  01,FF
....................    date=ascii2int(datetime[6],datetime[7]); 
5A08:  MOVFF  466,A8F
5A0C:  MOVFF  467,A90
5A10:  RCALL  583A
5A12:  MOVFF  01,100
....................    h=ascii2int(datetime[9],datetime[10]); 
5A16:  MOVFF  469,A8F
5A1A:  MOVFF  46A,A90
5A1E:  RCALL  583A
5A20:  MOVFF  01,101
....................    min=ascii2int(datetime[12],datetime[13])+1; 
5A24:  MOVFF  46C,A8F
5A28:  MOVFF  46D,A90
5A2C:  RCALL  583A
5A2E:  MOVLW  01
5A30:  ADDWF  01,W
5A32:  MOVLB  1
5A34:  MOVWF  x02
....................    //h=ascii2int(datetime[9],datetime[10]); 
....................    rtc_set_datetime(date,mon,year,day,h,min); 
5A36:  MOVFF  100,A8F
5A3A:  MOVFF  FF,A90
5A3E:  MOVFF  FE,A91
5A42:  MOVFF  FD,A92
5A46:  MOVFF  101,A93
5A4A:  MOVFF  102,A94
5A4E:  MOVLB  0
5A50:  BRA    5942
5A52:  RETURN 0
.................... } 
.................... //================================ 
....................  
.................... /*#if defined(SIM900) 
....................    #include <GSM.c>    
.................... #endif*/ 
....................  
....................  
.................... #include "mcr.c" 
....................  
.................... /*#define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_B4 
.................... #define MCR_STROBE2        PIN_B5*/ 
.................... #byte   RPINR1 =   getenv("SFR:RPINR1") 
.................... #byte   RPINR2 =   getenv("SFR:RPINR2") 
....................  
.................... #define MCR_CARD_PRESENT   PIN_B0 
.................... #define MCR_DATA1          PIN_B1 
.................... #define MCR_STROBE1        PIN_B2 
.................... #define MCR_DATA2          PIN_C5 
.................... #define MCR_STROBE2        PIN_B3 
....................  
.................... // The following define the error codes. 
.................... // To check for a specific error, check 
.................... // the cooresponding bit in the value 
.................... // returned by mcr_read(). 
.................... #define MCR_ERR_PARITY1 1 
.................... #define MCR_ERR_PARITY2 2 
.................... #define MCR_ERR_LRC1    4 
.................... #define MCR_ERR_LRC2    8 
....................  
.................... #define numbyteoftrack1 79 
.................... #define numbyteoftrack2 40 
.................... #define numbyteofbuffer1    850 
.................... #define numbyteofbuffer2    300 
.................... //#define numbyteofbuffer    100 
.................... //===================================== 
.................... char Track1[numbyteoftrack1]; 
.................... char Track2[numbyteoftrack2]; 
....................  
.................... char buffertrack1[numbyteofbuffer1]; 
.................... char buffertrack2[numbyteofbuffer2]; 
.................... //char temptrack1[numbyteofbuffer1]; 
.................... //char temptrack2[numbyteofbuffer2]; 
....................  
.................... int32 mcr_timeout=0; 
.................... int8 dir=0; 
.................... int16 countbit_T1=0,countbit_T2=0; 
.................... int16 bug_countbit_T1=0,bug_countbit_T2=0; 
.................... int16 card_timeout=65000; 
.................... int16 countbit=0; 
.................... int8 datinbuf=0; 
.................... int8 debugmode=0; 
.................... int8 cardread_st=0; 
.................... int8 saving_flag=0; 
.................... int8 data_avai=0; 
.................... int8 reading_fg=0; 
.................... int8 count_reading_error=0; 
.................... //========================= 
.................... //#include "mcrtool.c" 
.................... //============================ 
.................... int8 makebyte(int8 bit7,int8 bit6,int8 bit5,int8 bit4,int8 bit3,int8 bit2,int8 bit1,int8 bit0) 
*
07C0:  MOVLB  A
07C2:  CLRF   xEF
.................... { 
....................    int8 temp=0; 
....................    temp=bit7<<7|bit6<<6|bit5<<5|bit4<<4|bit3<<3|bit2<<2|bit1<<1|bit0<<0; 
07C4:  CLRF   xF0
07C6:  BTFSC  xE7.0
07C8:  BSF    xF0.7
07CA:  SWAPF  xE8,W
07CC:  MOVWF  00
07CE:  RLCF   00,F
07D0:  RLCF   00,F
07D2:  MOVLW  C0
07D4:  ANDWF  00,F
07D6:  MOVF   00,W
07D8:  IORWF  xF0,F
07DA:  SWAPF  xE9,W
07DC:  MOVWF  00
07DE:  RLCF   00,F
07E0:  MOVLW  E0
07E2:  ANDWF  00,F
07E4:  MOVF   00,W
07E6:  IORWF  xF0,F
07E8:  SWAPF  xEA,W
07EA:  MOVWF  00
07EC:  MOVLW  F0
07EE:  ANDWF  00,F
07F0:  MOVF   00,W
07F2:  IORWF  xF0,F
07F4:  RLCF   xEB,W
07F6:  MOVWF  00
07F8:  RLCF   00,F
07FA:  RLCF   00,F
07FC:  MOVLW  F8
07FE:  ANDWF  00,F
0800:  MOVF   00,W
0802:  IORWF  xF0,F
0804:  RLCF   xEC,W
0806:  MOVWF  00
0808:  RLCF   00,F
080A:  MOVLW  FC
080C:  ANDWF  00,F
080E:  MOVF   00,W
0810:  IORWF  xF0,F
0812:  BCF    FD8.0
0814:  RLCF   xED,W
0816:  IORWF  xF0,F
0818:  MOVF   xEE,W
081A:  IORWF  xF0,W
081C:  MOVWF  xEF
....................    return temp; 
081E:  MOVFF  AEF,01
0822:  MOVLB  0
0824:  RETURN 0
.................... } 
.................... //========================= 
.................... int8 check_lrc_T1(int8 direct,int16 offset,int8 *datain) 
0826:  MOVLB  A
0828:  CLRF   xD7
.................... { 
....................    int8 temp=0; 
....................    if(direct==0) 
082A:  MOVF   xD2,F
082C:  BNZ   0902
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]^datain[offset+4]^datain[offset+5]); 
082E:  MOVF   xD5,W
0830:  ADDWF  xD3,W
0832:  MOVWF  FE9
0834:  MOVF   xD6,W
0836:  ADDWFC xD4,W
0838:  MOVWF  FEA
083A:  MOVFF  FEF,AD8
083E:  MOVLW  01
0840:  ADDWF  xD3,W
0842:  MOVWF  xD9
0844:  MOVLW  00
0846:  ADDWFC xD4,W
0848:  MOVWF  xDA
084A:  MOVF   xD5,W
084C:  ADDWF  xD9,W
084E:  MOVWF  FE9
0850:  MOVF   xD6,W
0852:  ADDWFC xDA,W
0854:  MOVWF  FEA
0856:  MOVF   FEF,W
0858:  XORWF  xD8,F
085A:  MOVLW  02
085C:  ADDWF  xD3,W
085E:  MOVWF  xDB
0860:  MOVLW  00
0862:  ADDWFC xD4,W
0864:  MOVWF  xDC
0866:  MOVF   xD5,W
0868:  ADDWF  xDB,W
086A:  MOVWF  FE9
086C:  MOVF   xD6,W
086E:  ADDWFC xDC,W
0870:  MOVWF  FEA
0872:  MOVF   FEF,W
0874:  XORWF  xD8,F
0876:  MOVLW  03
0878:  ADDWF  xD3,W
087A:  MOVWF  xDD
087C:  MOVLW  00
087E:  ADDWFC xD4,W
0880:  MOVWF  xDE
0882:  MOVF   xD5,W
0884:  ADDWF  xDD,W
0886:  MOVWF  FE9
0888:  MOVF   xD6,W
088A:  ADDWFC xDE,W
088C:  MOVWF  FEA
088E:  MOVF   FEF,W
0890:  XORWF  xD8,F
0892:  MOVLW  04
0894:  ADDWF  xD3,W
0896:  MOVWF  xDF
0898:  MOVLW  00
089A:  ADDWFC xD4,W
089C:  MOVWF  xE0
089E:  MOVF   xD5,W
08A0:  ADDWF  xDF,W
08A2:  MOVWF  FE9
08A4:  MOVF   xD6,W
08A6:  ADDWFC xE0,W
08A8:  MOVWF  FEA
08AA:  MOVF   FEF,W
08AC:  XORWF  xD8,F
08AE:  MOVLW  05
08B0:  ADDWF  xD3,W
08B2:  MOVWF  xE1
08B4:  MOVLW  00
08B6:  ADDWFC xD4,W
08B8:  MOVWF  xE2
08BA:  MOVF   xD5,W
08BC:  ADDWF  xE1,W
08BE:  MOVWF  FE9
08C0:  MOVF   xD6,W
08C2:  ADDWFC xE2,W
08C4:  MOVWF  FEA
08C6:  MOVF   FEF,W
08C8:  XORWF  xD8,W
08CA:  BZ    08D0
08CC:  MOVLW  00
08CE:  BRA    08D2
08D0:  MOVLW  01
08D2:  MOVWF  xD7
....................       if(temp==datain[offset+6]) return 1; 
08D4:  MOVLW  06
08D6:  ADDWF  xD3,W
08D8:  MOVWF  xD8
08DA:  MOVLW  00
08DC:  ADDWFC xD4,W
08DE:  MOVWF  xD9
08E0:  MOVF   xD5,W
08E2:  ADDWF  xD8,W
08E4:  MOVWF  FE9
08E6:  MOVF   xD6,W
08E8:  ADDWFC xD9,W
08EA:  MOVWF  FEA
08EC:  MOVF   FEF,W
08EE:  SUBWF  xD7,W
08F0:  BNZ   08FA
08F2:  MOVLW  01
08F4:  MOVWF  01
08F6:  BRA    09D2
08F8:  BRA    0900
....................          else return 0; 
08FA:  MOVLW  00
08FC:  MOVWF  01
08FE:  BRA    09D2
....................    } 
0900:  BRA    09D2
....................       else  
....................       { 
....................          temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]^datain[offset-4]^datain[offset-5]); 
0902:  MOVF   xD5,W
0904:  ADDWF  xD3,W
0906:  MOVWF  FE9
0908:  MOVF   xD6,W
090A:  ADDWFC xD4,W
090C:  MOVWF  FEA
090E:  MOVFF  FEF,AD8
0912:  MOVLW  01
0914:  SUBWF  xD3,W
0916:  MOVWF  xD9
0918:  MOVLW  00
091A:  SUBWFB xD4,W
091C:  MOVWF  xDA
091E:  MOVF   xD5,W
0920:  ADDWF  xD9,W
0922:  MOVWF  FE9
0924:  MOVF   xD6,W
0926:  ADDWFC xDA,W
0928:  MOVWF  FEA
092A:  MOVF   FEF,W
092C:  XORWF  xD8,F
092E:  MOVLW  02
0930:  SUBWF  xD3,W
0932:  MOVWF  xDB
0934:  MOVLW  00
0936:  SUBWFB xD4,W
0938:  MOVWF  xDC
093A:  MOVF   xD5,W
093C:  ADDWF  xDB,W
093E:  MOVWF  FE9
0940:  MOVF   xD6,W
0942:  ADDWFC xDC,W
0944:  MOVWF  FEA
0946:  MOVF   FEF,W
0948:  XORWF  xD8,F
094A:  MOVLW  03
094C:  SUBWF  xD3,W
094E:  MOVWF  xDD
0950:  MOVLW  00
0952:  SUBWFB xD4,W
0954:  MOVWF  xDE
0956:  MOVF   xD5,W
0958:  ADDWF  xDD,W
095A:  MOVWF  FE9
095C:  MOVF   xD6,W
095E:  ADDWFC xDE,W
0960:  MOVWF  FEA
0962:  MOVF   FEF,W
0964:  XORWF  xD8,F
0966:  MOVLW  04
0968:  SUBWF  xD3,W
096A:  MOVWF  xDF
096C:  MOVLW  00
096E:  SUBWFB xD4,W
0970:  MOVWF  xE0
0972:  MOVF   xD5,W
0974:  ADDWF  xDF,W
0976:  MOVWF  FE9
0978:  MOVF   xD6,W
097A:  ADDWFC xE0,W
097C:  MOVWF  FEA
097E:  MOVF   FEF,W
0980:  XORWF  xD8,F
0982:  MOVLW  05
0984:  SUBWF  xD3,W
0986:  MOVWF  xE1
0988:  MOVLW  00
098A:  SUBWFB xD4,W
098C:  MOVWF  xE2
098E:  MOVF   xD5,W
0990:  ADDWF  xE1,W
0992:  MOVWF  FE9
0994:  MOVF   xD6,W
0996:  ADDWFC xE2,W
0998:  MOVWF  FEA
099A:  MOVF   FEF,W
099C:  XORWF  xD8,W
099E:  BZ    09A4
09A0:  MOVLW  00
09A2:  BRA    09A6
09A4:  MOVLW  01
09A6:  MOVWF  xD7
....................          if(temp==datain[offset-6]) return 1; 
09A8:  MOVLW  06
09AA:  SUBWF  xD3,W
09AC:  MOVWF  xD8
09AE:  MOVLW  00
09B0:  SUBWFB xD4,W
09B2:  MOVWF  xD9
09B4:  MOVF   xD5,W
09B6:  ADDWF  xD8,W
09B8:  MOVWF  FE9
09BA:  MOVF   xD6,W
09BC:  ADDWFC xD9,W
09BE:  MOVWF  FEA
09C0:  MOVF   FEF,W
09C2:  SUBWF  xD7,W
09C4:  BNZ   09CE
09C6:  MOVLW  01
09C8:  MOVWF  01
09CA:  BRA    09D2
09CC:  BRA    09D2
....................             else return 0;          
09CE:  MOVLW  00
09D0:  MOVWF  01
....................       } 
09D2:  MOVLB  0
09D4:  RETURN 0
.................... } 
.................... //========================= 
.................... int8 check_lrc_T2(int8 direct,int16 offset,int8 *datain) 
09D6:  MOVLB  A
09D8:  CLRF   xD7
.................... { 
....................    int8 temp=0; 
....................    if(direct==0) 
09DA:  MOVF   xD2,F
09DC:  BNZ   0A7A
....................    { 
....................       temp=!(datain[offset]^datain[offset+1]^datain[offset+2]^datain[offset+3]); 
09DE:  MOVF   xD5,W
09E0:  ADDWF  xD3,W
09E2:  MOVWF  FE9
09E4:  MOVF   xD6,W
09E6:  ADDWFC xD4,W
09E8:  MOVWF  FEA
09EA:  MOVFF  FEF,AD8
09EE:  MOVLW  01
09F0:  ADDWF  xD3,W
09F2:  MOVWF  xD9
09F4:  MOVLW  00
09F6:  ADDWFC xD4,W
09F8:  MOVWF  xDA
09FA:  MOVF   xD5,W
09FC:  ADDWF  xD9,W
09FE:  MOVWF  FE9
0A00:  MOVF   xD6,W
0A02:  ADDWFC xDA,W
0A04:  MOVWF  FEA
0A06:  MOVF   FEF,W
0A08:  XORWF  xD8,F
0A0A:  MOVLW  02
0A0C:  ADDWF  xD3,W
0A0E:  MOVWF  xDB
0A10:  MOVLW  00
0A12:  ADDWFC xD4,W
0A14:  MOVWF  xDC
0A16:  MOVF   xD5,W
0A18:  ADDWF  xDB,W
0A1A:  MOVWF  FE9
0A1C:  MOVF   xD6,W
0A1E:  ADDWFC xDC,W
0A20:  MOVWF  FEA
0A22:  MOVF   FEF,W
0A24:  XORWF  xD8,F
0A26:  MOVLW  03
0A28:  ADDWF  xD3,W
0A2A:  MOVWF  xDD
0A2C:  MOVLW  00
0A2E:  ADDWFC xD4,W
0A30:  MOVWF  xDE
0A32:  MOVF   xD5,W
0A34:  ADDWF  xDD,W
0A36:  MOVWF  FE9
0A38:  MOVF   xD6,W
0A3A:  ADDWFC xDE,W
0A3C:  MOVWF  FEA
0A3E:  MOVF   FEF,W
0A40:  XORWF  xD8,W
0A42:  BZ    0A48
0A44:  MOVLW  00
0A46:  BRA    0A4A
0A48:  MOVLW  01
0A4A:  MOVWF  xD7
....................       if(temp==datain[offset+4]) return 1; 
0A4C:  MOVLW  04
0A4E:  ADDWF  xD3,W
0A50:  MOVWF  xD8
0A52:  MOVLW  00
0A54:  ADDWFC xD4,W
0A56:  MOVWF  xD9
0A58:  MOVF   xD5,W
0A5A:  ADDWF  xD8,W
0A5C:  MOVWF  FE9
0A5E:  MOVF   xD6,W
0A60:  ADDWFC xD9,W
0A62:  MOVWF  FEA
0A64:  MOVF   FEF,W
0A66:  SUBWF  xD7,W
0A68:  BNZ   0A72
0A6A:  MOVLW  01
0A6C:  MOVWF  01
0A6E:  BRA    0B12
0A70:  BRA    0A78
....................          else return 0; 
0A72:  MOVLW  00
0A74:  MOVWF  01
0A76:  BRA    0B12
....................    } 
0A78:  BRA    0B12
....................    else 
....................    { 
....................       temp=!(datain[offset]^datain[offset-1]^datain[offset-2]^datain[offset-3]); 
0A7A:  MOVF   xD5,W
0A7C:  ADDWF  xD3,W
0A7E:  MOVWF  FE9
0A80:  MOVF   xD6,W
0A82:  ADDWFC xD4,W
0A84:  MOVWF  FEA
0A86:  MOVFF  FEF,AD8
0A8A:  MOVLW  01
0A8C:  SUBWF  xD3,W
0A8E:  MOVWF  xD9
0A90:  MOVLW  00
0A92:  SUBWFB xD4,W
0A94:  MOVWF  xDA
0A96:  MOVF   xD5,W
0A98:  ADDWF  xD9,W
0A9A:  MOVWF  FE9
0A9C:  MOVF   xD6,W
0A9E:  ADDWFC xDA,W
0AA0:  MOVWF  FEA
0AA2:  MOVF   FEF,W
0AA4:  XORWF  xD8,F
0AA6:  MOVLW  02
0AA8:  SUBWF  xD3,W
0AAA:  MOVWF  xDB
0AAC:  MOVLW  00
0AAE:  SUBWFB xD4,W
0AB0:  MOVWF  xDC
0AB2:  MOVF   xD5,W
0AB4:  ADDWF  xDB,W
0AB6:  MOVWF  FE9
0AB8:  MOVF   xD6,W
0ABA:  ADDWFC xDC,W
0ABC:  MOVWF  FEA
0ABE:  MOVF   FEF,W
0AC0:  XORWF  xD8,F
0AC2:  MOVLW  03
0AC4:  SUBWF  xD3,W
0AC6:  MOVWF  xDD
0AC8:  MOVLW  00
0ACA:  SUBWFB xD4,W
0ACC:  MOVWF  xDE
0ACE:  MOVF   xD5,W
0AD0:  ADDWF  xDD,W
0AD2:  MOVWF  FE9
0AD4:  MOVF   xD6,W
0AD6:  ADDWFC xDE,W
0AD8:  MOVWF  FEA
0ADA:  MOVF   FEF,W
0ADC:  XORWF  xD8,W
0ADE:  BZ    0AE4
0AE0:  MOVLW  00
0AE2:  BRA    0AE6
0AE4:  MOVLW  01
0AE6:  MOVWF  xD7
....................       if(temp==datain[offset-4]) return 1; 
0AE8:  MOVLW  04
0AEA:  SUBWF  xD3,W
0AEC:  MOVWF  xD8
0AEE:  MOVLW  00
0AF0:  SUBWFB xD4,W
0AF2:  MOVWF  xD9
0AF4:  MOVF   xD5,W
0AF6:  ADDWF  xD8,W
0AF8:  MOVWF  FE9
0AFA:  MOVF   xD6,W
0AFC:  ADDWFC xD9,W
0AFE:  MOVWF  FEA
0B00:  MOVF   FEF,W
0B02:  SUBWF  xD7,W
0B04:  BNZ   0B0E
0B06:  MOVLW  01
0B08:  MOVWF  01
0B0A:  BRA    0B12
0B0C:  BRA    0B12
....................          else return 0;                
0B0E:  MOVLW  00
0B10:  MOVWF  01
....................    } 
0B12:  MOVLB  0
0B14:  RETURN 0
.................... } 
.................... //========================= 
.................... int16 detect_pos_st(int8 track,int16 end_point,int8 *datin) 
0B16:  MOVLB  A
0B18:  CLRF   xCE
0B1A:  CLRF   xCF
0B1C:  CLRF   xD0
0B1E:  CLRF   xD1
.................... { 
....................    int16 i,j; 
....................    int8 temp=0,temp1=0,temp2=0; 
....................    unsigned int8 CRC=0; 
....................    for(i=0;i<end_point/4;i++) 
0B20:  CLRF   xCB
0B22:  CLRF   xCA
0B24:  RRCF   xC7,W
0B26:  MOVWF  03
0B28:  RRCF   xC6,W
0B2A:  MOVWF  02
0B2C:  RRCF   03,F
0B2E:  RRCF   02,F
0B30:  MOVLW  3F
0B32:  ANDWF  03,F
0B34:  MOVFF  02,01
0B38:  MOVF   xCB,W
0B3A:  SUBWF  03,W
0B3C:  BTFSS  FD8.0
0B3E:  BRA    10FE
0B40:  BNZ   0B4A
0B42:  MOVF   01,W
0B44:  SUBWF  xCA,W
0B46:  BTFSC  FD8.0
0B48:  BRA    10FE
....................    { 
....................       if(track==0) 
0B4A:  MOVF   xC5,F
0B4C:  BTFSS  FD8.2
0B4E:  BRA    0E84
....................       { 
....................          temp = makebyte(0,datin[i+6],datin[i+5],datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0B50:  MOVLW  06
0B52:  ADDWF  xCA,W
0B54:  MOVWF  xD2
0B56:  MOVLW  00
0B58:  ADDWFC xCB,W
0B5A:  MOVWF  xD3
0B5C:  MOVF   xC8,W
0B5E:  ADDWF  xD2,W
0B60:  MOVWF  FE9
0B62:  MOVF   xC9,W
0B64:  ADDWFC xD3,W
0B66:  MOVWF  FEA
0B68:  MOVFF  FEF,AD4
0B6C:  MOVLW  05
0B6E:  ADDWF  xCA,W
0B70:  MOVWF  xD5
0B72:  MOVLW  00
0B74:  ADDWFC xCB,W
0B76:  MOVWF  xD6
0B78:  MOVF   xC8,W
0B7A:  ADDWF  xD5,W
0B7C:  MOVWF  FE9
0B7E:  MOVF   xC9,W
0B80:  ADDWFC xD6,W
0B82:  MOVWF  FEA
0B84:  MOVFF  FEF,AD7
0B88:  MOVLW  04
0B8A:  ADDWF  xCA,W
0B8C:  MOVWF  xD8
0B8E:  MOVLW  00
0B90:  ADDWFC xCB,W
0B92:  MOVWF  xD9
0B94:  MOVF   xC8,W
0B96:  ADDWF  xD8,W
0B98:  MOVWF  FE9
0B9A:  MOVF   xC9,W
0B9C:  ADDWFC xD9,W
0B9E:  MOVWF  FEA
0BA0:  MOVFF  FEF,ADA
0BA4:  MOVLW  03
0BA6:  ADDWF  xCA,W
0BA8:  MOVWF  xDB
0BAA:  MOVLW  00
0BAC:  ADDWFC xCB,W
0BAE:  MOVWF  xDC
0BB0:  MOVF   xC8,W
0BB2:  ADDWF  xDB,W
0BB4:  MOVWF  FE9
0BB6:  MOVF   xC9,W
0BB8:  ADDWFC xDC,W
0BBA:  MOVWF  FEA
0BBC:  MOVFF  FEF,ADD
0BC0:  MOVLW  02
0BC2:  ADDWF  xCA,W
0BC4:  MOVWF  xDE
0BC6:  MOVLW  00
0BC8:  ADDWFC xCB,W
0BCA:  MOVWF  xDF
0BCC:  MOVF   xC8,W
0BCE:  ADDWF  xDE,W
0BD0:  MOVWF  FE9
0BD2:  MOVF   xC9,W
0BD4:  ADDWFC xDF,W
0BD6:  MOVWF  FEA
0BD8:  MOVFF  FEF,AE0
0BDC:  MOVLW  01
0BDE:  ADDWF  xCA,W
0BE0:  MOVWF  xE1
0BE2:  MOVLW  00
0BE4:  ADDWFC xCB,W
0BE6:  MOVWF  xE2
0BE8:  MOVF   xC8,W
0BEA:  ADDWF  xE1,W
0BEC:  MOVWF  FE9
0BEE:  MOVF   xC9,W
0BF0:  ADDWFC xE2,W
0BF2:  MOVWF  FEA
0BF4:  MOVFF  FEF,AE3
0BF8:  MOVF   xC8,W
0BFA:  ADDWF  xCA,W
0BFC:  MOVWF  FE9
0BFE:  MOVF   xC9,W
0C00:  ADDWFC xCB,W
0C02:  MOVWF  FEA
0C04:  MOVFF  FEF,AE4
0C08:  CLRF   xE7
0C0A:  MOVFF  AD4,AE8
0C0E:  MOVFF  AD7,AE9
0C12:  MOVFF  ADA,AEA
0C16:  MOVFF  ADD,AEB
0C1A:  MOVFF  AE0,AEC
0C1E:  MOVFF  AE3,AED
0C22:  MOVFF  AE4,AEE
0C26:  MOVLB  0
0C28:  RCALL  07C0
0C2A:  MOVFF  01,ACE
....................          temp1= makebyte(0,datin[i+13],datin[i+12],datin[i+11],datin[i+10],datin[i+9],datin[i+8],datin[i+7]); 
0C2E:  MOVLW  0D
0C30:  MOVLB  A
0C32:  ADDWF  xCA,W
0C34:  MOVWF  xD2
0C36:  MOVLW  00
0C38:  ADDWFC xCB,W
0C3A:  MOVWF  xD3
0C3C:  MOVF   xC8,W
0C3E:  ADDWF  xD2,W
0C40:  MOVWF  FE9
0C42:  MOVF   xC9,W
0C44:  ADDWFC xD3,W
0C46:  MOVWF  FEA
0C48:  MOVFF  FEF,AD4
0C4C:  MOVLW  0C
0C4E:  ADDWF  xCA,W
0C50:  MOVWF  xD5
0C52:  MOVLW  00
0C54:  ADDWFC xCB,W
0C56:  MOVWF  xD6
0C58:  MOVF   xC8,W
0C5A:  ADDWF  xD5,W
0C5C:  MOVWF  FE9
0C5E:  MOVF   xC9,W
0C60:  ADDWFC xD6,W
0C62:  MOVWF  FEA
0C64:  MOVFF  FEF,AD7
0C68:  MOVLW  0B
0C6A:  ADDWF  xCA,W
0C6C:  MOVWF  xD8
0C6E:  MOVLW  00
0C70:  ADDWFC xCB,W
0C72:  MOVWF  xD9
0C74:  MOVF   xC8,W
0C76:  ADDWF  xD8,W
0C78:  MOVWF  FE9
0C7A:  MOVF   xC9,W
0C7C:  ADDWFC xD9,W
0C7E:  MOVWF  FEA
0C80:  MOVFF  FEF,ADA
0C84:  MOVLW  0A
0C86:  ADDWF  xCA,W
0C88:  MOVWF  xDB
0C8A:  MOVLW  00
0C8C:  ADDWFC xCB,W
0C8E:  MOVWF  xDC
0C90:  MOVF   xC8,W
0C92:  ADDWF  xDB,W
0C94:  MOVWF  FE9
0C96:  MOVF   xC9,W
0C98:  ADDWFC xDC,W
0C9A:  MOVWF  FEA
0C9C:  MOVFF  FEF,ADD
0CA0:  MOVLW  09
0CA2:  ADDWF  xCA,W
0CA4:  MOVWF  xDE
0CA6:  MOVLW  00
0CA8:  ADDWFC xCB,W
0CAA:  MOVWF  xDF
0CAC:  MOVF   xC8,W
0CAE:  ADDWF  xDE,W
0CB0:  MOVWF  FE9
0CB2:  MOVF   xC9,W
0CB4:  ADDWFC xDF,W
0CB6:  MOVWF  FEA
0CB8:  MOVFF  FEF,AE0
0CBC:  MOVLW  08
0CBE:  ADDWF  xCA,W
0CC0:  MOVWF  xE1
0CC2:  MOVLW  00
0CC4:  ADDWFC xCB,W
0CC6:  MOVWF  xE2
0CC8:  MOVF   xC8,W
0CCA:  ADDWF  xE1,W
0CCC:  MOVWF  FE9
0CCE:  MOVF   xC9,W
0CD0:  ADDWFC xE2,W
0CD2:  MOVWF  FEA
0CD4:  MOVFF  FEF,AE3
0CD8:  MOVLW  07
0CDA:  ADDWF  xCA,W
0CDC:  MOVWF  xE4
0CDE:  MOVLW  00
0CE0:  ADDWFC xCB,W
0CE2:  MOVWF  xE5
0CE4:  MOVF   xC8,W
0CE6:  ADDWF  xE4,W
0CE8:  MOVWF  FE9
0CEA:  MOVF   xC9,W
0CEC:  ADDWFC xE5,W
0CEE:  MOVWF  FEA
0CF0:  MOVFF  FEF,AE6
0CF4:  CLRF   xE7
0CF6:  MOVFF  AD4,AE8
0CFA:  MOVFF  AD7,AE9
0CFE:  MOVFF  ADA,AEA
0D02:  MOVFF  ADD,AEB
0D06:  MOVFF  AE0,AEC
0D0A:  MOVFF  AE3,AED
0D0E:  MOVFF  AE6,AEE
0D12:  MOVLB  0
0D14:  RCALL  07C0
0D16:  MOVFF  01,ACF
....................          /*CRC = !(datin[i+19]^datin[i+18]^datin[i+17]^datin[i+16]^datin[i+15]^datin[i+14]); 
....................          if(datin[i+20]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111))//(temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111) 
0D1A:  MOVLB  A
0D1C:  MOVF   xCE,W
0D1E:  SUBLW  45
0D20:  BTFSS  FD8.2
0D22:  BRA    0E82
0D24:  MOVF   xCF,W
0D26:  SUBLW  7C
0D28:  BTFSC  FD8.2
0D2A:  BRA    0E82
0D2C:  MOVF   xCF,W
0D2E:  SUBLW  3E
0D30:  BTFSC  FD8.2
0D32:  BRA    0E82
0D34:  MOVF   xCF,W
0D36:  SUBLW  1F
0D38:  BTFSC  FD8.2
0D3A:  BRA    0E82
....................          { 
....................             j=i; 
0D3C:  MOVFF  ACB,ACD
0D40:  MOVFF  ACA,ACC
....................             CRC=1; 
0D44:  MOVLW  01
0D46:  MOVWF  xD1
....................             temp2=temp; 
0D48:  MOVFF  ACE,AD0
....................             //fprintf(COM2,"temp,j=%d,%lu\r\n",temp,j); 
....................             while((temp2!=0b00011111)&&(j<1000)) 
0D4C:  MOVF   xD0,W
0D4E:  SUBLW  1F
0D50:  BTFSC  FD8.2
0D52:  BRA    0E6C
0D54:  MOVF   xCD,W
0D56:  SUBLW  03
0D58:  BTFSS  FD8.0
0D5A:  BRA    0E6C
0D5C:  BNZ   0D66
0D5E:  MOVF   xCC,W
0D60:  SUBLW  E7
0D62:  BTFSS  FD8.0
0D64:  BRA    0E6C
....................             { 
....................                //CRC=CRC^temp2; 
....................                CRC=check_lrc_T1(0,j,datin)&CRC; 
0D66:  CLRF   xD2
0D68:  MOVFF  ACD,AD4
0D6C:  MOVFF  ACC,AD3
0D70:  MOVFF  AC9,AD6
0D74:  MOVFF  AC8,AD5
0D78:  MOVLB  0
0D7A:  RCALL  0826
0D7C:  MOVF   01,W
0D7E:  MOVLB  A
0D80:  ANDWF  xD1,F
....................                temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
0D82:  MOVLW  06
0D84:  ADDWF  xCC,W
0D86:  MOVWF  xD2
0D88:  MOVLW  00
0D8A:  ADDWFC xCD,W
0D8C:  MOVWF  xD3
0D8E:  MOVF   xC8,W
0D90:  ADDWF  xD2,W
0D92:  MOVWF  FE9
0D94:  MOVF   xC9,W
0D96:  ADDWFC xD3,W
0D98:  MOVWF  FEA
0D9A:  MOVFF  FEF,AD4
0D9E:  MOVLW  05
0DA0:  ADDWF  xCC,W
0DA2:  MOVWF  xD5
0DA4:  MOVLW  00
0DA6:  ADDWFC xCD,W
0DA8:  MOVWF  xD6
0DAA:  MOVF   xC8,W
0DAC:  ADDWF  xD5,W
0DAE:  MOVWF  FE9
0DB0:  MOVF   xC9,W
0DB2:  ADDWFC xD6,W
0DB4:  MOVWF  FEA
0DB6:  MOVFF  FEF,AD7
0DBA:  MOVLW  04
0DBC:  ADDWF  xCC,W
0DBE:  MOVWF  xD8
0DC0:  MOVLW  00
0DC2:  ADDWFC xCD,W
0DC4:  MOVWF  xD9
0DC6:  MOVF   xC8,W
0DC8:  ADDWF  xD8,W
0DCA:  MOVWF  FE9
0DCC:  MOVF   xC9,W
0DCE:  ADDWFC xD9,W
0DD0:  MOVWF  FEA
0DD2:  MOVFF  FEF,ADA
0DD6:  MOVLW  03
0DD8:  ADDWF  xCC,W
0DDA:  MOVWF  xDB
0DDC:  MOVLW  00
0DDE:  ADDWFC xCD,W
0DE0:  MOVWF  xDC
0DE2:  MOVF   xC8,W
0DE4:  ADDWF  xDB,W
0DE6:  MOVWF  FE9
0DE8:  MOVF   xC9,W
0DEA:  ADDWFC xDC,W
0DEC:  MOVWF  FEA
0DEE:  MOVFF  FEF,ADD
0DF2:  MOVLW  02
0DF4:  ADDWF  xCC,W
0DF6:  MOVWF  xDE
0DF8:  MOVLW  00
0DFA:  ADDWFC xCD,W
0DFC:  MOVWF  xDF
0DFE:  MOVF   xC8,W
0E00:  ADDWF  xDE,W
0E02:  MOVWF  FE9
0E04:  MOVF   xC9,W
0E06:  ADDWFC xDF,W
0E08:  MOVWF  FEA
0E0A:  MOVFF  FEF,AE0
0E0E:  MOVLW  01
0E10:  ADDWF  xCC,W
0E12:  MOVWF  xE1
0E14:  MOVLW  00
0E16:  ADDWFC xCD,W
0E18:  MOVWF  xE2
0E1A:  MOVF   xC8,W
0E1C:  ADDWF  xE1,W
0E1E:  MOVWF  FE9
0E20:  MOVF   xC9,W
0E22:  ADDWFC xE2,W
0E24:  MOVWF  FEA
0E26:  MOVFF  FEF,AE3
0E2A:  MOVF   xC8,W
0E2C:  ADDWF  xCC,W
0E2E:  MOVWF  FE9
0E30:  MOVF   xC9,W
0E32:  ADDWFC xCD,W
0E34:  MOVWF  FEA
0E36:  MOVFF  FEF,AE4
0E3A:  CLRF   xE7
0E3C:  MOVFF  AD4,AE8
0E40:  MOVFF  AD7,AE9
0E44:  MOVFF  ADA,AEA
0E48:  MOVFF  ADD,AEB
0E4C:  MOVFF  AE0,AEC
0E50:  MOVFF  AE3,AED
0E54:  MOVFF  AE4,AEE
0E58:  MOVLB  0
0E5A:  RCALL  07C0
0E5C:  MOVFF  01,AD0
....................                j=j+7; 
0E60:  MOVLW  07
0E62:  MOVLB  A
0E64:  ADDWF  xCC,F
0E66:  MOVLW  00
0E68:  ADDWFC xCD,F
0E6A:  BRA    0D4C
....................             } 
....................             //fprintf(COM2,"CRC,j=%d,%lu\r\n",CRC,j); 
....................             //CRC=CRC^temp2; 
....................             //j=j-7; 
....................             //j=j+7; 
....................             //temp2 = makebyte(0,datin[j+6],datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
....................             //fprintf(COM2,"CRC=%d,%d\r\n",CRC,temp2);  
....................             if(CRC==1) 
0E6C:  DECFSZ xD1,W
0E6E:  BRA    0E82
....................             { 
....................                dir=0; 
0E70:  MOVLB  9
0E72:  CLRF   x99
....................                return i; 
0E74:  MOVLB  A
0E76:  MOVFF  ACA,01
0E7A:  MOVFF  ACB,02
0E7E:  GOTO   1714
....................             } 
....................             //else return 0; 
....................          } 
....................          //check_crc=1; 
....................          //fprintf(COM2,"%d\r\n",check_crc);    
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................             dir=0; 
....................             return i; 
....................          }*/ 
....................       } 
0E82:  BRA    10F6
....................          else  
....................          { 
....................             temp = makebyte(0,0,0,datin[i+4],datin[i+3],datin[i+2],datin[i+1],datin[i]); 
0E84:  MOVLW  04
0E86:  ADDWF  xCA,W
0E88:  MOVWF  xD2
0E8A:  MOVLW  00
0E8C:  ADDWFC xCB,W
0E8E:  MOVWF  xD3
0E90:  MOVF   xC8,W
0E92:  ADDWF  xD2,W
0E94:  MOVWF  FE9
0E96:  MOVF   xC9,W
0E98:  ADDWFC xD3,W
0E9A:  MOVWF  FEA
0E9C:  MOVFF  FEF,AD4
0EA0:  MOVLW  03
0EA2:  ADDWF  xCA,W
0EA4:  MOVWF  xD5
0EA6:  MOVLW  00
0EA8:  ADDWFC xCB,W
0EAA:  MOVWF  xD6
0EAC:  MOVF   xC8,W
0EAE:  ADDWF  xD5,W
0EB0:  MOVWF  FE9
0EB2:  MOVF   xC9,W
0EB4:  ADDWFC xD6,W
0EB6:  MOVWF  FEA
0EB8:  MOVFF  FEF,AD7
0EBC:  MOVLW  02
0EBE:  ADDWF  xCA,W
0EC0:  MOVWF  xD8
0EC2:  MOVLW  00
0EC4:  ADDWFC xCB,W
0EC6:  MOVWF  xD9
0EC8:  MOVF   xC8,W
0ECA:  ADDWF  xD8,W
0ECC:  MOVWF  FE9
0ECE:  MOVF   xC9,W
0ED0:  ADDWFC xD9,W
0ED2:  MOVWF  FEA
0ED4:  MOVFF  FEF,ADA
0ED8:  MOVLW  01
0EDA:  ADDWF  xCA,W
0EDC:  MOVWF  xDB
0EDE:  MOVLW  00
0EE0:  ADDWFC xCB,W
0EE2:  MOVWF  xDC
0EE4:  MOVF   xC8,W
0EE6:  ADDWF  xDB,W
0EE8:  MOVWF  FE9
0EEA:  MOVF   xC9,W
0EEC:  ADDWFC xDC,W
0EEE:  MOVWF  FEA
0EF0:  MOVFF  FEF,ADD
0EF4:  MOVF   xC8,W
0EF6:  ADDWF  xCA,W
0EF8:  MOVWF  FE9
0EFA:  MOVF   xC9,W
0EFC:  ADDWFC xCB,W
0EFE:  MOVWF  FEA
0F00:  MOVFF  FEF,ADE
0F04:  CLRF   xE7
0F06:  CLRF   xE8
0F08:  CLRF   xE9
0F0A:  MOVFF  AD4,AEA
0F0E:  MOVFF  AD7,AEB
0F12:  MOVFF  ADA,AEC
0F16:  MOVFF  ADD,AED
0F1A:  MOVFF  ADE,AEE
0F1E:  MOVLB  0
0F20:  RCALL  07C0
0F22:  MOVFF  01,ACE
....................             temp1= makebyte(0,0,0,datin[i+9],datin[i+8],datin[i+7],datin[i+6],datin[i+5]);  
0F26:  MOVLW  09
0F28:  MOVLB  A
0F2A:  ADDWF  xCA,W
0F2C:  MOVWF  xD2
0F2E:  MOVLW  00
0F30:  ADDWFC xCB,W
0F32:  MOVWF  xD3
0F34:  MOVF   xC8,W
0F36:  ADDWF  xD2,W
0F38:  MOVWF  FE9
0F3A:  MOVF   xC9,W
0F3C:  ADDWFC xD3,W
0F3E:  MOVWF  FEA
0F40:  MOVFF  FEF,AD4
0F44:  MOVLW  08
0F46:  ADDWF  xCA,W
0F48:  MOVWF  xD5
0F4A:  MOVLW  00
0F4C:  ADDWFC xCB,W
0F4E:  MOVWF  xD6
0F50:  MOVF   xC8,W
0F52:  ADDWF  xD5,W
0F54:  MOVWF  FE9
0F56:  MOVF   xC9,W
0F58:  ADDWFC xD6,W
0F5A:  MOVWF  FEA
0F5C:  MOVFF  FEF,AD7
0F60:  MOVLW  07
0F62:  ADDWF  xCA,W
0F64:  MOVWF  xD8
0F66:  MOVLW  00
0F68:  ADDWFC xCB,W
0F6A:  MOVWF  xD9
0F6C:  MOVF   xC8,W
0F6E:  ADDWF  xD8,W
0F70:  MOVWF  FE9
0F72:  MOVF   xC9,W
0F74:  ADDWFC xD9,W
0F76:  MOVWF  FEA
0F78:  MOVFF  FEF,ADA
0F7C:  MOVLW  06
0F7E:  ADDWF  xCA,W
0F80:  MOVWF  xDB
0F82:  MOVLW  00
0F84:  ADDWFC xCB,W
0F86:  MOVWF  xDC
0F88:  MOVF   xC8,W
0F8A:  ADDWF  xDB,W
0F8C:  MOVWF  FE9
0F8E:  MOVF   xC9,W
0F90:  ADDWFC xDC,W
0F92:  MOVWF  FEA
0F94:  MOVFF  FEF,ADD
0F98:  MOVLW  05
0F9A:  ADDWF  xCA,W
0F9C:  MOVWF  xDE
0F9E:  MOVLW  00
0FA0:  ADDWFC xCB,W
0FA2:  MOVWF  xDF
0FA4:  MOVF   xC8,W
0FA6:  ADDWF  xDE,W
0FA8:  MOVWF  FE9
0FAA:  MOVF   xC9,W
0FAC:  ADDWFC xDF,W
0FAE:  MOVWF  FEA
0FB0:  MOVFF  FEF,AE0
0FB4:  CLRF   xE7
0FB6:  CLRF   xE8
0FB8:  CLRF   xE9
0FBA:  MOVFF  AD4,AEA
0FBE:  MOVFF  AD7,AEB
0FC2:  MOVFF  ADA,AEC
0FC6:  MOVFF  ADD,AED
0FCA:  MOVFF  AE0,AEE
0FCE:  MOVLB  0
0FD0:  CALL   07C0
0FD4:  MOVFF  01,ACF
....................             //CRC=!(datin[i+13]^datin[i+12]^datin[i+11]^datin[i+10]); 
....................             /*if(datin[i+14]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................            // fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111))//(temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111) 
0FD8:  MOVLB  A
0FDA:  MOVF   xCE,W
0FDC:  SUBLW  0B
0FDE:  BTFSS  FD8.2
0FE0:  BRA    10F6
0FE2:  MOVF   xCF,W
0FE4:  SUBLW  1F
0FE6:  BTFSC  FD8.2
0FE8:  BRA    10F6
0FEA:  MOVF   xCF,W
0FEC:  SUBLW  0F
0FEE:  BTFSC  FD8.2
0FF0:  BRA    10F6
....................             { 
....................                j=i; 
0FF2:  MOVFF  ACB,ACD
0FF6:  MOVFF  ACA,ACC
....................                CRC=1; 
0FFA:  MOVLW  01
0FFC:  MOVWF  xD1
....................                temp2=temp; 
0FFE:  MOVFF  ACE,AD0
....................                while((temp2!=0b00011111)&&(j<500)) 
1002:  MOVF   xD0,W
1004:  SUBLW  1F
1006:  BZ    10E2
1008:  MOVF   xCD,W
100A:  SUBLW  01
100C:  BNC   10E2
100E:  BNZ   1016
1010:  MOVF   xCC,W
1012:  SUBLW  F3
1014:  BNC   10E2
....................                { 
....................                   CRC=check_lrc_T2(0,j,datin)&CRC; 
1016:  CLRF   xD2
1018:  MOVFF  ACD,AD4
101C:  MOVFF  ACC,AD3
1020:  MOVFF  AC9,AD6
1024:  MOVFF  AC8,AD5
1028:  MOVLB  0
102A:  RCALL  09D6
102C:  MOVF   01,W
102E:  MOVLB  A
1030:  ANDWF  xD1,F
....................                   temp2=makebyte(0,0,0,datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
1032:  MOVLW  04
1034:  ADDWF  xCC,W
1036:  MOVWF  xD2
1038:  MOVLW  00
103A:  ADDWFC xCD,W
103C:  MOVWF  xD3
103E:  MOVF   xC8,W
1040:  ADDWF  xD2,W
1042:  MOVWF  FE9
1044:  MOVF   xC9,W
1046:  ADDWFC xD3,W
1048:  MOVWF  FEA
104A:  MOVFF  FEF,AD4
104E:  MOVLW  03
1050:  ADDWF  xCC,W
1052:  MOVWF  xD5
1054:  MOVLW  00
1056:  ADDWFC xCD,W
1058:  MOVWF  xD6
105A:  MOVF   xC8,W
105C:  ADDWF  xD5,W
105E:  MOVWF  FE9
1060:  MOVF   xC9,W
1062:  ADDWFC xD6,W
1064:  MOVWF  FEA
1066:  MOVFF  FEF,AD7
106A:  MOVLW  02
106C:  ADDWF  xCC,W
106E:  MOVWF  xD8
1070:  MOVLW  00
1072:  ADDWFC xCD,W
1074:  MOVWF  xD9
1076:  MOVF   xC8,W
1078:  ADDWF  xD8,W
107A:  MOVWF  FE9
107C:  MOVF   xC9,W
107E:  ADDWFC xD9,W
1080:  MOVWF  FEA
1082:  MOVFF  FEF,ADA
1086:  MOVLW  01
1088:  ADDWF  xCC,W
108A:  MOVWF  xDB
108C:  MOVLW  00
108E:  ADDWFC xCD,W
1090:  MOVWF  xDC
1092:  MOVF   xC8,W
1094:  ADDWF  xDB,W
1096:  MOVWF  FE9
1098:  MOVF   xC9,W
109A:  ADDWFC xDC,W
109C:  MOVWF  FEA
109E:  MOVFF  FEF,ADD
10A2:  MOVF   xC8,W
10A4:  ADDWF  xCC,W
10A6:  MOVWF  FE9
10A8:  MOVF   xC9,W
10AA:  ADDWFC xCD,W
10AC:  MOVWF  FEA
10AE:  MOVFF  FEF,ADE
10B2:  CLRF   xE7
10B4:  CLRF   xE8
10B6:  CLRF   xE9
10B8:  MOVFF  AD4,AEA
10BC:  MOVFF  AD7,AEB
10C0:  MOVFF  ADA,AEC
10C4:  MOVFF  ADD,AED
10C8:  MOVFF  ADE,AEE
10CC:  MOVLB  0
10CE:  CALL   07C0
10D2:  MOVFF  01,AD0
....................                   j=j+5; 
10D6:  MOVLW  05
10D8:  MOVLB  A
10DA:  ADDWF  xCC,F
10DC:  MOVLW  00
10DE:  ADDWFC xCD,F
10E0:  BRA    1002
....................                } 
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
10E2:  DECFSZ xD1,W
10E4:  BRA    10F6
....................                { 
....................                   dir=0; 
10E6:  MOVLB  9
10E8:  CLRF   x99
....................                   return i; 
10EA:  MOVLB  A
10EC:  MOVFF  ACA,01
10F0:  MOVFF  ACB,02
10F4:  BRA    1714
....................                } 
....................                   //else return 0; 
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",0,i); 
....................                dir=0; 
....................                return i; 
....................             }  */           
....................          } 
10F6:  INCF   xCA,F
10F8:  BTFSC  FD8.2
10FA:  INCF   xCB,F
10FC:  BRA    0B24
....................    } 
....................    for(i=end_point;i>end_point/4;i--) 
10FE:  MOVFF  AC7,ACB
1102:  MOVFF  AC6,ACA
1106:  RRCF   xC7,W
1108:  MOVWF  03
110A:  RRCF   xC6,W
110C:  MOVWF  02
110E:  RRCF   03,F
1110:  RRCF   02,F
1112:  MOVLW  3F
1114:  ANDWF  03,F
1116:  MOVFF  02,01
111A:  MOVF   03,W
111C:  SUBWF  xCB,W
111E:  BTFSS  FD8.0
1120:  BRA    170E
1122:  BNZ   112C
1124:  MOVF   xCA,W
1126:  SUBWF  01,W
1128:  BTFSC  FD8.0
112A:  BRA    170E
....................    { 
....................       if(track==0) 
112C:  MOVF   xC5,F
112E:  BTFSS  FD8.2
1130:  BRA    1484
....................       { 
....................          temp = makebyte(0,datin[i-6],datin[i-5],datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
1132:  MOVLW  06
1134:  SUBWF  xCA,W
1136:  MOVWF  xD2
1138:  MOVLW  00
113A:  SUBWFB xCB,W
113C:  MOVWF  xD3
113E:  MOVF   xC8,W
1140:  ADDWF  xD2,W
1142:  MOVWF  FE9
1144:  MOVF   xC9,W
1146:  ADDWFC xD3,W
1148:  MOVWF  FEA
114A:  MOVFF  FEF,AD4
114E:  MOVLW  05
1150:  SUBWF  xCA,W
1152:  MOVWF  xD5
1154:  MOVLW  00
1156:  SUBWFB xCB,W
1158:  MOVWF  xD6
115A:  MOVF   xC8,W
115C:  ADDWF  xD5,W
115E:  MOVWF  FE9
1160:  MOVF   xC9,W
1162:  ADDWFC xD6,W
1164:  MOVWF  FEA
1166:  MOVFF  FEF,AD7
116A:  MOVLW  04
116C:  SUBWF  xCA,W
116E:  MOVWF  xD8
1170:  MOVLW  00
1172:  SUBWFB xCB,W
1174:  MOVWF  xD9
1176:  MOVF   xC8,W
1178:  ADDWF  xD8,W
117A:  MOVWF  FE9
117C:  MOVF   xC9,W
117E:  ADDWFC xD9,W
1180:  MOVWF  FEA
1182:  MOVFF  FEF,ADA
1186:  MOVLW  03
1188:  SUBWF  xCA,W
118A:  MOVWF  xDB
118C:  MOVLW  00
118E:  SUBWFB xCB,W
1190:  MOVWF  xDC
1192:  MOVF   xC8,W
1194:  ADDWF  xDB,W
1196:  MOVWF  FE9
1198:  MOVF   xC9,W
119A:  ADDWFC xDC,W
119C:  MOVWF  FEA
119E:  MOVFF  FEF,ADD
11A2:  MOVLW  02
11A4:  SUBWF  xCA,W
11A6:  MOVWF  xDE
11A8:  MOVLW  00
11AA:  SUBWFB xCB,W
11AC:  MOVWF  xDF
11AE:  MOVF   xC8,W
11B0:  ADDWF  xDE,W
11B2:  MOVWF  FE9
11B4:  MOVF   xC9,W
11B6:  ADDWFC xDF,W
11B8:  MOVWF  FEA
11BA:  MOVFF  FEF,AE0
11BE:  MOVLW  01
11C0:  SUBWF  xCA,W
11C2:  MOVWF  xE1
11C4:  MOVLW  00
11C6:  SUBWFB xCB,W
11C8:  MOVWF  xE2
11CA:  MOVF   xC8,W
11CC:  ADDWF  xE1,W
11CE:  MOVWF  FE9
11D0:  MOVF   xC9,W
11D2:  ADDWFC xE2,W
11D4:  MOVWF  FEA
11D6:  MOVFF  FEF,AE3
11DA:  MOVF   xC8,W
11DC:  ADDWF  xCA,W
11DE:  MOVWF  FE9
11E0:  MOVF   xC9,W
11E2:  ADDWFC xCB,W
11E4:  MOVWF  FEA
11E6:  MOVFF  FEF,AE4
11EA:  CLRF   xE7
11EC:  MOVFF  AD4,AE8
11F0:  MOVFF  AD7,AE9
11F4:  MOVFF  ADA,AEA
11F8:  MOVFF  ADD,AEB
11FC:  MOVFF  AE0,AEC
1200:  MOVFF  AE3,AED
1204:  MOVFF  AE4,AEE
1208:  MOVLB  0
120A:  CALL   07C0
120E:  MOVFF  01,ACE
....................          temp1= makebyte(0,datin[i-13],datin[i-12],datin[i-11],datin[i-10],datin[i-9],datin[i-8],datin[i-7]);  
1212:  MOVLW  0D
1214:  MOVLB  A
1216:  SUBWF  xCA,W
1218:  MOVWF  xD2
121A:  MOVLW  00
121C:  SUBWFB xCB,W
121E:  MOVWF  xD3
1220:  MOVF   xC8,W
1222:  ADDWF  xD2,W
1224:  MOVWF  FE9
1226:  MOVF   xC9,W
1228:  ADDWFC xD3,W
122A:  MOVWF  FEA
122C:  MOVFF  FEF,AD4
1230:  MOVLW  0C
1232:  SUBWF  xCA,W
1234:  MOVWF  xD5
1236:  MOVLW  00
1238:  SUBWFB xCB,W
123A:  MOVWF  xD6
123C:  MOVF   xC8,W
123E:  ADDWF  xD5,W
1240:  MOVWF  FE9
1242:  MOVF   xC9,W
1244:  ADDWFC xD6,W
1246:  MOVWF  FEA
1248:  MOVFF  FEF,AD7
124C:  MOVLW  0B
124E:  SUBWF  xCA,W
1250:  MOVWF  xD8
1252:  MOVLW  00
1254:  SUBWFB xCB,W
1256:  MOVWF  xD9
1258:  MOVF   xC8,W
125A:  ADDWF  xD8,W
125C:  MOVWF  FE9
125E:  MOVF   xC9,W
1260:  ADDWFC xD9,W
1262:  MOVWF  FEA
1264:  MOVFF  FEF,ADA
1268:  MOVLW  0A
126A:  SUBWF  xCA,W
126C:  MOVWF  xDB
126E:  MOVLW  00
1270:  SUBWFB xCB,W
1272:  MOVWF  xDC
1274:  MOVF   xC8,W
1276:  ADDWF  xDB,W
1278:  MOVWF  FE9
127A:  MOVF   xC9,W
127C:  ADDWFC xDC,W
127E:  MOVWF  FEA
1280:  MOVFF  FEF,ADD
1284:  MOVLW  09
1286:  SUBWF  xCA,W
1288:  MOVWF  xDE
128A:  MOVLW  00
128C:  SUBWFB xCB,W
128E:  MOVWF  xDF
1290:  MOVF   xC8,W
1292:  ADDWF  xDE,W
1294:  MOVWF  FE9
1296:  MOVF   xC9,W
1298:  ADDWFC xDF,W
129A:  MOVWF  FEA
129C:  MOVFF  FEF,AE0
12A0:  MOVLW  08
12A2:  SUBWF  xCA,W
12A4:  MOVWF  xE1
12A6:  MOVLW  00
12A8:  SUBWFB xCB,W
12AA:  MOVWF  xE2
12AC:  MOVF   xC8,W
12AE:  ADDWF  xE1,W
12B0:  MOVWF  FE9
12B2:  MOVF   xC9,W
12B4:  ADDWFC xE2,W
12B6:  MOVWF  FEA
12B8:  MOVFF  FEF,AE3
12BC:  MOVLW  07
12BE:  SUBWF  xCA,W
12C0:  MOVWF  xE4
12C2:  MOVLW  00
12C4:  SUBWFB xCB,W
12C6:  MOVWF  xE5
12C8:  MOVF   xC8,W
12CA:  ADDWF  xE4,W
12CC:  MOVWF  FE9
12CE:  MOVF   xC9,W
12D0:  ADDWFC xE5,W
12D2:  MOVWF  FEA
12D4:  MOVFF  FEF,AE6
12D8:  CLRF   xE7
12DA:  MOVFF  AD4,AE8
12DE:  MOVFF  AD7,AE9
12E2:  MOVFF  ADA,AEA
12E6:  MOVFF  ADD,AEB
12EA:  MOVFF  AE0,AEC
12EE:  MOVFF  AE3,AED
12F2:  MOVFF  AE6,AEE
12F6:  MOVLB  0
12F8:  CALL   07C0
12FC:  MOVFF  01,ACF
....................          /*CRC = !(datin[i-19]^datin[i-18]^datin[i-17]^datin[i-16]^datin[i-15]^datin[i-14]); 
....................          if(datin[i-20] == CRC)check_crc=1; 
....................            else check_crc=0;*/ 
....................           // fprintf(COM2,"%d\r\n",check_crc);  
....................          if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)) 
1300:  MOVLB  A
1302:  MOVF   xCE,W
1304:  SUBLW  45
1306:  BTFSS  FD8.2
1308:  BRA    1482
130A:  MOVF   xCF,W
130C:  SUBLW  7C
130E:  BTFSC  FD8.2
1310:  BRA    1482
1312:  MOVF   xCF,W
1314:  SUBLW  3E
1316:  BTFSC  FD8.2
1318:  BRA    1482
131A:  MOVF   xCF,W
131C:  SUBLW  1F
131E:  BTFSC  FD8.2
1320:  BRA    1482
1322:  MOVF   xCF,W
1324:  SUBLW  0F
1326:  BTFSC  FD8.2
1328:  BRA    1482
132A:  MOVF   xCF,W
132C:  SUBLW  78
132E:  BTFSC  FD8.2
1330:  BRA    1482
....................          { 
....................             j=i; 
1332:  MOVFF  ACB,ACD
1336:  MOVFF  ACA,ACC
....................             CRC=1; 
133A:  MOVLW  01
133C:  MOVWF  xD1
....................             temp2=temp; 
133E:  MOVFF  ACE,AD0
....................              while((temp2!=0b00011111)&&(j>1)) 
1342:  MOVF   xD0,W
1344:  SUBLW  1F
1346:  BTFSC  FD8.2
1348:  BRA    1462
134A:  MOVF   xCD,F
134C:  BNZ   1356
134E:  MOVF   xCC,W
1350:  SUBLW  01
1352:  BTFSC  FD8.0
1354:  BRA    1462
....................              { 
....................                CRC=check_lrc_T1(1,j,datin)&CRC; 
1356:  MOVLW  01
1358:  MOVWF  xD2
135A:  MOVFF  ACD,AD4
135E:  MOVFF  ACC,AD3
1362:  MOVFF  AC9,AD6
1366:  MOVFF  AC8,AD5
136A:  MOVLB  0
136C:  CALL   0826
1370:  MOVF   01,W
1372:  MOVLB  A
1374:  ANDWF  xD1,F
....................                temp2 = makebyte(0,datin[j-6],datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
1376:  MOVLW  06
1378:  SUBWF  xCC,W
137A:  MOVWF  xD2
137C:  MOVLW  00
137E:  SUBWFB xCD,W
1380:  MOVWF  xD3
1382:  MOVF   xC8,W
1384:  ADDWF  xD2,W
1386:  MOVWF  FE9
1388:  MOVF   xC9,W
138A:  ADDWFC xD3,W
138C:  MOVWF  FEA
138E:  MOVFF  FEF,AD4
1392:  MOVLW  05
1394:  SUBWF  xCC,W
1396:  MOVWF  xD5
1398:  MOVLW  00
139A:  SUBWFB xCD,W
139C:  MOVWF  xD6
139E:  MOVF   xC8,W
13A0:  ADDWF  xD5,W
13A2:  MOVWF  FE9
13A4:  MOVF   xC9,W
13A6:  ADDWFC xD6,W
13A8:  MOVWF  FEA
13AA:  MOVFF  FEF,AD7
13AE:  MOVLW  04
13B0:  SUBWF  xCC,W
13B2:  MOVWF  xD8
13B4:  MOVLW  00
13B6:  SUBWFB xCD,W
13B8:  MOVWF  xD9
13BA:  MOVF   xC8,W
13BC:  ADDWF  xD8,W
13BE:  MOVWF  FE9
13C0:  MOVF   xC9,W
13C2:  ADDWFC xD9,W
13C4:  MOVWF  FEA
13C6:  MOVFF  FEF,ADA
13CA:  MOVLW  03
13CC:  SUBWF  xCC,W
13CE:  MOVWF  xDB
13D0:  MOVLW  00
13D2:  SUBWFB xCD,W
13D4:  MOVWF  xDC
13D6:  MOVF   xC8,W
13D8:  ADDWF  xDB,W
13DA:  MOVWF  FE9
13DC:  MOVF   xC9,W
13DE:  ADDWFC xDC,W
13E0:  MOVWF  FEA
13E2:  MOVFF  FEF,ADD
13E6:  MOVLW  02
13E8:  SUBWF  xCC,W
13EA:  MOVWF  xDE
13EC:  MOVLW  00
13EE:  SUBWFB xCD,W
13F0:  MOVWF  xDF
13F2:  MOVF   xC8,W
13F4:  ADDWF  xDE,W
13F6:  MOVWF  FE9
13F8:  MOVF   xC9,W
13FA:  ADDWFC xDF,W
13FC:  MOVWF  FEA
13FE:  MOVFF  FEF,AE0
1402:  MOVLW  01
1404:  SUBWF  xCC,W
1406:  MOVWF  xE1
1408:  MOVLW  00
140A:  SUBWFB xCD,W
140C:  MOVWF  xE2
140E:  MOVF   xC8,W
1410:  ADDWF  xE1,W
1412:  MOVWF  FE9
1414:  MOVF   xC9,W
1416:  ADDWFC xE2,W
1418:  MOVWF  FEA
141A:  MOVFF  FEF,AE3
141E:  MOVF   xC8,W
1420:  ADDWF  xCC,W
1422:  MOVWF  FE9
1424:  MOVF   xC9,W
1426:  ADDWFC xCD,W
1428:  MOVWF  FEA
142A:  MOVFF  FEF,AE4
142E:  CLRF   xE7
1430:  MOVFF  AD4,AE8
1434:  MOVFF  AD7,AE9
1438:  MOVFF  ADA,AEA
143C:  MOVFF  ADD,AEB
1440:  MOVFF  AE0,AEC
1444:  MOVFF  AE3,AED
1448:  MOVFF  AE4,AEE
144C:  MOVLB  0
144E:  CALL   07C0
1452:  MOVFF  01,AD0
....................                j=j-7;             
1456:  MOVLW  07
1458:  MOVLB  A
145A:  SUBWF  xCC,F
145C:  MOVLW  00
145E:  SUBWFB xCD,F
1460:  BRA    1342
....................              } 
....................              //fprintf(COM2,"CRC_T1,j=%d,%lu\r\n",CRC,j); 
....................             if(CRC==1) 
1462:  DECFSZ xD1,W
1464:  BRA    147A
....................             { 
....................                dir=1; 
1466:  MOVLW  01
1468:  MOVLB  9
146A:  MOVWF  x99
....................                return i; 
146C:  MOVLB  A
146E:  MOVFF  ACA,01
1472:  MOVFF  ACB,02
1476:  BRA    1714
....................             } 
1478:  BRA    1482
....................             else return 0; 
147A:  MOVLW  00
147C:  MOVWF  01
147E:  MOVWF  02
1480:  BRA    1714
....................          } 
....................          /*if((temp==0b01000101)&&(temp1!=0b01111100)&&(temp1!=0b00111110)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(temp1!=0b01111000)&&(check_crc==1)) 
....................          { 
....................             //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................             dir=1; 
....................             return i; 
....................          }*/ 
....................       } 
1482:  BRA    1704
....................          else 
....................          { 
....................             temp = makebyte(0,0,0,datin[i-4],datin[i-3],datin[i-2],datin[i-1],datin[i]); 
1484:  MOVLW  04
1486:  SUBWF  xCA,W
1488:  MOVWF  xD2
148A:  MOVLW  00
148C:  SUBWFB xCB,W
148E:  MOVWF  xD3
1490:  MOVF   xC8,W
1492:  ADDWF  xD2,W
1494:  MOVWF  FE9
1496:  MOVF   xC9,W
1498:  ADDWFC xD3,W
149A:  MOVWF  FEA
149C:  MOVFF  FEF,AD4
14A0:  MOVLW  03
14A2:  SUBWF  xCA,W
14A4:  MOVWF  xD5
14A6:  MOVLW  00
14A8:  SUBWFB xCB,W
14AA:  MOVWF  xD6
14AC:  MOVF   xC8,W
14AE:  ADDWF  xD5,W
14B0:  MOVWF  FE9
14B2:  MOVF   xC9,W
14B4:  ADDWFC xD6,W
14B6:  MOVWF  FEA
14B8:  MOVFF  FEF,AD7
14BC:  MOVLW  02
14BE:  SUBWF  xCA,W
14C0:  MOVWF  xD8
14C2:  MOVLW  00
14C4:  SUBWFB xCB,W
14C6:  MOVWF  xD9
14C8:  MOVF   xC8,W
14CA:  ADDWF  xD8,W
14CC:  MOVWF  FE9
14CE:  MOVF   xC9,W
14D0:  ADDWFC xD9,W
14D2:  MOVWF  FEA
14D4:  MOVFF  FEF,ADA
14D8:  MOVLW  01
14DA:  SUBWF  xCA,W
14DC:  MOVWF  xDB
14DE:  MOVLW  00
14E0:  SUBWFB xCB,W
14E2:  MOVWF  xDC
14E4:  MOVF   xC8,W
14E6:  ADDWF  xDB,W
14E8:  MOVWF  FE9
14EA:  MOVF   xC9,W
14EC:  ADDWFC xDC,W
14EE:  MOVWF  FEA
14F0:  MOVFF  FEF,ADD
14F4:  MOVF   xC8,W
14F6:  ADDWF  xCA,W
14F8:  MOVWF  FE9
14FA:  MOVF   xC9,W
14FC:  ADDWFC xCB,W
14FE:  MOVWF  FEA
1500:  MOVFF  FEF,ADE
1504:  CLRF   xE7
1506:  CLRF   xE8
1508:  CLRF   xE9
150A:  MOVFF  AD4,AEA
150E:  MOVFF  AD7,AEB
1512:  MOVFF  ADA,AEC
1516:  MOVFF  ADD,AED
151A:  MOVFF  ADE,AEE
151E:  MOVLB  0
1520:  CALL   07C0
1524:  MOVFF  01,ACE
....................             temp1= makebyte(0,0,0,datin[i-9],datin[i-8],datin[i-7],datin[i-6],datin[i-5]); 
1528:  MOVLW  09
152A:  MOVLB  A
152C:  SUBWF  xCA,W
152E:  MOVWF  xD2
1530:  MOVLW  00
1532:  SUBWFB xCB,W
1534:  MOVWF  xD3
1536:  MOVF   xC8,W
1538:  ADDWF  xD2,W
153A:  MOVWF  FE9
153C:  MOVF   xC9,W
153E:  ADDWFC xD3,W
1540:  MOVWF  FEA
1542:  MOVFF  FEF,AD4
1546:  MOVLW  08
1548:  SUBWF  xCA,W
154A:  MOVWF  xD5
154C:  MOVLW  00
154E:  SUBWFB xCB,W
1550:  MOVWF  xD6
1552:  MOVF   xC8,W
1554:  ADDWF  xD5,W
1556:  MOVWF  FE9
1558:  MOVF   xC9,W
155A:  ADDWFC xD6,W
155C:  MOVWF  FEA
155E:  MOVFF  FEF,AD7
1562:  MOVLW  07
1564:  SUBWF  xCA,W
1566:  MOVWF  xD8
1568:  MOVLW  00
156A:  SUBWFB xCB,W
156C:  MOVWF  xD9
156E:  MOVF   xC8,W
1570:  ADDWF  xD8,W
1572:  MOVWF  FE9
1574:  MOVF   xC9,W
1576:  ADDWFC xD9,W
1578:  MOVWF  FEA
157A:  MOVFF  FEF,ADA
157E:  MOVLW  06
1580:  SUBWF  xCA,W
1582:  MOVWF  xDB
1584:  MOVLW  00
1586:  SUBWFB xCB,W
1588:  MOVWF  xDC
158A:  MOVF   xC8,W
158C:  ADDWF  xDB,W
158E:  MOVWF  FE9
1590:  MOVF   xC9,W
1592:  ADDWFC xDC,W
1594:  MOVWF  FEA
1596:  MOVFF  FEF,ADD
159A:  MOVLW  05
159C:  SUBWF  xCA,W
159E:  MOVWF  xDE
15A0:  MOVLW  00
15A2:  SUBWFB xCB,W
15A4:  MOVWF  xDF
15A6:  MOVF   xC8,W
15A8:  ADDWF  xDE,W
15AA:  MOVWF  FE9
15AC:  MOVF   xC9,W
15AE:  ADDWFC xDF,W
15B0:  MOVWF  FEA
15B2:  MOVFF  FEF,AE0
15B6:  CLRF   xE7
15B8:  CLRF   xE8
15BA:  CLRF   xE9
15BC:  MOVFF  AD4,AEA
15C0:  MOVFF  AD7,AEB
15C4:  MOVFF  ADA,AEC
15C8:  MOVFF  ADD,AED
15CC:  MOVFF  AE0,AEE
15D0:  MOVLB  0
15D2:  CALL   07C0
15D6:  MOVFF  01,ACF
....................             /*CRC = !(datin[i-8]^datin[i-7]^datin[i-6]^datin[i-5]); 
....................             if(datin[i-9]== CRC)check_crc=1; 
....................             else check_crc=0;*/ 
....................             //fprintf(COM2,"%d\r\n",check_crc);  
....................             if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)) 
15DA:  MOVLB  A
15DC:  MOVF   xCE,W
15DE:  SUBLW  0B
15E0:  BTFSS  FD8.2
15E2:  BRA    1704
15E4:  MOVF   xCF,W
15E6:  SUBLW  1F
15E8:  BTFSC  FD8.2
15EA:  BRA    1704
15EC:  MOVF   xCF,W
15EE:  SUBLW  0F
15F0:  BTFSC  FD8.2
15F2:  BRA    1704
....................             { 
....................                j=i; 
15F4:  MOVFF  ACB,ACD
15F8:  MOVFF  ACA,ACC
....................                CRC=1; 
15FC:  MOVLW  01
15FE:  MOVWF  xD1
....................                temp2=temp; 
1600:  MOVFF  ACE,AD0
....................                while((temp2!=0b00011111)&&(j>1)) 
1604:  MOVF   xD0,W
1606:  SUBLW  1F
1608:  BZ    16E4
160A:  MOVF   xCD,F
160C:  BNZ   1614
160E:  MOVF   xCC,W
1610:  SUBLW  01
1612:  BC    16E4
....................                { 
....................                   CRC=check_lrc_T2(1,j,datin)&CRC; 
1614:  MOVLW  01
1616:  MOVWF  xD2
1618:  MOVFF  ACD,AD4
161C:  MOVFF  ACC,AD3
1620:  MOVFF  AC9,AD6
1624:  MOVFF  AC8,AD5
1628:  MOVLB  0
162A:  CALL   09D6
162E:  MOVF   01,W
1630:  MOVLB  A
1632:  ANDWF  xD1,F
....................                   temp2=makebyte(0,0,0,datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
1634:  MOVLW  04
1636:  SUBWF  xCC,W
1638:  MOVWF  xD2
163A:  MOVLW  00
163C:  SUBWFB xCD,W
163E:  MOVWF  xD3
1640:  MOVF   xC8,W
1642:  ADDWF  xD2,W
1644:  MOVWF  FE9
1646:  MOVF   xC9,W
1648:  ADDWFC xD3,W
164A:  MOVWF  FEA
164C:  MOVFF  FEF,AD4
1650:  MOVLW  03
1652:  SUBWF  xCC,W
1654:  MOVWF  xD5
1656:  MOVLW  00
1658:  SUBWFB xCD,W
165A:  MOVWF  xD6
165C:  MOVF   xC8,W
165E:  ADDWF  xD5,W
1660:  MOVWF  FE9
1662:  MOVF   xC9,W
1664:  ADDWFC xD6,W
1666:  MOVWF  FEA
1668:  MOVFF  FEF,AD7
166C:  MOVLW  02
166E:  SUBWF  xCC,W
1670:  MOVWF  xD8
1672:  MOVLW  00
1674:  SUBWFB xCD,W
1676:  MOVWF  xD9
1678:  MOVF   xC8,W
167A:  ADDWF  xD8,W
167C:  MOVWF  FE9
167E:  MOVF   xC9,W
1680:  ADDWFC xD9,W
1682:  MOVWF  FEA
1684:  MOVFF  FEF,ADA
1688:  MOVLW  01
168A:  SUBWF  xCC,W
168C:  MOVWF  xDB
168E:  MOVLW  00
1690:  SUBWFB xCD,W
1692:  MOVWF  xDC
1694:  MOVF   xC8,W
1696:  ADDWF  xDB,W
1698:  MOVWF  FE9
169A:  MOVF   xC9,W
169C:  ADDWFC xDC,W
169E:  MOVWF  FEA
16A0:  MOVFF  FEF,ADD
16A4:  MOVF   xC8,W
16A6:  ADDWF  xCC,W
16A8:  MOVWF  FE9
16AA:  MOVF   xC9,W
16AC:  ADDWFC xCD,W
16AE:  MOVWF  FEA
16B0:  MOVFF  FEF,ADE
16B4:  CLRF   xE7
16B6:  CLRF   xE8
16B8:  CLRF   xE9
16BA:  MOVFF  AD4,AEA
16BE:  MOVFF  AD7,AEB
16C2:  MOVFF  ADA,AEC
16C6:  MOVFF  ADD,AED
16CA:  MOVFF  ADE,AEE
16CE:  MOVLB  0
16D0:  CALL   07C0
16D4:  MOVFF  01,AD0
....................                   j=j-5; 
16D8:  MOVLW  05
16DA:  MOVLB  A
16DC:  SUBWF  xCC,F
16DE:  MOVLW  00
16E0:  SUBWFB xCD,F
16E2:  BRA    1604
....................                } 
....................                //fprintf(COM2,"CRC_T2,j=%d,%lu\r\n",CRC,j); 
....................                if(CRC==1) 
16E4:  DECFSZ xD1,W
16E6:  BRA    16FC
....................                { 
....................                   dir=1; 
16E8:  MOVLW  01
16EA:  MOVLB  9
16EC:  MOVWF  x99
....................                   return i; 
16EE:  MOVLB  A
16F0:  MOVFF  ACA,01
16F4:  MOVFF  ACB,02
16F8:  BRA    1714
....................                } 
16FA:  BRA    1704
....................                   else return 0; 
16FC:  MOVLW  00
16FE:  MOVWF  01
1700:  MOVWF  02
1702:  BRA    1714
....................             } 
....................            /* if((temp==0b00001011)&&(temp1!=0b00011111)&&(temp1!=0b00001111)&&(check_crc==1))//&&(temp1!=0b00011111)) 
....................             { 
....................                //fprintf(COM2,"\r\ndir=%d,detect_pos=%lu\r\n",1,i); 
....................                dir=1; 
....................                return i; 
....................             } */            
....................          } 
1704:  MOVF   xCA,W
1706:  BTFSC  FD8.2
1708:  DECF   xCB,F
170A:  DECF   xCA,F
170C:  BRA    1106
....................    } 
....................    return 0; 
170E:  MOVLW  00
1710:  MOVWF  01
1712:  MOVWF  02
1714:  MOVLB  0
1716:  RETURN 0
.................... } 
.................... //========================= 
.................... int8 con_data_track(int8 track,int16 countbit ,int8 *datin,int8 *datout) 
*
3A94:  MOVLB  A
3A96:  CLRF   xC4
3A98:  MOVLW  01
3A9A:  MOVWF  xC3
.................... { 
....................    int8 i; 
....................    int16 j,temp=1; 
....................    temp = detect_pos_st(track,countbit,datin); 
3A9C:  MOVFF  AB9,AC5
3AA0:  MOVFF  ABB,AC7
3AA4:  MOVFF  ABA,AC6
3AA8:  MOVFF  ABD,AC9
3AAC:  MOVFF  ABC,AC8
3AB0:  MOVLB  0
3AB2:  CALL   0B16
3AB6:  MOVFF  02,AC4
3ABA:  MOVFF  01,AC3
....................    if(temp==0) return 0; 
3ABE:  MOVLB  A
3AC0:  MOVF   xC3,F
3AC2:  BNZ   3ACE
3AC4:  MOVF   xC4,F
3AC6:  BNZ   3ACE
3AC8:  MOVLW  00
3ACA:  MOVWF  01
3ACC:  BRA    3E70
....................    j=temp; 
3ACE:  MOVFF  AC4,AC2
3AD2:  MOVFF  AC3,AC1
....................    if(dir==0) 
3AD6:  MOVLB  9
3AD8:  MOVF   x99,F
3ADA:  BTFSS  FD8.2
3ADC:  BRA    3C94
....................    { 
....................       if(track==0) 
3ADE:  MOVLB  A
3AE0:  MOVF   xB9,F
3AE2:  BTFSS  FD8.2
3AE4:  BRA    3BDA
....................       { 
....................             for(i=0;i<79;i++) 
3AE6:  CLRF   xC0
3AE8:  MOVF   xC0,W
3AEA:  SUBLW  4E
3AEC:  BNC   3BD8
....................             { 
....................                datout[i]=makebyte(0,0,datin[j+5],datin[j+4],datin[j+3],datin[j+2],datin[j+1],datin[j]); 
3AEE:  MOVF   xC0,W
3AF0:  ADDWF  xBE,W
3AF2:  MOVWF  01
3AF4:  MOVLW  00
3AF6:  ADDWFC xBF,W
3AF8:  MOVWF  03
3AFA:  MOVFF  01,AC5
3AFE:  MOVWF  xC6
3B00:  MOVLW  05
3B02:  ADDWF  xC1,W
3B04:  MOVWF  xC7
3B06:  MOVLW  00
3B08:  ADDWFC xC2,W
3B0A:  MOVWF  xC8
3B0C:  MOVF   xBC,W
3B0E:  ADDWF  xC7,W
3B10:  MOVWF  FE9
3B12:  MOVF   xBD,W
3B14:  ADDWFC xC8,W
3B16:  MOVWF  FEA
3B18:  MOVFF  FEF,AC9
3B1C:  MOVLW  04
3B1E:  ADDWF  xC1,W
3B20:  MOVWF  xCA
3B22:  MOVLW  00
3B24:  ADDWFC xC2,W
3B26:  MOVWF  xCB
3B28:  MOVF   xBC,W
3B2A:  ADDWF  xCA,W
3B2C:  MOVWF  FE9
3B2E:  MOVF   xBD,W
3B30:  ADDWFC xCB,W
3B32:  MOVWF  FEA
3B34:  MOVFF  FEF,ACC
3B38:  MOVLW  03
3B3A:  ADDWF  xC1,W
3B3C:  MOVWF  xCD
3B3E:  MOVLW  00
3B40:  ADDWFC xC2,W
3B42:  MOVWF  xCE
3B44:  MOVF   xBC,W
3B46:  ADDWF  xCD,W
3B48:  MOVWF  FE9
3B4A:  MOVF   xBD,W
3B4C:  ADDWFC xCE,W
3B4E:  MOVWF  FEA
3B50:  MOVFF  FEF,ACF
3B54:  MOVLW  02
3B56:  ADDWF  xC1,W
3B58:  MOVWF  xD0
3B5A:  MOVLW  00
3B5C:  ADDWFC xC2,W
3B5E:  MOVWF  xD1
3B60:  MOVF   xBC,W
3B62:  ADDWF  xD0,W
3B64:  MOVWF  FE9
3B66:  MOVF   xBD,W
3B68:  ADDWFC xD1,W
3B6A:  MOVWF  FEA
3B6C:  MOVFF  FEF,AD2
3B70:  MOVLW  01
3B72:  ADDWF  xC1,W
3B74:  MOVWF  xD3
3B76:  MOVLW  00
3B78:  ADDWFC xC2,W
3B7A:  MOVWF  xD4
3B7C:  MOVF   xBC,W
3B7E:  ADDWF  xD3,W
3B80:  MOVWF  FE9
3B82:  MOVF   xBD,W
3B84:  ADDWFC xD4,W
3B86:  MOVWF  FEA
3B88:  MOVFF  FEF,AD5
3B8C:  MOVF   xBC,W
3B8E:  ADDWF  xC1,W
3B90:  MOVWF  FE9
3B92:  MOVF   xBD,W
3B94:  ADDWFC xC2,W
3B96:  MOVWF  FEA
3B98:  MOVFF  FEF,AD6
3B9C:  CLRF   xE7
3B9E:  CLRF   xE8
3BA0:  MOVFF  AC9,AE9
3BA4:  MOVFF  ACC,AEA
3BA8:  MOVFF  ACF,AEB
3BAC:  MOVFF  AD2,AEC
3BB0:  MOVFF  AD5,AED
3BB4:  MOVFF  AD6,AEE
3BB8:  MOVLB  0
3BBA:  CALL   07C0
3BBE:  MOVFF  AC6,FEA
3BC2:  MOVFF  AC5,FE9
3BC6:  MOVFF  01,FEF
....................                j=j+7; 
3BCA:  MOVLW  07
3BCC:  MOVLB  A
3BCE:  ADDWF  xC1,F
3BD0:  MOVLW  00
3BD2:  ADDWFC xC2,F
3BD4:  INCF   xC0,F
3BD6:  BRA    3AE8
....................             } 
....................       } 
3BD8:  BRA    3C90
....................          else  
....................          { 
....................             for(i=0;i<40;i++) 
3BDA:  CLRF   xC0
3BDC:  MOVF   xC0,W
3BDE:  SUBLW  27
3BE0:  BNC   3C90
....................             { 
....................                datout[i]=makebyte(0,0,0,0,datin[j+3],datin[j+2],datin[j+1],datin[j]); 
3BE2:  MOVF   xC0,W
3BE4:  ADDWF  xBE,W
3BE6:  MOVWF  01
3BE8:  MOVLW  00
3BEA:  ADDWFC xBF,W
3BEC:  MOVWF  03
3BEE:  MOVFF  01,AC5
3BF2:  MOVWF  xC6
3BF4:  MOVLW  03
3BF6:  ADDWF  xC1,W
3BF8:  MOVWF  xC7
3BFA:  MOVLW  00
3BFC:  ADDWFC xC2,W
3BFE:  MOVWF  xC8
3C00:  MOVF   xBC,W
3C02:  ADDWF  xC7,W
3C04:  MOVWF  FE9
3C06:  MOVF   xBD,W
3C08:  ADDWFC xC8,W
3C0A:  MOVWF  FEA
3C0C:  MOVFF  FEF,AC9
3C10:  MOVLW  02
3C12:  ADDWF  xC1,W
3C14:  MOVWF  xCA
3C16:  MOVLW  00
3C18:  ADDWFC xC2,W
3C1A:  MOVWF  xCB
3C1C:  MOVF   xBC,W
3C1E:  ADDWF  xCA,W
3C20:  MOVWF  FE9
3C22:  MOVF   xBD,W
3C24:  ADDWFC xCB,W
3C26:  MOVWF  FEA
3C28:  MOVFF  FEF,ACC
3C2C:  MOVLW  01
3C2E:  ADDWF  xC1,W
3C30:  MOVWF  xCD
3C32:  MOVLW  00
3C34:  ADDWFC xC2,W
3C36:  MOVWF  xCE
3C38:  MOVF   xBC,W
3C3A:  ADDWF  xCD,W
3C3C:  MOVWF  FE9
3C3E:  MOVF   xBD,W
3C40:  ADDWFC xCE,W
3C42:  MOVWF  FEA
3C44:  MOVFF  FEF,ACF
3C48:  MOVF   xBC,W
3C4A:  ADDWF  xC1,W
3C4C:  MOVWF  FE9
3C4E:  MOVF   xBD,W
3C50:  ADDWFC xC2,W
3C52:  MOVWF  FEA
3C54:  MOVFF  FEF,AD0
3C58:  CLRF   xE7
3C5A:  CLRF   xE8
3C5C:  CLRF   xE9
3C5E:  CLRF   xEA
3C60:  MOVFF  AC9,AEB
3C64:  MOVFF  ACC,AEC
3C68:  MOVFF  ACF,AED
3C6C:  MOVFF  AD0,AEE
3C70:  MOVLB  0
3C72:  CALL   07C0
3C76:  MOVFF  AC6,FEA
3C7A:  MOVFF  AC5,FE9
3C7E:  MOVFF  01,FEF
....................                j=j+5; 
3C82:  MOVLW  05
3C84:  MOVLB  A
3C86:  ADDWF  xC1,F
3C88:  MOVLW  00
3C8A:  ADDWFC xC2,F
3C8C:  INCF   xC0,F
3C8E:  BRA    3BDC
....................             }          
....................          } 
....................    } 
3C90:  BRA    3E46
3C92:  MOVLB  9
....................       else  
....................       { 
....................          if(track==0) 
3C94:  MOVLB  A
3C96:  MOVF   xB9,F
3C98:  BTFSS  FD8.2
3C9A:  BRA    3D90
....................          { 
....................             for(i=0;i<79;i++) 
3C9C:  CLRF   xC0
3C9E:  MOVF   xC0,W
3CA0:  SUBLW  4E
3CA2:  BNC   3D8E
....................             { 
....................                datout[i]=makebyte(0,0,datin[j-5],datin[j-4],datin[j-3],datin[j-2],datin[j-1],datin[j]); 
3CA4:  MOVF   xC0,W
3CA6:  ADDWF  xBE,W
3CA8:  MOVWF  01
3CAA:  MOVLW  00
3CAC:  ADDWFC xBF,W
3CAE:  MOVWF  03
3CB0:  MOVFF  01,AC5
3CB4:  MOVWF  xC6
3CB6:  MOVLW  05
3CB8:  SUBWF  xC1,W
3CBA:  MOVWF  xC7
3CBC:  MOVLW  00
3CBE:  SUBWFB xC2,W
3CC0:  MOVWF  xC8
3CC2:  MOVF   xBC,W
3CC4:  ADDWF  xC7,W
3CC6:  MOVWF  FE9
3CC8:  MOVF   xBD,W
3CCA:  ADDWFC xC8,W
3CCC:  MOVWF  FEA
3CCE:  MOVFF  FEF,AC9
3CD2:  MOVLW  04
3CD4:  SUBWF  xC1,W
3CD6:  MOVWF  xCA
3CD8:  MOVLW  00
3CDA:  SUBWFB xC2,W
3CDC:  MOVWF  xCB
3CDE:  MOVF   xBC,W
3CE0:  ADDWF  xCA,W
3CE2:  MOVWF  FE9
3CE4:  MOVF   xBD,W
3CE6:  ADDWFC xCB,W
3CE8:  MOVWF  FEA
3CEA:  MOVFF  FEF,ACC
3CEE:  MOVLW  03
3CF0:  SUBWF  xC1,W
3CF2:  MOVWF  xCD
3CF4:  MOVLW  00
3CF6:  SUBWFB xC2,W
3CF8:  MOVWF  xCE
3CFA:  MOVF   xBC,W
3CFC:  ADDWF  xCD,W
3CFE:  MOVWF  FE9
3D00:  MOVF   xBD,W
3D02:  ADDWFC xCE,W
3D04:  MOVWF  FEA
3D06:  MOVFF  FEF,ACF
3D0A:  MOVLW  02
3D0C:  SUBWF  xC1,W
3D0E:  MOVWF  xD0
3D10:  MOVLW  00
3D12:  SUBWFB xC2,W
3D14:  MOVWF  xD1
3D16:  MOVF   xBC,W
3D18:  ADDWF  xD0,W
3D1A:  MOVWF  FE9
3D1C:  MOVF   xBD,W
3D1E:  ADDWFC xD1,W
3D20:  MOVWF  FEA
3D22:  MOVFF  FEF,AD2
3D26:  MOVLW  01
3D28:  SUBWF  xC1,W
3D2A:  MOVWF  xD3
3D2C:  MOVLW  00
3D2E:  SUBWFB xC2,W
3D30:  MOVWF  xD4
3D32:  MOVF   xBC,W
3D34:  ADDWF  xD3,W
3D36:  MOVWF  FE9
3D38:  MOVF   xBD,W
3D3A:  ADDWFC xD4,W
3D3C:  MOVWF  FEA
3D3E:  MOVFF  FEF,AD5
3D42:  MOVF   xBC,W
3D44:  ADDWF  xC1,W
3D46:  MOVWF  FE9
3D48:  MOVF   xBD,W
3D4A:  ADDWFC xC2,W
3D4C:  MOVWF  FEA
3D4E:  MOVFF  FEF,AD6
3D52:  CLRF   xE7
3D54:  CLRF   xE8
3D56:  MOVFF  AC9,AE9
3D5A:  MOVFF  ACC,AEA
3D5E:  MOVFF  ACF,AEB
3D62:  MOVFF  AD2,AEC
3D66:  MOVFF  AD5,AED
3D6A:  MOVFF  AD6,AEE
3D6E:  MOVLB  0
3D70:  CALL   07C0
3D74:  MOVFF  AC6,FEA
3D78:  MOVFF  AC5,FE9
3D7C:  MOVFF  01,FEF
....................                j=j-7; 
3D80:  MOVLW  07
3D82:  MOVLB  A
3D84:  SUBWF  xC1,F
3D86:  MOVLW  00
3D88:  SUBWFB xC2,F
3D8A:  INCF   xC0,F
3D8C:  BRA    3C9E
....................             } 
....................          } 
3D8E:  BRA    3E46
....................             else 
....................             { 
....................                for(i=0;i<40;i++) 
3D90:  CLRF   xC0
3D92:  MOVF   xC0,W
3D94:  SUBLW  27
3D96:  BNC   3E46
....................                { 
....................                   datout[i]=makebyte(0,0,0,0,datin[j-3],datin[j-2],datin[j-1],datin[j]); 
3D98:  MOVF   xC0,W
3D9A:  ADDWF  xBE,W
3D9C:  MOVWF  01
3D9E:  MOVLW  00
3DA0:  ADDWFC xBF,W
3DA2:  MOVWF  03
3DA4:  MOVFF  01,AC5
3DA8:  MOVWF  xC6
3DAA:  MOVLW  03
3DAC:  SUBWF  xC1,W
3DAE:  MOVWF  xC7
3DB0:  MOVLW  00
3DB2:  SUBWFB xC2,W
3DB4:  MOVWF  xC8
3DB6:  MOVF   xBC,W
3DB8:  ADDWF  xC7,W
3DBA:  MOVWF  FE9
3DBC:  MOVF   xBD,W
3DBE:  ADDWFC xC8,W
3DC0:  MOVWF  FEA
3DC2:  MOVFF  FEF,AC9
3DC6:  MOVLW  02
3DC8:  SUBWF  xC1,W
3DCA:  MOVWF  xCA
3DCC:  MOVLW  00
3DCE:  SUBWFB xC2,W
3DD0:  MOVWF  xCB
3DD2:  MOVF   xBC,W
3DD4:  ADDWF  xCA,W
3DD6:  MOVWF  FE9
3DD8:  MOVF   xBD,W
3DDA:  ADDWFC xCB,W
3DDC:  MOVWF  FEA
3DDE:  MOVFF  FEF,ACC
3DE2:  MOVLW  01
3DE4:  SUBWF  xC1,W
3DE6:  MOVWF  xCD
3DE8:  MOVLW  00
3DEA:  SUBWFB xC2,W
3DEC:  MOVWF  xCE
3DEE:  MOVF   xBC,W
3DF0:  ADDWF  xCD,W
3DF2:  MOVWF  FE9
3DF4:  MOVF   xBD,W
3DF6:  ADDWFC xCE,W
3DF8:  MOVWF  FEA
3DFA:  MOVFF  FEF,ACF
3DFE:  MOVF   xBC,W
3E00:  ADDWF  xC1,W
3E02:  MOVWF  FE9
3E04:  MOVF   xBD,W
3E06:  ADDWFC xC2,W
3E08:  MOVWF  FEA
3E0A:  MOVFF  FEF,AD0
3E0E:  CLRF   xE7
3E10:  CLRF   xE8
3E12:  CLRF   xE9
3E14:  CLRF   xEA
3E16:  MOVFF  AC9,AEB
3E1A:  MOVFF  ACC,AEC
3E1E:  MOVFF  ACF,AED
3E22:  MOVFF  AD0,AEE
3E26:  MOVLB  0
3E28:  CALL   07C0
3E2C:  MOVFF  AC6,FEA
3E30:  MOVFF  AC5,FE9
3E34:  MOVFF  01,FEF
....................                   j=j-5; 
3E38:  MOVLW  05
3E3A:  MOVLB  A
3E3C:  SUBWF  xC1,F
3E3E:  MOVLW  00
3E40:  SUBWFB xC2,F
3E42:  INCF   xC0,F
3E44:  BRA    3D92
....................                }             
....................             } 
....................       } 
....................       if(track==0)del_buf(numbyteofbuffer1,datin); 
3E46:  MOVF   xB9,F
3E48:  BNZ   3E5E
3E4A:  MOVLW  52
3E4C:  MOVWF  xC5
3E4E:  MOVFF  ABD,AC7
3E52:  MOVFF  ABC,AC6
3E56:  MOVLB  0
3E58:  RCALL  3A74
3E5A:  BRA    3E6E
3E5C:  MOVLB  A
....................          else del_buf(numbyteofbuffer2,datin); 
3E5E:  MOVLW  2C
3E60:  MOVWF  xC5
3E62:  MOVFF  ABD,AC7
3E66:  MOVFF  ABC,AC6
3E6A:  MOVLB  0
3E6C:  RCALL  3A74
3E6E:  MOVLB  A
3E70:  MOVLB  0
3E72:  RETURN 0
.................... } 
.................... //========================= 
.................... void debug_reader() 
.................... { 
....................    int16 i; 
....................    fprintf(COM2,"\r\nBIT_Track1 Data:\r\n"); 
*
18FA:  MOVLW  72
18FC:  MOVWF  FF6
18FE:  MOVLW  06
1900:  MOVWF  FF7
1902:  CALL   07A0
....................    for(i=0;i<numbyteofbuffer1;i++)fprintf(COM2,"%d",buffertrack1[i]); 
1906:  MOVLB  A
1908:  CLRF   xBD
190A:  CLRF   xBC
190C:  MOVF   xBD,W
190E:  SUBLW  03
1910:  BNC   1940
1912:  BNZ   191A
1914:  MOVF   xBC,W
1916:  SUBLW  51
1918:  BNC   1940
191A:  MOVLW  17
191C:  ADDWF  xBC,W
191E:  MOVWF  FE9
1920:  MOVLW  05
1922:  ADDWFC xBD,W
1924:  MOVWF  FEA
1926:  MOVFF  FEF,ABE
192A:  MOVFF  ABE,ABF
192E:  MOVLW  18
1930:  MOVWF  xC0
1932:  MOVLB  0
1934:  RCALL  1836
1936:  MOVLB  A
1938:  INCF   xBC,F
193A:  BTFSC  FD8.2
193C:  INCF   xBD,F
193E:  BRA    190C
....................    fprintf(COM2,"\r\nBIT_Track2 Data:\r\n"); 
1940:  MOVLW  88
1942:  MOVWF  FF6
1944:  MOVLW  06
1946:  MOVWF  FF7
1948:  MOVLB  0
194A:  CALL   07A0
....................    for(i=0;i<numbyteofbuffer2;i++)fprintf(COM2,"%d",buffertrack2[i]); 
194E:  MOVLB  A
1950:  CLRF   xBD
1952:  CLRF   xBC
1954:  MOVF   xBD,W
1956:  SUBLW  01
1958:  BNC   1988
195A:  BNZ   1962
195C:  MOVF   xBC,W
195E:  SUBLW  2B
1960:  BNC   1988
1962:  MOVLW  69
1964:  ADDWF  xBC,W
1966:  MOVWF  FE9
1968:  MOVLW  08
196A:  ADDWFC xBD,W
196C:  MOVWF  FEA
196E:  MOVFF  FEF,ABE
1972:  MOVFF  ABE,ABF
1976:  MOVLW  18
1978:  MOVWF  xC0
197A:  MOVLB  0
197C:  RCALL  1836
197E:  MOVLB  A
1980:  INCF   xBC,F
1982:  BTFSC  FD8.2
1984:  INCF   xBD,F
1986:  BRA    1954
1988:  MOVLB  0
198A:  GOTO   1C20 (RETURN)
.................... } 
.................... //========================= 
.................... /*void copybuf2temp() 
.................... { 
....................    int16 i; 
....................    for(i=0;i<numbyteofbuffer1;i++)temptrack1[i]=buffertrack1[i]; 
....................    for(i=0;i<numbyteofbuffer2;i++)temptrack2[i]=buffertrack2[i]; 
....................    datinbuf=1; 
.................... }*/ 
.................... //========================= 
.................... void saving_card() 
.................... { 
....................    int8 temp; 
....................    int16 tempcount; 
....................    //fprintf(COM2,"\r\n"); 
....................    saving_flag=1; 
*
3FF8:  MOVLW  01
3FFA:  MOVLB  9
3FFC:  MOVWF  xA9
....................    rtc_get_date(date,mon,year,day); 
....................    rtc_get_time(h,min,sec); 
....................    ptr_card=(int32)((get_countcard()*numdata)+ptr_start); 
*
40A6:  RCALL  3A02
40A8:  MOVFF  02,ABA
40AC:  MOVFF  01,AB9
40B0:  MOVFF  02,ABC
40B4:  MOVFF  01,ABB
40B8:  MOVLB  A
40BA:  CLRF   xBE
40BC:  MOVLW  7C
40BE:  MOVWF  xBD
40C0:  MOVLB  0
40C2:  RCALL  3A52
40C4:  MOVFF  01,AB9
40C8:  MOVLW  96
40CA:  MOVLB  A
40CC:  ADDWF  01,W
40CE:  MOVWF  01
40D0:  MOVLW  00
40D2:  ADDWFC 02,W
40D4:  MOVFF  01,20
40D8:  MOVWF  21
40DA:  CLRF   22
40DC:  CLRF   23
....................    if(datinbuf==0)  
40DE:  MOVLB  9
40E0:  MOVF   xA6,F
40E2:  BNZ   4104
....................    { 
....................       countbit_T1=0; 
40E4:  CLRF   x9B
40E6:  CLRF   x9A
....................       countbit_T2=0; 
40E8:  CLRF   x9D
40EA:  CLRF   x9C
....................       bug_countbit_T1=0; 
40EC:  CLRF   x9F
40EE:  CLRF   x9E
....................       bug_countbit_T2=0; 
40F0:  CLRF   xA1
40F2:  CLRF   xA0
....................       if(data_avai==0)charac_timeout=0xffffffff; 
40F4:  MOVF   xAA,F
40F6:  BNZ   4100
40F8:  MOVLB  0
40FA:  SETF   xFC
40FC:  SETF   xFB
40FE:  MOVLB  9
....................       saving_flag=0; 
4100:  CLRF   xA9
....................       return; 
4102:  BRA    4470
....................    }//*/ 
....................    //disable_interrupts(INT_EXT1_H2L); 
....................    fprintf(COM2,"\r\nSaving Card Data\r\n"); 
4104:  MOVLW  9E
4106:  MOVWF  FF6
4108:  MOVLW  06
410A:  MOVWF  FF7
410C:  MOVLB  0
410E:  CALL   07A0
....................    key_timeout=0; 
4112:  MOVLB  1
4114:  CLRF   x09
4116:  CLRF   x08
....................    //key_count=0; 
....................    enable_getpin=1; 
4118:  MOVLW  01
411A:  MOVWF  x0C
....................    //en_getpin; 
....................    tempcount=countbit_T1; 
411C:  MOVFF  99B,AB8
4120:  MOVFF  99A,AB7
....................    con_data_track(0,tempcount,buffertrack1,Track1); 
4124:  MOVLB  A
4126:  CLRF   xB9
4128:  MOVFF  AB8,ABB
412C:  MOVFF  AB7,ABA
4130:  MOVLW  05
4132:  MOVWF  xBD
4134:  MOVLW  17
4136:  MOVWF  xBC
4138:  MOVLW  04
413A:  MOVWF  xBF
413C:  MOVLW  A0
413E:  MOVWF  xBE
4140:  MOVLB  0
4142:  RCALL  3A94
....................    countbit_T1=0; 
4144:  MOVLB  9
4146:  CLRF   x9B
4148:  CLRF   x9A
....................    /*   fprintf(COM2,"\r\n"); 
....................       for(countbit=0;countbit<numbyteoftrack1;countbit++) 
....................          fputc(Track1[countbit]+0x20,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................    tempcount=countbit_T2;    
414A:  MOVFF  99D,AB8
414E:  MOVFF  99C,AB7
....................    con_data_track(1,tempcount,buffertrack2,Track2); 
4152:  MOVLW  01
4154:  MOVLB  A
4156:  MOVWF  xB9
4158:  MOVFF  AB8,ABB
415C:  MOVFF  AB7,ABA
4160:  MOVLW  08
4162:  MOVWF  xBD
4164:  MOVLW  69
4166:  MOVWF  xBC
4168:  MOVLW  04
416A:  MOVWF  xBF
416C:  MOVLW  EF
416E:  MOVWF  xBE
4170:  MOVLB  0
4172:  RCALL  3A94
....................    countbit_T2=0; 
4174:  MOVLB  9
4176:  CLRF   x9D
4178:  CLRF   x9C
....................    saving_flag=0; 
417A:  CLRF   xA9
....................   /*   for(countbit=0;countbit<numbyteoftrack2;countbit++) 
....................          fputc(Track2[countbit]+0x30,COM2); 
....................       fprintf(COM2,"\r\n");//*/ 
....................       temp=Track1[0]+0x20; 
417C:  MOVLW  20
417E:  MOVLB  4
4180:  ADDWF  xA0,W
4182:  MOVLB  A
4184:  MOVWF  xB6
....................    if((ptr_card<EEPROM_SIZE)&&(temp=='%')) 
4186:  MOVF   23,F
4188:  BTFSS  FD8.2
418A:  BRA    446E
418C:  MOVF   22,F
418E:  BTFSS  FD8.2
4190:  BRA    446E
4192:  MOVF   21,W
4194:  SUBLW  AA
4196:  BTFSS  FD8.0
4198:  BRA    446E
419A:  BNZ   41A4
419C:  MOVF   20,W
419E:  SUBLW  45
41A0:  BTFSS  FD8.0
41A2:  BRA    446E
41A4:  MOVF   xB6,W
41A6:  SUBLW  25
41A8:  BTFSS  FD8.2
41AA:  BRA    446E
....................    { 
....................          write_ext_eeprom((long int)ptr_card++,date); 
41AC:  MOVFF  23,03
41B0:  MOVFF  22,02
41B4:  MOVFF  21,01
41B8:  MOVFF  20,00
41BC:  MOVLW  01
41BE:  ADDWF  20,F
41C0:  BTFSC  FD8.0
41C2:  INCF   21,F
41C4:  BTFSC  FD8.2
41C6:  INCF   22,F
41C8:  BTFSC  FD8.2
41CA:  INCF   23,F
41CC:  MOVFF  01,ABA
41D0:  MOVFF  00,AB9
41D4:  MOVFF  01,AC8
41D8:  MOVFF  00,AC7
41DC:  MOVFF  100,AC9
41E0:  MOVLB  0
41E2:  RCALL  3E74
....................          write_ext_eeprom((long int)ptr_card++,mon); 
41E4:  MOVFF  23,03
41E8:  MOVFF  22,02
41EC:  MOVFF  21,01
41F0:  MOVFF  20,00
41F4:  MOVLW  01
41F6:  ADDWF  20,F
41F8:  BTFSC  FD8.0
41FA:  INCF   21,F
41FC:  BTFSC  FD8.2
41FE:  INCF   22,F
4200:  BTFSC  FD8.2
4202:  INCF   23,F
4204:  MOVFF  01,ABA
4208:  MOVFF  00,AB9
420C:  MOVFF  01,AC8
4210:  MOVFF  00,AC7
4214:  MOVFF  FF,AC9
4218:  RCALL  3E74
....................          write_ext_eeprom((long int)ptr_card++,h); 
421A:  MOVFF  23,03
421E:  MOVFF  22,02
4222:  MOVFF  21,01
4226:  MOVFF  20,00
422A:  MOVLW  01
422C:  ADDWF  20,F
422E:  BTFSC  FD8.0
4230:  INCF   21,F
4232:  BTFSC  FD8.2
4234:  INCF   22,F
4236:  BTFSC  FD8.2
4238:  INCF   23,F
423A:  MOVFF  01,ABA
423E:  MOVFF  00,AB9
4242:  MOVFF  01,AC8
4246:  MOVFF  00,AC7
424A:  MOVFF  101,AC9
424E:  RCALL  3E74
....................          write_ext_eeprom((long int)ptr_card++,min); 
4250:  MOVFF  23,03
4254:  MOVFF  22,02
4258:  MOVFF  21,01
425C:  MOVFF  20,00
4260:  MOVLW  01
4262:  ADDWF  20,F
4264:  BTFSC  FD8.0
4266:  INCF   21,F
4268:  BTFSC  FD8.2
426A:  INCF   22,F
426C:  BTFSC  FD8.2
426E:  INCF   23,F
4270:  MOVFF  01,ABA
4274:  MOVFF  00,AB9
4278:  MOVFF  01,AC8
427C:  MOVFF  00,AC7
4280:  MOVFF  102,AC9
4284:  RCALL  3E74
....................          write_ext_eeprom((long int)ptr_card++,sec);           
4286:  MOVFF  23,03
428A:  MOVFF  22,02
428E:  MOVFF  21,01
4292:  MOVFF  20,00
4296:  MOVLW  01
4298:  ADDWF  20,F
429A:  BTFSC  FD8.0
429C:  INCF   21,F
429E:  BTFSC  FD8.2
42A0:  INCF   22,F
42A2:  BTFSC  FD8.2
42A4:  INCF   23,F
42A6:  MOVFF  01,ABA
42AA:  MOVFF  00,AB9
42AE:  MOVFF  01,AC8
42B2:  MOVFF  00,AC7
42B6:  MOVFF  103,AC9
42BA:  RCALL  3E74
....................          for(countbit=0;countbit<numbyteoftrack1;countbit++) 
42BC:  MOVLB  9
42BE:  CLRF   xA5
42C0:  CLRF   xA4
42C2:  MOVF   xA5,F
42C4:  BNZ   4322
42C6:  MOVF   xA4,W
42C8:  SUBLW  4E
42CA:  BNC   4322
....................          { 
....................             //fputc(Track1[countbit]+0x20,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track1[countbit]&0b00111111)+0x20)); //(((Track1[countbit]&0b00111111)+0x20)) 
42CC:  MOVFF  23,03
42D0:  MOVFF  22,02
42D4:  MOVFF  21,01
42D8:  MOVFF  20,00
42DC:  MOVLW  01
42DE:  ADDWF  20,F
42E0:  BTFSC  FD8.0
42E2:  INCF   21,F
42E4:  BTFSC  FD8.2
42E6:  INCF   22,F
42E8:  BTFSC  FD8.2
42EA:  INCF   23,F
42EC:  MOVFF  01,ABA
42F0:  MOVFF  00,AB9
42F4:  MOVLW  A0
42F6:  ADDWF  xA4,W
42F8:  MOVWF  FE9
42FA:  MOVLW  04
42FC:  ADDWFC xA5,W
42FE:  MOVWF  FEA
4300:  MOVF   FEF,W
4302:  ANDLW  3F
4304:  ADDLW  20
4306:  MOVLB  A
4308:  MOVWF  xBB
430A:  MOVFF  01,AC8
430E:  MOVFF  00,AC7
4312:  MOVWF  xC9
4314:  MOVLB  0
4316:  RCALL  3E74
4318:  MOVLB  9
431A:  INCF   xA4,F
431C:  BTFSC  FD8.2
431E:  INCF   xA5,F
4320:  BRA    42C2
....................              
....................          } 
....................          del_buf(numbyteoftrack1,Track1); 
4322:  MOVLW  4F
4324:  MOVLB  A
4326:  MOVWF  xC5
4328:  MOVLW  04
432A:  MOVWF  xC7
432C:  MOVLW  A0
432E:  MOVWF  xC6
4330:  MOVLB  0
4332:  CALL   3A74
....................          for(countbit=0;countbit<numbyteoftrack2;countbit++) 
4336:  MOVLB  9
4338:  CLRF   xA5
433A:  CLRF   xA4
433C:  MOVF   xA5,F
433E:  BNZ   439C
4340:  MOVF   xA4,W
4342:  SUBLW  27
4344:  BNC   439C
....................          { 
....................             //fputc(Track2[countbit]+0x30,COM2); 
....................             write_ext_eeprom((long int)ptr_card++,((Track2[countbit]&0b00001111)+0x30));//putc(((Track2[countbit]&0b00001111)+0x30));     
4346:  MOVFF  23,03
434A:  MOVFF  22,02
434E:  MOVFF  21,01
4352:  MOVFF  20,00
4356:  MOVLW  01
4358:  ADDWF  20,F
435A:  BTFSC  FD8.0
435C:  INCF   21,F
435E:  BTFSC  FD8.2
4360:  INCF   22,F
4362:  BTFSC  FD8.2
4364:  INCF   23,F
4366:  MOVFF  01,ABA
436A:  MOVFF  00,AB9
436E:  MOVLW  EF
4370:  ADDWF  xA4,W
4372:  MOVWF  FE9
4374:  MOVLW  04
4376:  ADDWFC xA5,W
4378:  MOVWF  FEA
437A:  MOVF   FEF,W
437C:  ANDLW  0F
437E:  ADDLW  30
4380:  MOVLB  A
4382:  MOVWF  xBB
4384:  MOVFF  01,AC8
4388:  MOVFF  00,AC7
438C:  MOVWF  xC9
438E:  MOVLB  0
4390:  RCALL  3E74
4392:  MOVLB  9
4394:  INCF   xA4,F
4396:  BTFSC  FD8.2
4398:  INCF   xA5,F
439A:  BRA    433C
....................          }  
....................          del_buf(numbyteoftrack2,Track2); 
439C:  MOVLW  28
439E:  MOVLB  A
43A0:  MOVWF  xC5
43A2:  MOVLW  04
43A4:  MOVWF  xC7
43A6:  MOVLW  EF
43A8:  MOVWF  xC6
43AA:  MOVLB  0
43AC:  CALL   3A74
....................          /*for(countbit=0;countbit<key_numbyte;countbit++) 
....................          { 
....................             write_ext_eeprom((long int)ptr_card++,key_data[countbit]); 
....................          } 
....................          del_buf(key_numbyte,key_data);*/ 
....................       fprintf(COM2,"\r\n"); 
43B0:  MOVLW  0D
43B2:  MOVLB  A
43B4:  MOVWF  xDF
43B6:  MOVLB  0
43B8:  CALL   075A
43BC:  MOVLW  0A
43BE:  MOVLB  A
43C0:  MOVWF  xDF
43C2:  MOVLB  0
43C4:  CALL   075A
....................       fprintf(COM2,"Done"); 
43C8:  MOVLW  B4
43CA:  MOVWF  FF6
43CC:  MOVLW  06
43CE:  MOVWF  FF7
43D0:  CALL   07A0
....................       if(KP_mode) 
43D4:  MOVLB  1
43D6:  MOVF   x0F,F
43D8:  BZ    43F0
....................       { 
....................          printf("\n\rKey release\n\r"); 
43DA:  MOVLW  BA
43DC:  MOVWF  FF6
43DE:  MOVLW  06
43E0:  MOVWF  FF7
43E2:  MOVLB  0
43E4:  CALL   07A0
....................          keyprss_off; 
43E8:  BCF    F92.7
43EA:  BCF    F89.7
....................          kp_st=0; 
43EC:  MOVLB  1
43EE:  CLRF   x10
....................       }   
....................       count_kp=0xffff; 
43F0:  SETF   x12
43F2:  SETF   x11
....................       //key_press('B'); 
....................       fprintf(COM2,"\r\n"); 
43F4:  MOVLW  0D
43F6:  MOVLB  A
43F8:  MOVWF  xDF
43FA:  MOVLB  0
43FC:  CALL   075A
4400:  MOVLW  0A
4402:  MOVLB  A
4404:  MOVWF  xDF
4406:  MOVLB  0
4408:  CALL   075A
....................       fprintf(COM2,"Waiting for PIN number"); 
440C:  MOVLW  CA
440E:  MOVWF  FF6
4410:  MOVLW  06
4412:  MOVWF  FF7
4414:  CALL   07A0
....................       count_checking=0; 
4418:  MOVLB  1
441A:  CLRF   x07
441C:  CLRF   x06
....................       fprintf(COM2,"\r\n"); 
441E:  MOVLW  0D
4420:  MOVLB  A
4422:  MOVWF  xDF
4424:  MOVLB  0
4426:  CALL   075A
442A:  MOVLW  0A
442C:  MOVLB  A
442E:  MOVWF  xDF
4430:  MOVLB  0
4432:  CALL   075A
....................       charac_timeout=0; 
4436:  CLRF   xFC
4438:  CLRF   xFB
....................       //=========================== 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................       save_ptrcard(ptr_card,strobe_ptrcard_addr); 
443A:  MOVFF  23,ABC
443E:  MOVFF  22,ABB
4442:  MOVFF  21,ABA
4446:  MOVFF  20,AB9
444A:  MOVLW  19
444C:  MOVLB  A
444E:  MOVWF  xBD
4450:  MOVLB  0
4452:  RCALL  3F7A
....................       datinbuf=0; 
4454:  MOVLB  9
4456:  CLRF   xA6
....................       saving_flag=0; 
4458:  CLRF   xA9
....................       data_avai=1; 
445A:  MOVLW  01
445C:  MOVWF  xAA
....................       enable_getpin=1; 
445E:  MOVLB  1
4460:  MOVWF  x0C
....................       charac_timeout=0; 
4462:  MOVLB  0
4464:  CLRF   xFC
4466:  CLRF   xFB
....................       key_count_ms=0; 
4468:  MOVLB  1
446A:  CLRF   x0E
446C:  MOVLB  A
446E:  MOVLB  9
....................       //en_getpin; 
.................... //      countcard=countcard+1; 
.................... //      save_coutcard(countcard); 
....................       //fprintf(COM2,"  countcard=%lu\n\r",get_countcard()); 
....................    }//*/ 
4470:  MOVLB  0
4472:  GOTO   47DA (RETURN)
....................    //fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
.................... } 
.................... //========================= 
.................... int8 mcr_read() 
*
19B6:  MOVLW  01
19B8:  MOVLB  A
19BA:  MOVWF  xB3
19BC:  MOVWF  xB4
19BE:  MOVWF  xB5
19C0:  MOVWF  xB6
19C2:  CLRF   xB7
19C4:  MOVWF  xB8
19C6:  MOVWF  xB9
.................... { 
....................    int8  ST1      = 1; 
....................    int8  ST1_old  = 1; 
....................    int8  ST2      = 1; 
....................    int8  ST2_old  = 1; 
....................    int8  Bit_t2  = 0; 
....................    int8  error_T1=1; 
....................    int8  error_T2=1; 
....................    int16 i; 
....................    // Loop until a card is not present 
....................    card_timeout=0; 
19C8:  MOVLB  9
19CA:  CLRF   xA3
19CC:  CLRF   xA2
....................    mcr_timeout=0; 
19CE:  CLRF   x98
19D0:  CLRF   x97
19D2:  CLRF   x96
19D4:  CLRF   x95
....................     
....................    //charac_timeout=0;  
....................    while((card_timeout<65000)&&(input(MCR_DATA1)==1)&&(input(MCR_DATA2)==1)) 
19D6:  MOVF   xA3,W
19D8:  SUBLW  FD
19DA:  BNC   19F8
19DC:  BNZ   19E4
19DE:  MOVF   xA2,W
19E0:  SUBLW  E7
19E2:  BNC   19F8
19E4:  BSF    F93.1
19E6:  BTFSS  F81.1
19E8:  BRA    19F8
19EA:  BSF    F94.5
19EC:  BTFSS  F82.5
19EE:  BRA    19F8
....................    { 
....................       card_timeout++; 
19F0:  INCF   xA2,F
19F2:  BTFSC  FD8.2
19F4:  INCF   xA3,F
19F6:  BRA    19D6
....................    } 
....................    card_timeout=0; 
19F8:  CLRF   xA3
19FA:  CLRF   xA2
....................    buffertrack1[bug_countbit_T1++]=0; 
19FC:  MOVFF  99F,03
1A00:  MOVF   x9E,W
1A02:  INCF   x9E,F
1A04:  BTFSC  FD8.2
1A06:  INCF   x9F,F
1A08:  MOVLB  A
1A0A:  MOVWF  xBC
1A0C:  MOVLW  17
1A0E:  ADDWF  xBC,W
1A10:  MOVWF  FE9
1A12:  MOVLW  05
1A14:  ADDWFC 03,W
1A16:  MOVWF  FEA
1A18:  CLRF   FEF
....................    buffertrack1[bug_countbit_T1++]=1; 
1A1A:  MOVLB  9
1A1C:  MOVFF  99F,03
1A20:  MOVF   x9E,W
1A22:  INCF   x9E,F
1A24:  BTFSC  FD8.2
1A26:  INCF   x9F,F
1A28:  MOVLB  A
1A2A:  MOVWF  xBC
1A2C:  MOVLW  17
1A2E:  ADDWF  xBC,W
1A30:  MOVWF  FE9
1A32:  MOVLW  05
1A34:  ADDWFC 03,W
1A36:  MOVWF  FEA
1A38:  MOVLW  01
1A3A:  MOVWF  FEF
....................    buffertrack2[bug_countbit_T2++]=0; 
1A3C:  MOVLB  9
1A3E:  MOVFF  9A1,03
1A42:  MOVF   xA0,W
1A44:  INCF   xA0,F
1A46:  BTFSC  FD8.2
1A48:  INCF   xA1,F
1A4A:  MOVLB  A
1A4C:  MOVWF  xBC
1A4E:  MOVLW  69
1A50:  ADDWF  xBC,W
1A52:  MOVWF  FE9
1A54:  MOVLW  08
1A56:  ADDWFC 03,W
1A58:  MOVWF  FEA
1A5A:  CLRF   FEF
....................    buffertrack2[bug_countbit_T2++]=1;//*/ 
1A5C:  MOVLB  9
1A5E:  MOVFF  9A1,03
1A62:  MOVF   xA0,W
1A64:  INCF   xA0,F
1A66:  BTFSC  FD8.2
1A68:  INCF   xA1,F
1A6A:  MOVLB  A
1A6C:  MOVWF  xBC
1A6E:  MOVLW  69
1A70:  ADDWF  xBC,W
1A72:  MOVWF  FE9
1A74:  MOVLW  08
1A76:  ADDWFC 03,W
1A78:  MOVWF  FEA
1A7A:  MOVLW  01
1A7C:  MOVWF  FEF
....................    while(((bug_countbit_T1<numbyteofbuffer1)&&(bug_countbit_T2<numbyteofbuffer2))&&(card_timeout<65500)) 
1A7E:  MOVLB  9
1A80:  MOVF   x9F,W
1A82:  SUBLW  03
1A84:  BTFSS  FD8.0
1A86:  BRA    1B66
1A88:  BNZ   1A92
1A8A:  MOVF   x9E,W
1A8C:  SUBLW  51
1A8E:  BTFSS  FD8.0
1A90:  BRA    1B66
1A92:  MOVF   xA1,W
1A94:  SUBLW  01
1A96:  BTFSS  FD8.0
1A98:  BRA    1B66
1A9A:  BNZ   1AA2
1A9C:  MOVF   xA0,W
1A9E:  SUBLW  2B
1AA0:  BNC   1B66
1AA2:  MOVF   xA3,W
1AA4:  SUBLW  FF
1AA6:  BNC   1B66
1AA8:  BNZ   1AB0
1AAA:  MOVF   xA2,W
1AAC:  SUBLW  DB
1AAE:  BNC   1B66
....................    { 
....................       // Check for NULL pointer and an index less than 79 
....................          // Get strobe number one 
....................          if(count_reading_error>0) 
1AB0:  MOVF   xAC,F
1AB2:  BZ    1ABC
....................          { 
....................             bug_countbit_T1=0; 
1AB4:  CLRF   x9F
1AB6:  CLRF   x9E
....................             bug_countbit_T2=0; 
1AB8:  CLRF   xA1
1ABA:  CLRF   xA0
....................          } 
....................          card_timeout++; 
1ABC:  INCF   xA2,F
1ABE:  BTFSC  FD8.2
1AC0:  INCF   xA3,F
....................          mcr_timeout=0; 
1AC2:  CLRF   x98
1AC4:  CLRF   x97
1AC6:  CLRF   x96
1AC8:  CLRF   x95
....................          //charac_timeout=0; 
....................          ST1 = input(MCR_STROBE1); 
1ACA:  BSF    F93.2
1ACC:  MOVLB  A
1ACE:  CLRF   xB3
1AD0:  BTFSC  F81.2
1AD2:  INCF   xB3,F
....................          // If the strobe was high and is now low (falling edge), 
....................          // then data is present 
....................          
....................          if(ST1 == 0 && ST1_old == 1) 
1AD4:  MOVF   xB3,F
1AD6:  BNZ   1B14
1AD8:  DECFSZ xB4,W
1ADA:  BRA    1B14
....................          { 
....................             ST1_old = 0; 
1ADC:  CLRF   xB4
....................             buffertrack1[bug_countbit_T1] = !input(MCR_DATA1); 
1ADE:  MOVLW  17
1AE0:  MOVLB  9
1AE2:  ADDWF  x9E,W
1AE4:  MOVWF  FE9
1AE6:  MOVLW  05
1AE8:  ADDWFC x9F,W
1AEA:  MOVWF  FEA
1AEC:  BSF    F93.1
1AEE:  MOVLW  00
1AF0:  BTFSS  F81.1
1AF2:  MOVLW  01
1AF4:  MOVWF  FEF
....................             buffertrack2[bug_countbit_T2] = Bit_t2; 
1AF6:  MOVLW  69
1AF8:  ADDWF  xA0,W
1AFA:  MOVWF  FE9
1AFC:  MOVLW  08
1AFE:  ADDWFC xA1,W
1B00:  MOVWF  FEA
1B02:  MOVFF  AB7,FEF
....................             /*if(countbit_T1<100) 
....................             { 
....................                if(buffertrack1[countbit_T1]==1) countbit_zero_t1=0; 
....................                else countbit_zero_t1++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T1++; 
1B06:  INCF   x9E,F
1B08:  BTFSC  FD8.2
1B0A:  INCF   x9F,F
....................             card_timeout=0; 
1B0C:  CLRF   xA3
1B0E:  CLRF   xA2
....................          } 
1B10:  BRA    1B1E
1B12:  MOVLB  A
....................          else if(ST1 == 1)ST1_old = 1; 
1B14:  DECFSZ xB3,W
1B16:  BRA    1B1C
1B18:  MOVLW  01
1B1A:  MOVWF  xB4
1B1C:  MOVLB  9
....................          // Get strobe number 2 
....................          ST2 = input(MCR_STROBE2); 
1B1E:  BSF    F93.3
1B20:  MOVLB  A
1B22:  CLRF   xB5
1B24:  BTFSC  F81.3
1B26:  INCF   xB5,F
....................          if(ST2 == 0 && ST2_old == 1) 
1B28:  MOVF   xB5,F
1B2A:  BNZ   1B4A
1B2C:  DECFSZ xB6,W
1B2E:  BRA    1B4A
....................          { 
....................             ST2_old = 0; 
1B30:  CLRF   xB6
....................             Bit_t2 = !input(MCR_DATA2); 
1B32:  BSF    F94.5
1B34:  CLRF   xB7
1B36:  BTFSS  F82.5
1B38:  INCF   xB7,F
....................             //buffertrack2[countbit_T2]=!input(MCR_DATA2); 
....................             /*if(countbit_T2<100) 
....................             { 
....................                if(Bit_t2==1)countbit_zero_t2=0; 
....................                else countbit_zero_t2++; 
....................             } 
....................             //*/ 
....................             bug_countbit_T2++; 
1B3A:  MOVLB  9
1B3C:  INCF   xA0,F
1B3E:  BTFSC  FD8.2
1B40:  INCF   xA1,F
....................             card_timeout=0; 
1B42:  CLRF   xA3
1B44:  CLRF   xA2
....................          } 
1B46:  BRA    1B54
1B48:  MOVLB  A
....................          else if(ST2 == 1)ST2_old = 1;//*/ 
1B4A:  DECFSZ xB5,W
1B4C:  BRA    1B52
1B4E:  MOVLW  01
1B50:  MOVWF  xB6
1B52:  MOVLB  9
....................          if(input(MCR_CARD_PRESENT)==1)//break; 
1B54:  BSF    F93.0
1B56:  BTFSS  F81.0
1B58:  BRA    1B64
....................          { 
....................             //fprintf(COM2,"end card=%lu\r\n",card_timeout); 
....................             count_reading_error=0; 
1B5A:  CLRF   xAC
....................             card_timeout=65500; 
1B5C:  SETF   xA3
1B5E:  MOVLW  DC
1B60:  MOVWF  xA2
....................             break;            
1B62:  BRA    1B66
....................          } 
1B64:  BRA    1A80
....................       } 
....................        
....................       //fprintf(COM2,"\r\nreading done\r\n"); 
....................       card_timeout=0; 
1B66:  CLRF   xA3
1B68:  CLRF   xA2
....................       error_T1 = detect_pos_st(0,bug_countbit_T1,buffertrack1); 
1B6A:  MOVLB  A
1B6C:  CLRF   xC5
1B6E:  MOVFF  99F,AC7
1B72:  MOVFF  99E,AC6
1B76:  MOVLW  05
1B78:  MOVWF  xC9
1B7A:  MOVLW  17
1B7C:  MOVWF  xC8
1B7E:  MOVLB  0
1B80:  CALL   0B16
1B84:  MOVFF  01,AB8
....................       error_T2 = detect_pos_st(1,bug_countbit_T2,buffertrack2); 
1B88:  MOVLW  01
1B8A:  MOVLB  A
1B8C:  MOVWF  xC5
1B8E:  MOVFF  9A1,AC7
1B92:  MOVFF  9A0,AC6
1B96:  MOVLW  08
1B98:  MOVWF  xC9
1B9A:  MOVLW  69
1B9C:  MOVWF  xC8
1B9E:  MOVLB  0
1BA0:  CALL   0B16
1BA4:  MOVFF  01,AB9
....................       //#if defined(debug) 
....................       if(debugmode==1) 
1BA8:  MOVLB  9
1BAA:  DECFSZ xA7,W
1BAC:  BRA    1C4E
....................       { 
....................          fprintf(COM2,"\r\ncountbit_T1:%lu\r\n",bug_countbit_T1); 
1BAE:  MOVLW  E2
1BB0:  MOVWF  FF6
1BB2:  MOVLW  06
1BB4:  MOVWF  FF7
1BB6:  MOVLW  0E
1BB8:  MOVLB  A
1BBA:  MOVWF  xD3
1BBC:  MOVLB  0
1BBE:  RCALL  1718
1BC0:  MOVLW  10
1BC2:  MOVWF  FE9
1BC4:  MOVFF  99F,ABD
1BC8:  MOVFF  99E,ABC
1BCC:  RCALL  1742
1BCE:  MOVLW  0D
1BD0:  MOVLB  A
1BD2:  MOVWF  xDF
1BD4:  MOVLB  0
1BD6:  CALL   075A
1BDA:  MOVLW  0A
1BDC:  MOVLB  A
1BDE:  MOVWF  xDF
1BE0:  MOVLB  0
1BE2:  CALL   075A
....................          fprintf(COM2,"\r\ncountbit_T2:%lu\r\n",bug_countbit_T2); 
1BE6:  MOVLW  F6
1BE8:  MOVWF  FF6
1BEA:  MOVLW  06
1BEC:  MOVWF  FF7
1BEE:  MOVLW  0E
1BF0:  MOVLB  A
1BF2:  MOVWF  xD3
1BF4:  MOVLB  0
1BF6:  RCALL  1718
1BF8:  MOVLW  10
1BFA:  MOVWF  FE9
1BFC:  MOVFF  9A1,ABD
1C00:  MOVFF  9A0,ABC
1C04:  RCALL  1742
1C06:  MOVLW  0D
1C08:  MOVLB  A
1C0A:  MOVWF  xDF
1C0C:  MOVLB  0
1C0E:  CALL   075A
1C12:  MOVLW  0A
1C14:  MOVLB  A
1C16:  MOVWF  xDF
1C18:  MOVLB  0
1C1A:  CALL   075A
....................          debug_reader();       
1C1E:  BRA    18FA
....................          if(error_T1==0)fprintf(COM2,"\r\nreading error T1\r\n"); 
1C20:  MOVLB  A
1C22:  MOVF   xB8,F
1C24:  BNZ   1C36
1C26:  MOVLW  0A
1C28:  MOVWF  FF6
1C2A:  MOVLW  07
1C2C:  MOVWF  FF7
1C2E:  MOVLB  0
1C30:  CALL   07A0
1C34:  MOVLB  A
....................          if(error_T2==0)fprintf(COM2,"\r\nreading error T2\r\n"); 
1C36:  MOVF   xB9,F
1C38:  BNZ   1C4A
1C3A:  MOVLW  20
1C3C:  MOVWF  FF6
1C3E:  MOVLW  07
1C40:  MOVWF  FF7
1C42:  MOVLB  0
1C44:  CALL   07A0
1C48:  MOVLB  A
....................       } 
1C4A:  BRA    1C5A
1C4C:  MOVLB  9
....................          else 
....................          { 
....................             //for(i=0;i<3000;i++); 
....................             delay_ms(15); 
1C4E:  MOVLW  0F
1C50:  MOVLB  A
1C52:  MOVWF  xBC
1C54:  MOVLB  0
1C56:  RCALL  198E
1C58:  MOVLB  A
....................          } 
....................       //#endif      
....................       if((error_T1==0)||(error_T2==0)) 
1C5A:  MOVF   xB8,F
1C5C:  BZ    1C62
1C5E:  MOVF   xB9,F
1C60:  BNZ   1C82
....................       { 
....................          //charac_timeout=5000; 
....................         // memset(buffertrack1, 0, sizeof(buffertrack1));    
....................          //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................          bug_countbit_T2=0; 
1C62:  MOVLB  9
1C64:  CLRF   xA1
1C66:  CLRF   xA0
....................          bug_countbit_T1=0; 
1C68:  CLRF   x9F
1C6A:  CLRF   x9E
....................          reading_fg=0; 
1C6C:  CLRF   xAB
....................          count_reading_error++; 
1C6E:  INCF   xAC,F
....................          //fprintf(COM2,"\r\nreading error=%d\r\n",count_reading_error); 
....................          mcr_timeout=0; 
1C70:  CLRF   x98
1C72:  CLRF   x97
1C74:  CLRF   x96
1C76:  CLRF   x95
....................          //charac_timeout=0xffffffff; // can kiem tra them 
....................          return 0;       
1C78:  MOVLW  00
1C7A:  MOVWF  01
1C7C:  BRA    1CBA
....................       } 
1C7E:  BRA    1CB6
1C80:  MOVLB  A
....................          else  
....................          { 
....................             //copybuf2temp(); 
....................             datinbuf=1; 
1C82:  MOVLW  01
1C84:  MOVLB  9
1C86:  MOVWF  xA6
....................             reading_fg=1; 
1C88:  MOVWF  xAB
....................             //saving_card(); 
....................             countbit_T2=bug_countbit_T2; 
1C8A:  MOVFF  9A1,99D
1C8E:  MOVFF  9A0,99C
....................             countbit_T1=bug_countbit_T1; 
1C92:  MOVFF  99F,99B
1C96:  MOVFF  99E,99A
....................              
....................             //memset(buffertrack1, 0, sizeof(buffertrack1));    
....................             //memset(buffertrack2, 0, sizeof(buffertrack2)); 
....................             bug_countbit_T1=0; 
1C9A:  CLRF   x9F
1C9C:  CLRF   x9E
....................             bug_countbit_T2=0;  
1C9E:  CLRF   xA1
1CA0:  CLRF   xA0
....................             mcr_timeout=0; 
1CA2:  CLRF   x98
1CA4:  CLRF   x97
1CA6:  CLRF   x96
1CA8:  CLRF   x95
....................             charac_timeout=0; 
1CAA:  MOVLB  0
1CAC:  CLRF   xFC
1CAE:  CLRF   xFB
....................             return 1; 
1CB0:  MOVWF  01
1CB2:  MOVLB  9
1CB4:  BRA    1CBA
....................          } 
....................    
.................... // Return any errors 
....................    return 0; 
1CB6:  MOVLW  00
1CB8:  MOVWF  01
1CBA:  MOVLB  0
1CBC:  GOTO   1D28 (RETURN)
.................... } 
.................... //========================= 
.................... #INT_EXT1 
.................... void read_card_T1() 
.................... { 
....................       //disable_interrupts(GLOBAL); 
....................       delay_us(500); 
1CC0:  MOVLW  02
1CC2:  MOVLB  A
1CC4:  MOVWF  xB3
1CC6:  MOVLW  FA
1CC8:  MOVWF  xB4
1CCA:  MOVLB  0
1CCC:  CALL   0736
1CD0:  MOVLB  A
1CD2:  DECFSZ xB3,F
1CD4:  BRA    1CC6
....................    //if(input(MCR_STROBE1)==0) 
....................    //{ 
....................       if(saving_flag==1) return;      
1CD6:  MOVLB  9
1CD8:  DECFSZ xA9,W
1CDA:  BRA    1CDE
1CDC:  BRA    1D3A
....................       if((KP_mode)&&(enable_getpin==0)&&(booting==1)) 
1CDE:  MOVLB  1
1CE0:  MOVF   x0F,F
1CE2:  BZ    1D24
1CE4:  MOVF   x0C,F
1CE6:  BNZ   1D24
1CE8:  DECFSZ x05,W
1CEA:  BRA    1D24
....................       { 
....................          if(kp_st==1) 
1CEC:  DECFSZ x10,W
1CEE:  BRA    1D08
....................          { 
....................             printf("\n\rKey release.\n\r"); 
1CF0:  MOVLW  42
1CF2:  MOVWF  FF6
1CF4:  MOVLW  1D
1CF6:  MOVWF  FF7
1CF8:  MOVLB  0
1CFA:  CALL   07A0
....................             keyprss_off; 
1CFE:  BCF    F92.7
1D00:  BCF    F89.7
....................             kp_st=0; 
1D02:  MOVLB  1
1D04:  CLRF   x10
....................          } 
1D06:  BRA    1D24
....................          else 
....................          { 
....................             printf("\n\rKey press.\n\r"); 
1D08:  MOVLW  54
1D0A:  MOVWF  FF6
1D0C:  MOVLW  1D
1D0E:  MOVWF  FF7
1D10:  MOVLB  0
1D12:  CALL   07A0
....................             keyprss_on; 
1D16:  BCF    F92.7
1D18:  BSF    F89.7
....................             kp_st=1;  
1D1A:  MOVLW  01
1D1C:  MOVLB  1
1D1E:  MOVWF  x10
....................             count_kp=0; 
1D20:  CLRF   x12
1D22:  CLRF   x11
....................          } 
....................       } 
....................       cardread_st=mcr_read(); 
1D24:  MOVLB  0
1D26:  BRA    19B6
1D28:  MOVFF  01,9A8
....................       //enable_getpin=0; 
....................       mcr_timeout=0; 
1D2C:  MOVLB  9
1D2E:  CLRF   x98
1D30:  CLRF   x97
1D32:  CLRF   x96
1D34:  CLRF   x95
....................       card_timeout=0; 
1D36:  CLRF   xA3
1D38:  CLRF   xA2
....................       /*if(KP_mode) 
....................       { 
....................          printf("\n\rKey release\n\r"); 
....................          keyprss_off; 
....................       } */      
....................       //charac_timeout=0; 
....................       //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................       //enable_interrupts(GLOBAL); 
....................   // } 
1D3A:  BCF    FF0.0
1D3C:  MOVLB  0
1D3E:  GOTO   0084
.................... } 
.................... //==================================== 
.................... void debug_card() 
.................... { 
....................    int8 i; 
....................    int16 j; 
....................    con_data_track(0,countbit_T1,buffertrack1,Track1); 
....................    countbit_T1=0; 
....................    con_data_track(1,countbit_T2,buffertrack2,Track2); 
....................    countbit_T2=0; 
....................    for(j=0;j<700;j++) buffertrack1[j]=0; 
....................    for(j=0;j<300;j++) buffertrack2[j]=0; 
....................    fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack1;i++) 
....................    { 
....................       fputc(Track1[i]+0x20,COM2); 
....................    } 
....................    fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
....................    for(i=0;i<numbyteoftrack2;i++) 
....................    { 
....................       fputc(Track2[i]+0x30,COM2); 
....................    } 
.................... } 
.................... //==================================== 
....................  
.................... #include "mode.c" 
....................  
.................... #define LOGOFF                0 
.................... #define LOGON                 1 
.................... #define get_data              2 
.................... #define changer_pass          3 
.................... //============================== 
....................  
.................... int8 mode=0; 
.................... int8 ee_dat=0; 
.................... int16 count_card=1,count_card_tg=0; 
.................... int8 mode_sl=0; 
.................... int32 addr_key=0; 
.................... char console[16]; 
.................... //=============================== 
.................... void rstfact() 
*
5A54:  CLRF   19
5A56:  BTFSC  FF2.7
5A58:  BSF    19.7
5A5A:  BCF    FF2.7
.................... { 
....................    write_ext_eeprom(strobe_delaytime,3);  
5A5C:  MOVLB  A
5A5E:  CLRF   xC8
5A60:  MOVLW  94
5A62:  MOVWF  xC7
5A64:  MOVLW  03
5A66:  MOVWF  xC9
5A68:  MOVLB  0
5A6A:  CALL   3E74
5A6E:  BTFSC  19.7
5A70:  BSF    FF2.7
5A72:  CLRF   19
5A74:  BTFSC  FF2.7
5A76:  BSF    19.7
5A78:  BCF    FF2.7
....................    delaycharaction=read_ext_eeprom(strobe_delaytime); 
5A7A:  MOVLB  A
5A7C:  CLRF   xC0
5A7E:  MOVLW  94
5A80:  MOVWF  xBF
5A82:  MOVLB  0
5A84:  CALL   395A
5A88:  BTFSC  19.7
5A8A:  BSF    FF2.7
5A8C:  MOVFF  01,146
....................    fprintf(COM2,"tran time = %d\n\r",delaycharaction);   
5A90:  MOVLW  88
5A92:  MOVWF  FF6
5A94:  MOVLW  1D
5A96:  MOVWF  FF7
5A98:  CLRF   19
5A9A:  BTFSC  FF2.7
5A9C:  BSF    19.7
5A9E:  BCF    FF2.7
5AA0:  MOVLW  0C
5AA2:  MOVLB  A
5AA4:  MOVWF  xD3
5AA6:  MOVLB  0
5AA8:  CALL   1718
5AAC:  BTFSC  19.7
5AAE:  BSF    FF2.7
5AB0:  CLRF   19
5AB2:  BTFSC  FF2.7
5AB4:  BSF    19.7
5AB6:  BCF    FF2.7
5AB8:  MOVFF  146,ABF
5ABC:  MOVLW  18
5ABE:  MOVLB  A
5AC0:  MOVWF  xC0
5AC2:  MOVLB  0
5AC4:  CALL   1836
5AC8:  BTFSC  19.7
5ACA:  BSF    FF2.7
5ACC:  CLRF   19
5ACE:  BTFSC  FF2.7
5AD0:  BSF    19.7
5AD2:  BCF    FF2.7
5AD4:  MOVLW  0A
5AD6:  MOVLB  A
5AD8:  MOVWF  xDF
5ADA:  MOVLB  0
5ADC:  CALL   075A
5AE0:  BTFSC  19.7
5AE2:  BSF    FF2.7
5AE4:  CLRF   19
5AE6:  BTFSC  FF2.7
5AE8:  BSF    19.7
5AEA:  BCF    FF2.7
5AEC:  MOVLW  0D
5AEE:  MOVLB  A
5AF0:  MOVWF  xDF
5AF2:  MOVLB  0
5AF4:  CALL   075A
5AF8:  BTFSC  19.7
5AFA:  BSF    FF2.7
5AFC:  CLRF   19
5AFE:  BTFSC  FF2.7
5B00:  BSF    19.7
5B02:  BCF    FF2.7
....................  
....................    write_ext_eeprom(strobe_keypressmode,0); 
5B04:  MOVLB  A
5B06:  CLRF   xC8
5B08:  MOVLW  7F
5B0A:  MOVWF  xC7
5B0C:  CLRF   xC9
5B0E:  MOVLB  0
5B10:  CALL   3E74
5B14:  BTFSC  19.7
5B16:  BSF    FF2.7
5B18:  CLRF   19
5B1A:  BTFSC  FF2.7
5B1C:  BSF    19.7
5B1E:  BCF    FF2.7
....................    KP_mode=read_ext_eeprom(strobe_keypressmode); 
5B20:  MOVLB  A
5B22:  CLRF   xC0
5B24:  MOVLW  7F
5B26:  MOVWF  xBF
5B28:  MOVLB  0
5B2A:  CALL   395A
5B2E:  BTFSC  19.7
5B30:  BSF    FF2.7
5B32:  MOVFF  01,10F
....................    if(KP_mode) printf("KP-> Keypress mode setting (On)\n\r"); 
5B36:  MOVLB  1
5B38:  MOVF   x0F,F
5B3A:  BZ    5B5A
5B3C:  MOVLW  9A
5B3E:  MOVWF  FF6
5B40:  MOVLW  1D
5B42:  MOVWF  FF7
5B44:  CLRF   19
5B46:  BTFSC  FF2.7
5B48:  BSF    19.7
5B4A:  BCF    FF2.7
5B4C:  MOVLB  0
5B4E:  CALL   07A0
5B52:  BTFSC  19.7
5B54:  BSF    FF2.7
5B56:  BRA    5B74
5B58:  MOVLB  1
....................    else printf("KP-> Keypress mode setting (Off)\n\r"); 
5B5A:  MOVLW  BC
5B5C:  MOVWF  FF6
5B5E:  MOVLW  1D
5B60:  MOVWF  FF7
5B62:  CLRF   19
5B64:  BTFSC  FF2.7
5B66:  BSF    19.7
5B68:  BCF    FF2.7
5B6A:  MOVLB  0
5B6C:  CALL   07A0
5B70:  BTFSC  19.7
5B72:  BSF    FF2.7
5B74:  CLRF   19
5B76:  BTFSC  FF2.7
5B78:  BSF    19.7
5B7A:  BCF    FF2.7
....................  
....................    write_ext_eeprom(strobe_Master_SLV,1);    
5B7C:  MOVLB  A
5B7E:  CLRF   xC8
5B80:  MOVLW  91
5B82:  MOVWF  xC7
5B84:  MOVLW  01
5B86:  MOVWF  xC9
5B88:  MOVLB  0
5B8A:  CALL   3E74
5B8E:  BTFSC  19.7
5B90:  BSF    FF2.7
5B92:  CLRF   19
5B94:  BTFSC  FF2.7
5B96:  BSF    19.7
5B98:  BCF    FF2.7
....................    mode_sl=read_ext_eeprom(strobe_Master_SLV); 
5B9A:  MOVLB  A
5B9C:  CLRF   xC0
5B9E:  MOVLW  91
5BA0:  MOVWF  xBF
5BA2:  MOVLB  0
5BA4:  CALL   395A
5BA8:  BTFSC  19.7
5BAA:  BSF    FF2.7
5BAC:  MOVFF  01,9B3
....................    if(mode_sl) printf("Is Slave mode\n\r"); 
5BB0:  MOVLB  9
5BB2:  MOVF   xB3,F
5BB4:  BZ    5BD4
5BB6:  MOVLW  E0
5BB8:  MOVWF  FF6
5BBA:  MOVLW  1D
5BBC:  MOVWF  FF7
5BBE:  CLRF   19
5BC0:  BTFSC  FF2.7
5BC2:  BSF    19.7
5BC4:  BCF    FF2.7
5BC6:  MOVLB  0
5BC8:  CALL   07A0
5BCC:  BTFSC  19.7
5BCE:  BSF    FF2.7
5BD0:  BRA    5BEE
5BD2:  MOVLB  9
....................    else printf("Is Master mode)\n\r"); 
5BD4:  MOVLW  F0
5BD6:  MOVWF  FF6
5BD8:  MOVLW  1D
5BDA:  MOVWF  FF7
5BDC:  CLRF   19
5BDE:  BTFSC  FF2.7
5BE0:  BSF    19.7
5BE2:  BCF    FF2.7
5BE4:  MOVLB  0
5BE6:  CALL   07A0
5BEA:  BTFSC  19.7
5BEC:  BSF    FF2.7
5BEE:  CLRF   19
5BF0:  BTFSC  FF2.7
5BF2:  BSF    19.7
5BF4:  BCF    FF2.7
....................     
....................    write_ext_eeprom(kindofKB,1); 
5BF6:  MOVLB  A
5BF8:  CLRF   xC8
5BFA:  MOVLW  7E
5BFC:  MOVWF  xC7
5BFE:  MOVLW  01
5C00:  MOVWF  xC9
5C02:  MOVLB  0
5C04:  CALL   3E74
5C08:  BTFSC  19.7
5C0A:  BSF    FF2.7
5C0C:  CLRF   19
5C0E:  BTFSC  FF2.7
5C10:  BSF    19.7
5C12:  BCF    FF2.7
....................    type_KB = read_ext_eeprom(kindofKB); 
5C14:  MOVLB  A
5C16:  CLRF   xC0
5C18:  MOVLW  7E
5C1A:  MOVWF  xBF
5C1C:  MOVLB  0
5C1E:  CALL   395A
5C22:  BTFSC  19.7
5C24:  BSF    FF2.7
5C26:  MOVFF  01,113
....................    if(type_KB) printf("Is 4x6 matrix\n\r"); 
5C2A:  MOVLB  1
5C2C:  MOVF   x13,F
5C2E:  BZ    5C4E
5C30:  MOVLW  02
5C32:  MOVWF  FF6
5C34:  MOVLW  1E
5C36:  MOVWF  FF7
5C38:  CLRF   19
5C3A:  BTFSC  FF2.7
5C3C:  BSF    19.7
5C3E:  BCF    FF2.7
5C40:  MOVLB  0
5C42:  CALL   07A0
5C46:  BTFSC  19.7
5C48:  BSF    FF2.7
5C4A:  BRA    5C68
5C4C:  MOVLB  1
....................    else printf("Is 4x5 matrix\n\r"); 
5C4E:  MOVLW  12
5C50:  MOVWF  FF6
5C52:  MOVLW  1E
5C54:  MOVWF  FF7
5C56:  CLRF   19
5C58:  BTFSC  FF2.7
5C5A:  BSF    19.7
5C5C:  BCF    FF2.7
5C5E:  MOVLB  0
5C60:  CALL   07A0
5C64:  BTFSC  19.7
5C66:  BSF    FF2.7
....................     
....................    ptr_card=ptr_start; 
5C68:  CLRF   23
5C6A:  CLRF   22
5C6C:  CLRF   21
5C6E:  MOVLW  96
5C70:  MOVWF  20
....................    ptr_card_key=EEPROM_KEY_ST; 
5C72:  CLRF   27
5C74:  CLRF   26
5C76:  MOVLW  AA
5C78:  MOVWF  25
5C7A:  MOVLW  47
5C7C:  MOVWF  24
5C7E:  CLRF   19
5C80:  BTFSC  FF2.7
5C82:  BSF    19.7
5C84:  BCF    FF2.7
....................    save_ptrcard(ptr_card,strobe_ptrcard_addr); 
5C86:  MOVFF  23,ABC
5C8A:  MOVFF  22,ABB
5C8E:  MOVFF  21,ABA
5C92:  MOVFF  20,AB9
5C96:  MOVLW  19
5C98:  MOVLB  A
5C9A:  MOVWF  xBD
5C9C:  MOVLB  0
5C9E:  CALL   3F7A
5CA2:  BTFSC  19.7
5CA4:  BSF    FF2.7
5CA6:  CLRF   19
5CA8:  BTFSC  FF2.7
5CAA:  BSF    19.7
5CAC:  BCF    FF2.7
....................    save_ptrcard(ptr_card_key,strobe_ptrcard_key); 
5CAE:  MOVFF  27,ABC
5CB2:  MOVFF  26,ABB
5CB6:  MOVFF  25,ABA
5CBA:  MOVFF  24,AB9
5CBE:  MOVLW  1E
5CC0:  MOVLB  A
5CC2:  MOVWF  xBD
5CC4:  MOVLB  0
5CC6:  CALL   3F7A
5CCA:  BTFSC  19.7
5CCC:  BSF    FF2.7
5CCE:  CLRF   19
5CD0:  BTFSC  FF2.7
5CD2:  BSF    19.7
5CD4:  BCF    FF2.7
....................    save_coutcard(0); 
5CD6:  MOVLB  A
5CD8:  CLRF   xB7
5CDA:  CLRF   xB6
5CDC:  MOVLB  0
5CDE:  CALL   45E4
5CE2:  BTFSC  19.7
5CE4:  BSF    FF2.7
5CE6:  CLRF   19
5CE8:  BTFSC  FF2.7
5CEA:  BSF    19.7
5CEC:  BCF    FF2.7
....................    #if defined(SIM900) 
....................       write_ext_eeprom(strobe_autosending,0);      
5CEE:  MOVLB  A
5CF0:  CLRF   xC8
5CF2:  MOVLW  93
5CF4:  MOVWF  xC7
5CF6:  CLRF   xC9
5CF8:  MOVLB  0
5CFA:  CALL   3E74
5CFE:  BTFSC  19.7
5D00:  BSF    FF2.7
5D02:  CLRF   19
5D04:  BTFSC  FF2.7
5D06:  BSF    19.7
5D08:  BCF    FF2.7
....................       auto_sending=read_ext_eeprom(strobe_autosending);  
5D0A:  MOVLB  A
5D0C:  CLRF   xC0
5D0E:  MOVLW  93
5D10:  MOVWF  xBF
5D12:  MOVLB  0
5D14:  CALL   395A
5D18:  BTFSC  19.7
5D1A:  BSF    FF2.7
5D1C:  MOVFF  01,499
....................    #endif 
5D20:  GOTO   834C (RETURN)
.................... } 
.................... //================================ 
.................... void adminmode() 
.................... { 
....................    int8 index,i; 
....................    int8 temp[50]; 
....................        
....................       //printf("Admin>"); 
....................       printf("%s>",console); 
....................       #if defined(SIM900) 
....................          SIM_state=config; 
....................       #endif    
....................       USART_getstring(EN_ECHO,20,buffer_uart); 
....................       printf("\n\r"); 
....................       strcpy(buffer2,"d"); 
....................       index=0; 
....................       ee_dat=0; 
....................       count_card=1; 
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
....................       { 
....................          unsigned long adr=0; 
....................          //unsigned int count=0; 
....................          rec[0]=0; 
....................          count_card_tg=get_countcard(); 
....................          adr=count_card*numdata; 
....................          addr_key=EEPROM_KEY_ST; 
....................          while(count_card<=count_card_tg) 
....................          { 
....................             adr=count_card*numdata+ptr_start; 
....................             I2CEEPROM_read((unsigned int16)(adr-numdata),numdata,rec); 
....................             fprintf(COM2,"%ld)%02i/%02i %02i:%02i:%02i",count_card,rec[0],rec[1],rec[2],rec[3],rec[4]); 
....................             ee_dat=0; 
....................             index=0; 
....................             fprintf(COM2,"\r\nTrack1 Data:\r\n"); 
....................             while((index<numbyteoftrack1)&&(ee_dat!='?')) 
....................             { 
....................                ee_dat = rec[index+5]; 
....................                if((ee_dat>31)&&(ee_dat<127))fputc(ee_dat,COM2); 
....................                index++; 
....................                if(ee_dat==0)break; 
....................             } 
....................             fprintf(COM2,"\r\nTrack2 Data:\r\n"); 
....................             index=0; 
....................             ee_dat=0; 
....................             while((index<numbyteoftrack2) && (ee_dat!='?')) 
....................             { 
....................                ee_dat = rec[index+5+numbyteoftrack1]; 
....................                if((ee_dat>31)&&(ee_dat<127)) fputc(ee_dat,COM2); 
....................                index++; 
....................                if(ee_dat==0)break; 
....................             } 
....................             index=0; 
....................             //ee_dat=0; 
....................     
....................             //I2CEEPROM_read((unsigned int16)(addr_key),key_numbyte,temp); 
....................             fprintf(COM2,"\r\nPIN Number:\r\n"); 
....................             if(ptr_card_key>addr_key) 
....................             { 
....................                i=0; 
....................                //fprintf(COM2,"%02i/%02i %02i:%02i:%02i -> ",read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++),read_ext_eeprom(addr_key+i++)); 
....................                do 
....................                //for(i=0;i<key_numbyte;i++) 
....................                { 
....................                   ee_dat=read_ext_eeprom(i+addr_key); 
....................                   if(((ee_dat>47)&&(ee_dat<58))||((ee_dat=='#')||(ee_dat=='*'))||(ee_dat>64)&&(ee_dat<91)) 
....................                      fputc(ee_dat,COM2); 
....................                   i++; 
....................                } 
....................                while((i<key_numbyte)&&(ee_dat!=0)); 
....................                //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................                addr_key=addr_key+50; 
....................                fprintf(COM2,"\n\r"); 
....................             } 
....................             count_card++; 
....................          } 
....................       }  
....................       strcpy(buffer2,"f"); 
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
....................          format_eepromext(); 
....................          fprintf(COM2," exit\n\r");  
....................       } 
....................       //#if defined(PIC26) 
....................       strcpy(buffer2,"f mem"); 
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"FORMATTING..."); 
....................          ease_eeprom(); 
....................          fprintf(COM2," exit\n\r");  
....................       }     
....................      strcpy(buffer2,"RSPW"); 
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
....................       { 
....................          //mode=LOGOFF; 
....................          fprintf(COM2,"reseting password..."); 
....................          reset_password(); 
....................          init_password(); 
....................          fprintf(COM2," exit\n\r");  
....................       }    
....................       strcpy(buffer2,"!kbd!"); 
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
....................       { 
....................          keydebug_en=1; 
....................          //en_getpin; 
....................          fprintf(COM2,"Key board testing\n\r"); 
....................       }   
....................       strcpy(buffer2,"rsfact"); 
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
....................       { 
....................          //keydebug_en=1; 
....................          //en_getpin; 
....................          fprintf(COM2,"reset factory\n\r"); 
....................          rstfact(); 
....................       }   
....................       //#endif 
....................       strcpy(buffer2,"e"); 
....................       if(!stringcomp(buffer_uart,buffer2))   // download data 
....................       { 
....................          mode=LOGOFF; 
....................          keydebug_en=0; 
....................          set_tris_a(0xff); 
....................          //dis_getpin; 
....................          fprintf(COM2," exit\n\r");  
....................       } 
....................        
....................       strcpy(buffer2,"n"); 
....................       if(!stringcomp(buffer_uart,buffer2))   // format mem 
....................       { 
....................          fprintf(COM2,"New console name>"); 
....................          USART_getstring(EN_ECHO,16, console); 
....................          EEPROM_write(strobe_nameconsole,16,console); 
....................          fprintf(COM2," OK\n\r"); 
....................       } 
....................        
....................       strcpy(buffer2,"c"); 
....................       if(!stringcomp(buffer_uart,buffer2))   //show clock 
....................       { 
....................          rtc_get_date(date,mon,year,day); 
....................          rtc_get_time(h,min,sec); 
....................          mode_sl=read_ext_eeprom(strobe_Master_SLV); 
....................          if(mode_sl==0) fprintf(COM2,"[M]"); 
....................          else fprintf(COM2,"[S]");   
....................          delaycharaction=read_ext_eeprom(strobe_delaytime);  
....................          fprintf(COM2,"[%u]",delaycharaction); 
....................          #if defined(SIM900) 
....................          auto_sending=read_ext_eeprom(strobe_autosending);  
....................          if(auto_sending==0)fprintf(COM2,"[auto sending (off)]"); 
....................             else fprintf(COM2,"[auto sending (on)]"); 
....................          fprintf(COM2,"[");    
....................          for(i=0;i<16;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i));   
....................          fprintf(COM2,"] "); 
....................          #endif 
....................          fprintf(COM2,"%02i/%02i %02i:%02i:%02i",date,mon,h,min,sec); 
....................          /*fprintf(COM2,"\n\rMobile Phone Number:");  
....................          for(i=0;i<20;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i));*/ 
....................          fprintf(COM2,"\n\r"); 
....................       } 
....................       strcpy(buffer2,"sc"); 
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
....................       { 
....................          fprintf(COM2,"Year>"); 
....................          USART_getstring(EN_ECHO, 3, temp); 
....................          year=(unsigned int8)strtoi(temp); 
....................          fprintf(COM2,"Month>"); 
....................          USART_getstring(EN_ECHO, 3, temp); 
....................          mon=(unsigned int8)strtoi(temp); 
....................          fprintf(COM2,"Date>"); 
....................          USART_getstring(EN_ECHO, 3, temp); 
....................          date = (unsigned int8)strtoi(temp); 
....................          fprintf(COM2,"Day>"); 
....................          USART_getstring(EN_ECHO, 3, temp); 
....................          day = (unsigned int8)strtoi(temp); 
....................          fprintf(COM2,"Hour>"); 
....................          USART_getstring(EN_ECHO, 3, temp); 
....................          h = (unsigned int8)strtoi(temp); 
....................          fprintf(COM2,"Minutes>"); 
....................          USART_getstring(EN_ECHO, 3, temp); 
....................          min = (unsigned int8)strtoi(temp);                   
....................          fprintf(COM2,"Seconds>"); 
....................          USART_getstring(EN_ECHO, 3, temp); 
....................          sec = (unsigned int8)strtoi(temp);                   
....................          fprintf(COM2,"\n\r"); 
....................          rtc_set_datetime(date,mon,year,day,h,min); 
....................       } 
....................       strcpy(buffer2,"MS"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Press '1' to select Slaver mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           fprintf(COM2,"Press '0' to select Master mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           mode_sl = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_Master_SLV,mode_sl); 
....................           set_tris_a(0xff); 
....................           fprintf(COM2,"\n\r"); 
....................       } 
....................       strcpy(buffer2,"KP"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Press '1' to turn on kepress"); 
....................           fprintf(COM2,"\n\r"); 
....................           fprintf(COM2,"Press '0' to turn off kepress"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           KP_mode = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_keypressmode,KP_mode); 
....................           fprintf(COM2,"\n\r"); 
....................       } 
....................       strcpy(buffer2,"tran time"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           delaycharaction = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_delaytime,delaycharaction); 
....................           fprintf(COM2,"\n\r"); 
....................       }    
....................       /*strcpy(buffer2,"delaykb"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           delaykey = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_delaykb,delaykey); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       } */ 
....................       strcpy(buffer2,"kofkb"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Press '1' to select the new keyboard"); 
....................           fprintf(COM2,"\n\r"); 
....................           fprintf(COM2,"Press '0' to select the old keyboard"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           type_KB=(unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(kindofKB,type_KB); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       }//*/   
....................       /*strcpy(buffer2,"KBlogic"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Input Number"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           write_ext_eeprom(KB_logic,(unsigned int8)strtoi(temp)); 
....................           //fprintf(COM2,"delaykey=%u\n\r",delaykey); 
....................           fprintf(COM2,"\n\r"); 
....................       }  */ 
....................       #if defined(SIM900) 
....................       memset(buffer2,0,sizeof(buffer2));  
....................       strcpy(buffer2,"cf mbn"); 
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
....................       { 
....................          for(i=0;i<20;i++)buffer1[i]=0; 
....................          fprintf(COM2,"\n\rInput your mobile phone number:"); 
....................          USART_getstring(EN_ECHO, 20, buffer1); 
....................          EEPROM_write(strobe_mobile_num1,20,buffer1); 
....................          fprintf(COM2,"\n\rdone\n\r");   
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<20;i++) fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i)); 
....................          fprintf(COM2,"\n\r");//*/ 
....................       } 
....................       strcpy(buffer2,"SIM900auto"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Press '1' to turn on Auto mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           fprintf(COM2,"Press '0' to turn off Auto mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           auto_sending = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_autosending,auto_sending); 
....................           fprintf(COM2,"\n\r"); 
....................       }    
....................       #endif 
....................       #if defined(PIC26) 
....................       strcpy(buffer2,"h"); 
....................       if(!stringcomp(buffer_uart,buffer2))   //setting clock 
....................       { 
....................          printf("h-> Help\n\r"); 
....................          printf("sc-> Set Clock\n\r"); 
....................          printf("c-> show Clock\n\r"); 
....................          printf("password-> changing PASSWORD\n\r"); 
....................          printf("n -> change console Name\n\r"); 
....................          printf("f-> Format\n\r"); 
....................          printf("e-> Exit\n\r");   
....................          printf("MS-> Keyboard mode setting (Slave/Master)\n\r"); 
....................          KP_mode=read_ext_eeprom(strobe_keypressmode); 
....................          if(KP_mode) printf("KP-> Keypress mode setting (On)\n\r"); 
....................             else printf("KP-> Keypress mode setting (Off)\n\r"); 
....................          printf("tran time-> time of each transaction\n\r"); 
....................          printf("debug-> on/off debug mode\n\r");      
....................          //printf("delaykb %d -> Keyboard's Timing\n\r",read_ext_eeprom(strobe_delaykb));  
....................          printf("kofkb %d -> select kind of keyboard\n\r",read_ext_eeprom(kindofKB)); 
....................          printf("rsfact-> reset factory\n\r");      
....................          //printf("KBlogic %d -> Keyboard's logic\n\r",read_ext_eeprom(KB_logic));  
....................          #if defined(SIM900) 
....................          printf("cf mbn-> changing target mobile phone number\n\r");  
....................          printf("SIM900auto-> on/off auto sending mode\n\r");  
....................          #endif 
....................       } 
....................       #endif 
....................       strcpy(buffer2,"password"); 
....................       if(!stringcomp(buffer_uart,buffer2))  
....................       { 
....................          fprintf(COM2,"old password:"); 
....................          EEPROM_read(strobe_pass_addr,20,password); 
....................          USART_getstring(STAR_ECHO, 20, entpassword); 
....................          if(!stringcomp(entpassword,password)) 
....................          { 
....................             fprintf(COM2,"\n\rnew:"); 
....................             USART_getstring(STAR_ECHO, 20, entpassword); 
....................             fprintf(COM2,"\n\ragain:"); 
....................             USART_getstring(STAR_ECHO, 20, password); 
....................             if(!stringcomp(entpassword,password)) 
....................             { 
....................                EEPROM_write(strobe_pass_addr,20,password); 
....................                fprintf(COM2,"\n\rOK\n\r");    
....................             } 
....................                else 
....................                { 
....................                   fprintf(COM2,"\n\rERR\n\r"); 
....................                } 
....................          } 
....................             else 
....................             { 
....................                fprintf(COM2," X\n\r"); 
....................             }    
....................       } 
....................       #if defined(debug) 
....................       strcpy(buffer2,"debug"); 
....................       if(!stringcomp(buffer_uart,buffer2)) 
....................       { 
....................           fprintf(COM2,"Press '1' to enable debug mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           fprintf(COM2,"Press '0' to disable debug mode"); 
....................           fprintf(COM2,"\n\r"); 
....................           USART_getstring(EN_ECHO, 3, temp); 
....................           debugmode = (unsigned int8)strtoi(temp); 
....................           write_ext_eeprom(strobe_debugmode,debugmode); 
....................           fprintf(COM2,"\n\r"); 
....................       }    
....................       #endif 
.................... } 
.................... //=============================================== 
....................  
....................  
.................... //========================= 
....................  
.................... #int_RDA 
.................... void  RDA_isr(void)  
.................... {   
....................    char c; 
....................    //restart_wdt(); 
....................    //disable_interrupts(INT_TIMER0); 
....................    //set_timer0(0);   
....................    //disable_interrupts(INT_RDA);   
....................    c=fgetc(COM1); 
*
22D6:  BTFSS  F9E.5
22D8:  BRA    22D6
22DA:  MOVFF  FAF,AB3
22DE:  MOVLB  A
....................    //if((c>127)||(c<30)) return; 
....................    //fprintf(COM2,"%c ",c);   
....................    #if defined(SIM900) 
....................    count_checking=0; 
22E0:  MOVLB  1
22E2:  CLRF   x07
22E4:  CLRF   x06
....................    if(checking_sim==1) 
22E6:  MOVLB  4
22E8:  DECFSZ x9C,W
22EA:  BRA    2302
....................    { 
....................       restart_wdt(); 
22EC:  CLRWDT
....................       setup_wdt(WDT_OFF); 
22EE:  BCF    FC0.0
....................       checking_sim=0; 
22F0:  CLRF   x9C
....................       fprintf(COM2,"OK\n\r"); 
22F2:  MOVLW  8C
22F4:  MOVWF  FF6
22F6:  MOVLW  23
22F8:  MOVWF  FF7
22FA:  MOVLB  0
22FC:  CALL   07A0
2300:  MOVLB  4
....................    } 
....................    #endif 
....................    output_toggle(LED); 
2302:  BCF    F92.6
2304:  BTG    F89.6
....................    if(booting_done) 
2306:  MOVLB  1
2308:  MOVF   xB5,F
230A:  BZ    2340
....................    { 
....................       buffer_uart[UART_index++]=c; 
230C:  MOVF   xB2,W
230E:  INCF   xB2,F
2310:  CLRF   03
2312:  ADDLW  4E
2314:  MOVWF  FE9
2316:  MOVLW  01
2318:  ADDWFC 03,W
231A:  MOVWF  FEA
231C:  MOVFF  AB3,FEF
....................       if(UART_index>=99)  
2320:  MOVF   xB2,W
2322:  SUBLW  62
2324:  BC    2328
....................       { 
....................          UART_index=0; 
2326:  CLRF   xB2
....................       } 
....................       //============================= 
....................       //output_toggle(PIN_C2); 
....................       if(receiver_state==0) 
2328:  MOVF   xB4,F
232A:  BNZ   2340
....................       { 
....................          timing_wait=3000;//3000 
232C:  MOVLW  0B
232E:  MOVLB  4
2330:  MOVWF  x98
2332:  MOVLW  B8
2334:  MOVWF  x97
....................          SIM_state=data_analyze; 
2336:  MOVLW  0D
2338:  MOVWF  x95
....................          count_polling=0; 
233A:  CLRF   x94
233C:  CLRF   x93
233E:  MOVLB  1
....................       } 
....................       //============================= 
....................       //enable_interrupts(INT_EXT1_H2L); 
....................    } 
....................    #if defined(SIM900) 
....................    if(SIM_state==data_analyze) 
2340:  MOVLB  4
2342:  MOVF   x95,W
2344:  SUBLW  0D
2346:  BNZ   2376
....................    { 
....................       over_byte++; 
2348:  MOVLB  1
234A:  INCF   xB6,F
234C:  BTFSC  FD8.2
234E:  INCF   xB7,F
....................       if(over_byte>=200) 
2350:  MOVF   xB7,F
2352:  BNZ   235A
2354:  MOVF   xB6,W
2356:  SUBLW  C7
2358:  BC    2374
....................       { 
....................          over_byte=0; 
235A:  CLRF   xB7
235C:  CLRF   xB6
....................          setup_wdt(WDT_ON); 
235E:  BSF    FC0.0
....................          output_low(rst_sim); 
2360:  BCF    F94.1
2362:  BCF    F8B.1
....................          fprintf(COM2,"\n\rDevice will reset\n\r"); 
2364:  MOVLW  92
2366:  MOVWF  FF6
2368:  MOVLW  23
236A:  MOVWF  FF7
236C:  MOVLB  0
236E:  CALL   07A0
2372:  MOVLB  1
2374:  MOVLB  4
....................       } 
....................    } 
....................    if(SIM_state==MSG_sending)over_byte=0; 
2376:  MOVF   x95,W
2378:  SUBLW  08
237A:  BNZ   2384
237C:  MOVLB  1
237E:  CLRF   xB7
2380:  CLRF   xB6
2382:  MOVLB  4
....................    #endif 
....................    return; 
....................    //enable_interrupts(INT_TIMER0); 
.................... } 
.................... //========================= 
2384:  BCF    F9E.5
2386:  MOVLB  0
2388:  GOTO   0084
.................... #INT_TIMER1 
.................... void timer1() 
.................... { 
....................    output_toggle(LED); 
*
23A8:  BCF    F92.6
23AA:  BTG    F89.6
....................    set_timer1(0xffff-50); 
23AC:  SETF   FCF
23AE:  MOVLW  CD
23B0:  MOVWF  FCE
.................... } 
.................... //========================== 
23B2:  BCF    F9E.0
23B4:  GOTO   0084
.................... #INT_TIMER0 
.................... void timer0() 
.................... { 
....................    int16 buf; 
....................    int8 temp; 
....................     
....................    //========strobe keyboarddata============ 
....................    //=======================================   
....................    //output_toggle(ROW0); 
....................    //KP_mode=read_ext_eeprom(strobe_keypressmode); 
....................    if(KP_mode) 
*
4720:  MOVLB  1
4722:  MOVF   x0F,F
4724:  BZ    4760
....................    { 
....................       if(count_kp<500)count_kp++; 
4726:  MOVF   x12,W
4728:  SUBLW  01
472A:  BNC   473A
472C:  BNZ   4734
472E:  MOVF   x11,W
4730:  SUBLW  F3
4732:  BNC   473A
4734:  INCF   x11,F
4736:  BTFSC  FD8.2
4738:  INCF   x12,F
....................       if(count_kp==500) 
473A:  MOVF   x11,W
473C:  SUBLW  F4
473E:  BNZ   4760
4740:  DECFSZ x12,W
4742:  BRA    4760
....................       { 
....................             fprintf(COM2,"\n\rKey release\n\r"); 
4744:  MOVLW  56
4746:  MOVWF  FF6
4748:  MOVLW  49
474A:  MOVWF  FF7
474C:  MOVLB  0
474E:  CALL   07A0
....................             keyprss_off; 
4752:  BCF    F92.7
4754:  BCF    F89.7
....................             kp_st=0;     
4756:  MOVLB  1
4758:  CLRF   x10
....................             count_kp++; 
475A:  INCF   x11,F
475C:  BTFSC  FD8.2
475E:  INCF   x12,F
....................       } 
....................    } 
....................    if(keydebug_en==1) 
4760:  DECFSZ x0B,W
4762:  BRA    477E
....................    { 
....................       if(mode_sl==0)kbd_getc(); 
4764:  MOVLB  9
4766:  MOVF   xB3,F
4768:  BNZ   4772
476A:  MOVLB  0
476C:  CALL   23B8
4770:  BRA    477C
....................          else temp=kbd_getc_slv();//kbd_getc_slv1(); 
4772:  MOVLB  0
4774:  CALL   361A
4778:  MOVFF  01,AB5
477C:  MOVLB  1
....................    } 
....................    if(enable_getpin==1) 
477E:  DECFSZ x0C,W
4780:  BRA    479C
....................    { 
....................       //output_high(PIN_C2); 
....................       if(mode_sl==0)kbd_getc(); 
4782:  MOVLB  9
4784:  MOVF   xB3,F
4786:  BNZ   4790
4788:  MOVLB  0
478A:  CALL   23B8
478E:  BRA    479A
....................          else temp=kbd_getc_slv(); 
4790:  MOVLB  0
4792:  CALL   361A
4796:  MOVFF  01,AB5
479A:  MOVLB  1
....................    } 
....................   if(mcr_timeout<5) mcr_timeout++; 
479C:  MOVLB  9
479E:  MOVF   x98,F
47A0:  BNZ   47C0
47A2:  MOVF   x97,F
47A4:  BNZ   47C0
47A6:  MOVF   x96,F
47A8:  BNZ   47C0
47AA:  MOVF   x95,W
47AC:  SUBLW  04
47AE:  BNC   47C0
47B0:  MOVLW  01
47B2:  ADDWF  x95,F
47B4:  BTFSC  FD8.0
47B6:  INCF   x96,F
47B8:  BTFSC  FD8.2
47BA:  INCF   x97,F
47BC:  BTFSC  FD8.2
47BE:  INCF   x98,F
....................   if(mcr_timeout==5) 
47C0:  MOVF   x95,W
47C2:  SUBLW  05
47C4:  BNZ   481A
47C6:  MOVF   x96,F
47C8:  BNZ   481A
47CA:  MOVF   x97,F
47CC:  BNZ   481A
47CE:  MOVF   x98,F
47D0:  BNZ   481A
....................   { 
....................       //fprintf(COM2,"\r\nSaving Card Data\r\n"); 
....................       if(reading_fg==1)saving_card(); 
47D2:  DECFSZ xAB,W
47D4:  BRA    47DC
47D6:  MOVLB  0
47D8:  BRA    3FF8
47DA:  MOVLB  9
....................          //else fprintf(COM2,"\r\nreading error\r\n"); 
....................       memset(buffertrack1, 0, sizeof(buffertrack1));    
47DC:  MOVLW  05
47DE:  MOVWF  FEA
47E0:  MOVLW  17
47E2:  MOVWF  FE9
47E4:  CLRF   00
47E6:  MOVLW  03
47E8:  MOVWF  02
47EA:  MOVLW  52
47EC:  MOVWF  01
47EE:  MOVLB  0
47F0:  RCALL  4476
....................       memset(buffertrack2, 0, sizeof(buffertrack2)); 
47F2:  MOVLW  08
47F4:  MOVWF  FEA
47F6:  MOVLW  69
47F8:  MOVWF  FE9
47FA:  CLRF   00
47FC:  MOVLW  01
47FE:  MOVWF  02
4800:  MOVLW  2C
4802:  MOVWF  01
4804:  RCALL  4476
....................       //debug_card(); 
....................       count_reading_error=0; 
4806:  MOVLB  9
4808:  CLRF   xAC
....................       mcr_timeout++;   
480A:  MOVLW  01
480C:  ADDWF  x95,F
480E:  BTFSC  FD8.0
4810:  INCF   x96,F
4812:  BTFSC  FD8.2
4814:  INCF   x97,F
4816:  BTFSC  FD8.2
4818:  INCF   x98,F
....................       //saving_flag=0; 
....................   } 
....................   delaycharaction=read_ext_eeprom(strobe_delaytime); 
481A:  MOVLB  A
481C:  CLRF   xC0
481E:  MOVLW  94
4820:  MOVWF  xBF
4822:  MOVLB  0
4824:  CALL   395A
4828:  MOVFF  01,146
....................   //fprintf(COM2,"\r\ndelaycharaction %lu\r\n",charac_timeout); 
....................   if(charac_timeout<(int16)(700*delaycharaction)) charac_timeout++; 
482C:  MOVLW  02
482E:  MOVLB  A
4830:  MOVWF  xBC
4832:  MOVLW  BC
4834:  MOVWF  xBB
4836:  CLRF   xBE
4838:  MOVFF  146,ABD
483C:  MOVLB  0
483E:  CALL   3A52
4842:  MOVFF  02,03
4846:  MOVF   xFC,W
4848:  SUBWF  02,W
484A:  BNC   485A
484C:  BNZ   4854
484E:  MOVF   01,W
4850:  SUBWF  xFB,W
4852:  BC    485A
4854:  INCF   xFB,F
4856:  BTFSC  FD8.2
4858:  INCF   xFC,F
....................   if(charac_timeout==(int16)(700*delaycharaction)) 
485A:  MOVLW  02
485C:  MOVLB  A
485E:  MOVWF  xBC
4860:  MOVLW  BC
4862:  MOVWF  xBB
4864:  CLRF   xBE
4866:  MOVFF  146,ABD
486A:  MOVLB  0
486C:  CALL   3A52
4870:  MOVFF  02,03
4874:  MOVF   01,W
4876:  SUBWF  xFB,W
4878:  BNZ   4950
487A:  MOVF   03,W
487C:  SUBWF  xFC,W
487E:  BNZ   4950
....................   { 
....................       charac_timeout++; 
4880:  INCF   xFB,F
4882:  BTFSC  FD8.2
4884:  INCF   xFC,F
....................       buf=get_countcard(); 
4886:  CALL   3A02
488A:  MOVFF  02,AB4
488E:  MOVFF  01,AB3
....................       if(buf<countcards) 
4892:  MOVLB  A
4894:  MOVF   xB4,W
4896:  SUBLW  01
4898:  BNC   48C0
489A:  BNZ   48A2
489C:  MOVF   xB3,W
489E:  SUBLW  5D
48A0:  BNC   48C0
....................       { 
....................          save_key_new(); 
48A2:  MOVLB  0
48A4:  BRA    4490
....................          buf=buf+1; 
48A6:  MOVLW  01
48A8:  MOVLB  A
48AA:  ADDWF  xB3,F
48AC:  MOVLW  00
48AE:  ADDWFC xB4,F
....................          save_coutcard(buf); 
48B0:  MOVFF  AB4,AB7
48B4:  MOVFF  AB3,AB6
48B8:  MOVLB  0
48BA:  RCALL  45E4
....................       } 
48BC:  BRA    48F2
48BE:  MOVLB  A
....................          else 
....................          { 
....................             fprintf(COM2,"\r\nFull memory\r\n"); 
48C0:  MOVLW  66
48C2:  MOVWF  FF6
48C4:  MOVLW  49
48C6:  MOVWF  FF7
48C8:  MOVLB  0
48CA:  CALL   07A0
....................             #if defined(SIM900) 
....................                //SIM_state=autosending; 
....................                SIM_state=SIM_reply;   
48CE:  MOVLW  0E
48D0:  MOVLB  4
48D2:  MOVWF  x95
....................                strcpy(reply_buffer,"Full memory, please format memory"); 
48D4:  MOVLW  03
48D6:  MOVWF  FEA
48D8:  MOVLW  48
48DA:  MOVWF  FE9
48DC:  MOVLW  00
48DE:  MOVLB  0
48E0:  CALL   017C
48E4:  TBLRD*-
48E6:  TBLRD*+
48E8:  MOVF   FF5,W
48EA:  MOVWF  FEE
48EC:  IORLW  00
48EE:  BNZ   48E6
....................             #endif 
....................             return; 
48F0:  BRA    4950
....................          } 
....................       //if(cardread_st==0)return; 
....................       fprintf(COM2,"\r\nSaving PIN\r\n"); 
48F2:  MOVLW  76
48F4:  MOVWF  FF6
48F6:  MOVLW  49
48F8:  MOVWF  FF7
48FA:  CALL   07A0
....................       fprintf(COM2,"\r\nnext transaction (%ld)\r\n",buf);  
48FE:  MOVLW  86
4900:  MOVWF  FF6
4902:  MOVLW  49
4904:  MOVWF  FF7
4906:  MOVLW  14
4908:  MOVLB  A
490A:  MOVWF  xD3
490C:  MOVLB  0
490E:  CALL   1718
4912:  MOVLW  10
4914:  MOVWF  FE9
4916:  MOVFF  AB4,AB7
491A:  MOVFF  AB3,AB6
491E:  BRA    461E
4920:  MOVLW  9D
4922:  MOVWF  FF6
4924:  MOVLW  49
4926:  MOVWF  FF7
4928:  MOVLW  03
492A:  MOVLB  A
492C:  MOVWF  xD3
492E:  MOVLB  0
4930:  CALL   1718
....................       data_avai=0; 
4934:  MOVLB  9
4936:  CLRF   xAA
....................       enable_getpin=0; 
4938:  MOVLB  1
493A:  CLRF   x0C
....................       //dis_getpin; 
....................       output_low(LED); 
493C:  BCF    F92.6
493E:  BCF    F89.6
....................       #if defined(SIM900) 
....................        if(auto_sending==1)SIM_state=autosending; 
4940:  MOVLB  4
4942:  DECFSZ x99,W
4944:  BRA    494A
4946:  MOVLW  0B
4948:  MOVWF  x95
....................        #if defined(twonumber) 
....................             two_number_sending=1; 
494A:  MOVLW  01
494C:  MOVWF  x9F
494E:  MOVLB  0
....................        #endif 
....................       #endif 
....................   } 
....................   //================================= 
....................   //================================= 
4950:  BCF    FF2.2
4952:  GOTO   0084
.................... } 
.................... //========================= 
.................... void main() 
*
6BDC:  CLRF   FF8
6BDE:  BCF    FD0.7
6BE0:  BSF    07.7
6BE2:  BSF    F7E.3
6BE4:  MOVLW  40
6BE6:  MOVWF  FB0
6BE8:  MOVLW  03
6BEA:  MOVWF  F7F
6BEC:  MOVLW  A6
6BEE:  MOVWF  FAD
6BF0:  MOVLW  90
6BF2:  MOVWF  FAC
6BF4:  BCF    F94.0
6BF6:  BSF    F8B.0
6BF8:  CLRF   23
6BFA:  CLRF   22
6BFC:  CLRF   21
6BFE:  MOVLW  96
6C00:  MOVWF  20
6C02:  CLRF   27
6C04:  CLRF   26
6C06:  MOVLW  AA
6C08:  MOVWF  25
6C0A:  MOVLW  47
6C0C:  MOVWF  24
6C0E:  CLRF   xFA
6C10:  CLRF   xF9
6C12:  SETF   xFC
6C14:  SETF   xFB
6C16:  MOVLW  0E
6C18:  MOVWF  xFE
6C1A:  MOVLW  01
6C1C:  MOVWF  xFF
6C1E:  MOVLB  1
6C20:  MOVWF  x00
6C22:  CLRF   x01
6C24:  CLRF   x02
6C26:  CLRF   x03
6C28:  CLRF   x04
6C2A:  CLRF   x05
6C2C:  CLRF   x07
6C2E:  MOVLW  0A
6C30:  MOVWF  x06
6C32:  MOVLW  03
6C34:  MOVWF  x09
6C36:  MOVLW  E8
6C38:  MOVWF  x08
6C3A:  CLRF   x0A
6C3C:  CLRF   x0B
6C3E:  CLRF   x0C
6C40:  MOVLW  64
6C42:  MOVWF  x0D
6C44:  CLRF   x0E
6C46:  CLRF   x0F
6C48:  CLRF   x10
6C4A:  CLRF   x12
6C4C:  CLRF   x11
6C4E:  CLRF   x13
6C50:  CLRF   x46
6C52:  CLRF   x4B
6C54:  CLRF   xB2
6C56:  CLRF   xB3
6C58:  CLRF   xB4
6C5A:  CLRF   xB5
6C5C:  CLRF   xB7
6C5E:  CLRF   xB6
6C60:  MOVLB  4
6C62:  CLRF   x94
6C64:  CLRF   x93
6C66:  CLRF   x95
6C68:  CLRF   x96
6C6A:  CLRF   x98
6C6C:  MOVWF  x97
6C6E:  CLRF   x99
6C70:  CLRF   x9A
6C72:  CLRF   x9B
6C74:  CLRF   x9C
6C76:  CLRF   x9D
6C78:  CLRF   x9E
6C7A:  CLRF   x9F
6C7C:  MOVLB  9
6C7E:  CLRF   x98
6C80:  CLRF   x97
6C82:  CLRF   x96
6C84:  CLRF   x95
6C86:  CLRF   x99
6C88:  CLRF   x9B
6C8A:  CLRF   x9A
6C8C:  CLRF   x9D
6C8E:  CLRF   x9C
6C90:  CLRF   x9F
6C92:  CLRF   x9E
6C94:  CLRF   xA1
6C96:  CLRF   xA0
6C98:  MOVLW  FD
6C9A:  MOVWF  xA3
6C9C:  MOVLW  E8
6C9E:  MOVWF  xA2
6CA0:  CLRF   xA5
6CA2:  CLRF   xA4
6CA4:  CLRF   xA6
6CA6:  CLRF   xA7
6CA8:  CLRF   xA8
6CAA:  CLRF   xA9
6CAC:  CLRF   xAA
6CAE:  CLRF   xAB
6CB0:  CLRF   xAC
6CB2:  CLRF   xAD
6CB4:  CLRF   xAE
6CB6:  CLRF   xB0
6CB8:  MOVLW  01
6CBA:  MOVWF  xAF
6CBC:  CLRF   xB2
6CBE:  CLRF   xB1
6CC0:  CLRF   xB3
6CC2:  CLRF   xB7
6CC4:  CLRF   xB6
6CC6:  CLRF   xB5
6CC8:  CLRF   xB4
6CCA:  MOVLW  FF
6CCC:  MOVLB  F
6CCE:  MOVWF  x48
6CD0:  BCF    FC2.6
6CD2:  BCF    FC2.7
6CD4:  MOVF   x49,W
6CD6:  ANDLW  E0
6CD8:  IORLW  1F
6CDA:  MOVWF  x49
6CDC:  CLRF   FD2
6CDE:  CLRF   FD1
6CE0:  MOVLB  1
6CE2:  BCF    x48.0
6CE4:  BCF    x48.1
6CE6:  BRA    6D04
6CE8:  DATA 02,00
6CEA:  DATA 1A,00
6CEC:  DATA 00,01
6CEE:  DATA 01,47
6CF0:  DATA 00,02
6CF2:  DATA 01,49
6CF4:  DATA 00,00
6CF6:  DATA 02,01
6CF8:  DATA 4C,00
6CFA:  DATA 00,1A
6CFC:  DATA 44,79
6CFE:  DATA 00,0A
6D00:  DATA 49,C8
6D02:  DATA 00,00
6D04:  MOVLW  00
6D06:  MOVWF  FF8
6D08:  MOVLW  6C
6D0A:  MOVWF  FF7
6D0C:  MOVLW  E8
6D0E:  MOVWF  FF6
6D10:  TBLRD*+
6D12:  MOVF   FF5,W
6D14:  MOVWF  00
6D16:  XORLW  00
6D18:  BZ    6D40
6D1A:  TBLRD*+
6D1C:  MOVF   FF5,W
6D1E:  MOVWF  01
6D20:  BTFSC  FE8.7
6D22:  BRA    6D2E
6D24:  ANDLW  0F
6D26:  MOVWF  FEA
6D28:  TBLRD*+
6D2A:  MOVFF  FF5,FE9
6D2E:  BTFSC  01.6
6D30:  TBLRD*+
6D32:  BTFSS  01.6
6D34:  TBLRD*+
6D36:  MOVFF  FF5,FEE
6D3A:  DCFSNZ 00,F
6D3C:  BRA    6D10
6D3E:  BRA    6D32
6D40:  CLRF   FF8
6D42:  MOVLB  9
6D44:  CLRF   xD4
6D46:  CLRF   xD6
6D48:  CLRF   xD5
.................... {  
....................    int8 i,temp,count_char=0; 
....................    static int16 num_card,cards,countc,count_dwla; 
....................    static int16 lastlen; 
....................    int16 len=0,addr_dat; 
....................    int8 strl,j; 
....................    char  string[5],buftemp[124],buftemp2[50]; 
....................    //RPINR2=6; 
....................    RPINR1=5; 
6D4A:  MOVLW  05
6D4C:  MOVLB  E
6D4E:  MOVWF  xE7
....................    SIM_state = 0xff; 
6D50:  MOVLB  4
6D52:  SETF   x95
....................    charac_timeout=0xffffffff; 
6D54:  MOVLB  0
6D56:  SETF   xFC
6D58:  SETF   xFB
....................    key_timeout=0xffff; 
6D5A:  MOVLB  1
6D5C:  SETF   x09
6D5E:  SETF   x08
....................    setup_oscillator(OSC_32MHZ); 
6D60:  MOVLW  70
6D62:  MOVWF  FD3
6D64:  MOVLW  40
6D66:  MOVWF  F9B
6D68:  MOVF   FD3,W
....................    keyprss_off; 
6D6A:  BCF    F92.7
6D6C:  BCF    F89.7
....................    //============================= 
....................    disable_interrupts(GLOBAL); 
6D6E:  BCF    FF2.6
6D70:  BCF    FF2.7
6D72:  BTFSC  FF2.7
6D74:  BRA    6D70
....................    init_ext_eeprom(); 
6D76:  MOVLB  0
6D78:  GOTO   506C
....................    #if defined(rst_pwd) 
....................       delay_ms(1000); 
....................       fprintf(COM2,"\r\nreset password\r\n"); 
....................       delay_ms(1000); 
....................       reset_password(); 
....................       fprintf(COM2,"\r\nDone\r\n"); 
....................       while(1); 
....................    #endif      
....................       delay_ms(1000); 
6D7C:  MOVLW  04
6D7E:  MOVLB  A
6D80:  MOVWF  x8E
6D82:  CLRF   19
6D84:  BTFSC  FF2.7
6D86:  BSF    19.7
6D88:  BCF    FF2.7
6D8A:  MOVLW  FA
6D8C:  MOVWF  xBC
6D8E:  MOVLB  0
6D90:  CALL   198E
6D94:  BTFSC  19.7
6D96:  BSF    FF2.7
6D98:  MOVLB  A
6D9A:  DECFSZ x8E,F
6D9C:  BRA    6D82
....................    init_password(); 
6D9E:  MOVLB  0
6DA0:  CALL   511E
....................    EEPROM_read(strobe_pass_addr,20,password); 
6DA4:  MOVLB  A
6DA6:  CLRF   x8E
6DA8:  MOVLW  14
6DAA:  MOVWF  x8F
6DAC:  CLRF   x91
6DAE:  MOVLW  55
6DB0:  MOVWF  x90
6DB2:  MOVLB  0
6DB4:  CALL   5076
6DB8:  CLRF   19
6DBA:  BTFSC  FF2.7
6DBC:  BSF    19.7
6DBE:  BCF    FF2.7
....................    KP_mode=read_ext_eeprom(strobe_keypressmode); 
6DC0:  MOVLB  A
6DC2:  CLRF   xC0
6DC4:  MOVLW  7F
6DC6:  MOVWF  xBF
6DC8:  MOVLB  0
6DCA:  CALL   395A
6DCE:  BTFSC  19.7
6DD0:  BSF    FF2.7
6DD2:  MOVFF  01,10F
....................    //===================================== 
....................    rtc_init(); 
6DD6:  GOTO   518C
....................    //RTC_init(); 
....................    //mysettime(); 
....................    //write_ext_eeprom(65535,12); 
....................    ptr_card=get_ptrcard(strobe_ptrcard_addr); 
6DDA:  MOVLW  19
6DDC:  MOVLB  A
6DDE:  MOVWF  x8E
6DE0:  MOVLB  0
6DE2:  CALL   52A2
6DE6:  MOVFF  03,23
6DEA:  MOVFF  02,22
6DEE:  MOVFF  01,21
6DF2:  MOVFF  00,20
....................     
....................   // fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card); 
....................    ptr_card_key=get_ptrcard(strobe_ptrcard_key); 
6DF6:  MOVLW  1E
6DF8:  MOVLB  A
6DFA:  MOVWF  x8E
6DFC:  MOVLB  0
6DFE:  CALL   52A2
6E02:  MOVFF  03,27
6E06:  MOVFF  02,26
6E0A:  MOVFF  01,25
6E0E:  MOVFF  00,24
6E12:  CLRF   19
6E14:  BTFSC  FF2.7
6E16:  BSF    19.7
6E18:  BCF    FF2.7
....................   // fprintf(COM2," save_ptrcard=%lu\n\r",ptr_card_key); 
....................    countcard=get_countcard(); 
6E1A:  CALL   3A02
6E1E:  BTFSC  19.7
6E20:  BSF    FF2.7
6E22:  MOVFF  02,FA
6E26:  MOVFF  01,F9
....................   // fprintf(COM2," countcard=%lu\n\r",countcard); 
....................    //fprintf(COM2,"read_ext_eeprom=%d\r\n",read_ext_eeprom(65535)); 
....................    charac_timeout=0xffffffff; 
6E2A:  SETF   xFC
6E2C:  SETF   xFB
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256|T0_8_BIT); 
6E2E:  MOVLW  C7
6E30:  MOVWF  FD5
6E32:  CLRF   19
6E34:  BTFSC  FF2.7
6E36:  BSF    19.7
6E38:  BCF    FF2.7
....................    //setup_timer_1(T1_INTERNAL|T1_DIV_BY_1); 
....................    delaycharaction=read_ext_eeprom(strobe_delaytime); 
6E3A:  MOVLB  A
6E3C:  CLRF   xC0
6E3E:  MOVLW  94
6E40:  MOVWF  xBF
6E42:  MOVLB  0
6E44:  CALL   395A
6E48:  BTFSC  19.7
6E4A:  BSF    FF2.7
6E4C:  MOVFF  01,146
....................    if(delaycharaction==0)delaycharaction=1; 
6E50:  MOVLB  1
6E52:  MOVF   x46,F
6E54:  BNZ   6E5A
6E56:  MOVLW  01
6E58:  MOVWF  x46
....................    //delaykey=read_ext_eeprom(strobe_delaykb); 
....................    //fprintf(COM2," delaycharaction=%u\n\r",delaycharaction); 
....................    //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................     //========================================== 
....................       enable_interrupts(INT_TIMER0); 
6E5A:  BSF    FF2.5
....................       //enable_interrupts(INT_TIMER1); 
....................       enable_interrupts(INT_EXT1_H2L); 
6E5C:  BSF    FF0.3
6E5E:  BCF    FF1.5
....................    //enable_interrupts(INT_EXT2_H2L); 
....................       enable_interrupts(INT_RDA); 
6E60:  BSF    F9D.5
....................        
....................       enable_interrupts(GLOBAL); 
6E62:  MOVLW  C0
6E64:  IORWF  FF2,F
....................    //========================================== 
....................    //delay_ms(100); 
....................    //EEPROM_read(strobe_mobile_num1,20,mobilenumb); 
....................    //reset_password(); 
....................    //init_password(); 
....................    //fprintf(COM2,"Start\r\n"); 
....................    mcr_timeout=10000; 
6E66:  MOVLB  9
6E68:  CLRF   x98
6E6A:  CLRF   x97
6E6C:  MOVLW  27
6E6E:  MOVWF  x96
6E70:  MOVLW  10
6E72:  MOVWF  x95
6E74:  CLRF   19
6E76:  BTFSC  FF2.7
6E78:  BSF    19.7
6E7A:  BCF    FF2.7
....................    //EEPROM_read(strobe_pass_addr,20,password); 
....................    //========================================== 
....................    //write_ext_eeprom(strobe_Master_SLV,1); 
....................     mode_sl=read_ext_eeprom(strobe_Master_SLV); 
6E7C:  MOVLB  A
6E7E:  CLRF   xC0
6E80:  MOVLW  91
6E82:  MOVWF  xBF
6E84:  MOVLB  0
6E86:  CALL   395A
6E8A:  BTFSC  19.7
6E8C:  BSF    FF2.7
6E8E:  MOVFF  01,9B3
6E92:  CLRF   19
6E94:  BTFSC  FF2.7
6E96:  BSF    19.7
6E98:  BCF    FF2.7
....................     debugmode=read_ext_eeprom(strobe_debugmode); 
6E9A:  MOVLB  A
6E9C:  CLRF   xC0
6E9E:  MOVLW  92
6EA0:  MOVWF  xBF
6EA2:  MOVLB  0
6EA4:  CALL   395A
6EA8:  BTFSC  19.7
6EAA:  BSF    FF2.7
6EAC:  MOVFF  01,9A7
....................     key_timeout=1000; 
6EB0:  MOVLW  03
6EB2:  MOVLB  1
6EB4:  MOVWF  x09
6EB6:  MOVLW  E8
6EB8:  MOVWF  x08
....................    //========================================== 
....................    charac_timeout=0xffffffff; 
6EBA:  MOVLB  0
6EBC:  SETF   xFC
6EBE:  SETF   xFB
....................    //delay_ms(3000); 
....................     
....................    #if defined(SIM900) 
....................       disable_interrupts(GLOBAL); 
6EC0:  BCF    FF2.6
6EC2:  BCF    FF2.7
6EC4:  BTFSC  FF2.7
6EC6:  BRA    6EC2
....................       output_high(rst_sim); 
6EC8:  BCF    F94.1
6ECA:  BSF    F8B.1
....................       //fprintf(COM1,"AT+CPOWD=1\r\n"); 
....................       //output_low(PIN_C7); 
....................       //set_tris_c(0); 
....................       #ASM 
....................          BCF    0xF94.7 
6ECC:  BCF    F94.7
....................       #ENDASM 
....................       SIM_state = 0xff; 
6ECE:  MOVLB  4
6ED0:  SETF   x95
....................       fprintf(COM2,"\r\nbooting...\r\n"); 
6ED2:  MOVLW  A2
6ED4:  MOVWF  FF6
6ED6:  MOVLW  49
6ED8:  MOVWF  FF7
6EDA:  CLRF   19
6EDC:  BTFSC  FF2.7
6EDE:  BSF    19.7
6EE0:  BCF    FF2.7
6EE2:  MOVLB  0
6EE4:  CALL   07A0
6EE8:  BTFSC  19.7
6EEA:  BSF    FF2.7
....................       delay_ms(10000); 
6EEC:  MOVLW  28
6EEE:  MOVLB  A
6EF0:  MOVWF  x8E
6EF2:  CLRF   19
6EF4:  BTFSC  FF2.7
6EF6:  BSF    19.7
6EF8:  BCF    FF2.7
6EFA:  MOVLW  FA
6EFC:  MOVWF  xBC
6EFE:  MOVLB  0
6F00:  CALL   198E
6F04:  BTFSC  19.7
6F06:  BSF    FF2.7
6F08:  MOVLB  A
6F0A:  DECFSZ x8E,F
6F0C:  BRA    6EF2
....................       receiver_state=1; 
6F0E:  MOVLW  01
6F10:  MOVLB  1
6F12:  MOVWF  xB4
....................       fprintf(COM1,"AT\r\n"); 
6F14:  MOVLW  B2
6F16:  MOVWF  FF6
6F18:  MOVLW  49
6F1A:  MOVWF  FF7
6F1C:  MOVLB  0
6F1E:  CALL   53E0
....................       delay_ms(1000); 
6F22:  MOVLW  04
6F24:  MOVLB  A
6F26:  MOVWF  x8E
6F28:  CLRF   19
6F2A:  BTFSC  FF2.7
6F2C:  BSF    19.7
6F2E:  BCF    FF2.7
6F30:  MOVLW  FA
6F32:  MOVWF  xBC
6F34:  MOVLB  0
6F36:  CALL   198E
6F3A:  BTFSC  19.7
6F3C:  BSF    FF2.7
6F3E:  MOVLB  A
6F40:  DECFSZ x8E,F
6F42:  BRA    6F28
....................       fprintf(COM1,"AT+CMGF=1\r\n"); 
6F44:  MOVLW  B8
6F46:  MOVWF  FF6
6F48:  MOVLW  49
6F4A:  MOVWF  FF7
6F4C:  MOVLB  0
6F4E:  CALL   53E0
....................       delay_ms(1000); 
6F52:  MOVLW  04
6F54:  MOVLB  A
6F56:  MOVWF  x8E
6F58:  CLRF   19
6F5A:  BTFSC  FF2.7
6F5C:  BSF    19.7
6F5E:  BCF    FF2.7
6F60:  MOVLW  FA
6F62:  MOVWF  xBC
6F64:  MOVLB  0
6F66:  CALL   198E
6F6A:  BTFSC  19.7
6F6C:  BSF    FF2.7
6F6E:  MOVLB  A
6F70:  DECFSZ x8E,F
6F72:  BRA    6F58
....................       //sim900_init(); 
....................       EEPROM_read(strobe_mobile_num1,20,mobilenumb); 
6F74:  MOVLW  55
6F76:  MOVWF  x8E
6F78:  MOVLW  14
6F7A:  MOVWF  x8F
6F7C:  MOVLW  04
6F7E:  MOVWF  x91
6F80:  MOVLW  79
6F82:  MOVWF  x90
6F84:  MOVLB  0
6F86:  CALL   5076
....................       fprintf(COM1,"AT+CSMP=17,167,0,245\r\n"); 
6F8A:  MOVLW  C4
6F8C:  MOVWF  FF6
6F8E:  MOVLW  49
6F90:  MOVWF  FF7
6F92:  CALL   53E0
....................       delay_ms(1000); 
6F96:  MOVLW  04
6F98:  MOVLB  A
6F9A:  MOVWF  x8E
6F9C:  CLRF   19
6F9E:  BTFSC  FF2.7
6FA0:  BSF    19.7
6FA2:  BCF    FF2.7
6FA4:  MOVLW  FA
6FA6:  MOVWF  xBC
6FA8:  MOVLB  0
6FAA:  CALL   198E
6FAE:  BTFSC  19.7
6FB0:  BSF    FF2.7
6FB2:  MOVLB  A
6FB4:  DECFSZ x8E,F
6FB6:  BRA    6F9C
....................       fprintf(COM1,"AT+CMGD=1\r\n");  
6FB8:  MOVLW  DC
6FBA:  MOVWF  FF6
6FBC:  MOVLW  49
6FBE:  MOVWF  FF7
6FC0:  MOVLB  0
6FC2:  CALL   53E0
....................       delay_ms(1000); 
6FC6:  MOVLW  04
6FC8:  MOVLB  A
6FCA:  MOVWF  x8E
6FCC:  CLRF   19
6FCE:  BTFSC  FF2.7
6FD0:  BSF    19.7
6FD2:  BCF    FF2.7
6FD4:  MOVLW  FA
6FD6:  MOVWF  xBC
6FD8:  MOVLB  0
6FDA:  CALL   198E
6FDE:  BTFSC  19.7
6FE0:  BSF    FF2.7
6FE2:  MOVLB  A
6FE4:  DECFSZ x8E,F
6FE6:  BRA    6FCC
....................       fprintf(COM1,"AT+CMGD=2\r\n"); 
6FE8:  MOVLW  E8
6FEA:  MOVWF  FF6
6FEC:  MOVLW  49
6FEE:  MOVWF  FF7
6FF0:  MOVLB  0
6FF2:  CALL   53E0
....................       delay_ms(1000); 
6FF6:  MOVLW  04
6FF8:  MOVLB  A
6FFA:  MOVWF  x8E
6FFC:  CLRF   19
6FFE:  BTFSC  FF2.7
7000:  BSF    19.7
7002:  BCF    FF2.7
7004:  MOVLW  FA
7006:  MOVWF  xBC
7008:  MOVLB  0
700A:  CALL   198E
700E:  BTFSC  19.7
7010:  BSF    FF2.7
7012:  MOVLB  A
7014:  DECFSZ x8E,F
7016:  BRA    6FFC
....................       fprintf(COM1,"AT+CMGD=3\r\n"); 
7018:  MOVLW  F4
701A:  MOVWF  FF6
701C:  MOVLW  49
701E:  MOVWF  FF7
7020:  MOVLB  0
7022:  CALL   53E0
....................       delay_ms(1000); 
7026:  MOVLW  04
7028:  MOVLB  A
702A:  MOVWF  x8E
702C:  CLRF   19
702E:  BTFSC  FF2.7
7030:  BSF    19.7
7032:  BCF    FF2.7
7034:  MOVLW  FA
7036:  MOVWF  xBC
7038:  MOVLB  0
703A:  CALL   198E
703E:  BTFSC  19.7
7040:  BSF    FF2.7
7042:  MOVLB  A
7044:  DECFSZ x8E,F
7046:  BRA    702C
....................       fprintf(COM1,"AT+CMGD=4\r\n"); 
7048:  MOVLW  00
704A:  MOVWF  FF6
704C:  MOVLW  4A
704E:  MOVWF  FF7
7050:  MOVLB  0
7052:  CALL   53E0
....................       delay_ms(1000); 
7056:  MOVLW  04
7058:  MOVLB  A
705A:  MOVWF  x8E
705C:  CLRF   19
705E:  BTFSC  FF2.7
7060:  BSF    19.7
7062:  BCF    FF2.7
7064:  MOVLW  FA
7066:  MOVWF  xBC
7068:  MOVLB  0
706A:  CALL   198E
706E:  BTFSC  19.7
7070:  BSF    FF2.7
7072:  MOVLB  A
7074:  DECFSZ x8E,F
7076:  BRA    705C
....................       fprintf(COM1,"AT+CMGD=5\r\n");  
7078:  MOVLW  0C
707A:  MOVWF  FF6
707C:  MOVLW  4A
707E:  MOVWF  FF7
7080:  MOVLB  0
7082:  CALL   53E0
....................       output_high(LED); 
7086:  BCF    F92.6
7088:  BSF    F89.6
....................       delay_ms(1000); 
708A:  MOVLW  04
708C:  MOVLB  A
708E:  MOVWF  x8E
7090:  CLRF   19
7092:  BTFSC  FF2.7
7094:  BSF    19.7
7096:  BCF    FF2.7
7098:  MOVLW  FA
709A:  MOVWF  xBC
709C:  MOVLB  0
709E:  CALL   198E
70A2:  BTFSC  19.7
70A4:  BSF    FF2.7
70A6:  MOVLB  A
70A8:  DECFSZ x8E,F
70AA:  BRA    7090
....................       SIM_state= idle; 
70AC:  MOVLW  0C
70AE:  MOVLB  4
70B0:  MOVWF  x95
....................       #ASM 
....................          BSF    0xF94.7 
70B2:  BSF    F94.7
....................       #ENDASM 
....................       //set_tris_c(0xff); 
....................       //setup_wdt(WDT_ON); 
....................       enable_interrupts(GLOBAL); 
70B4:  MOVLW  C0
70B6:  IORWF  FF2,F
....................    #endif 
....................    booting=1; 
70B8:  MOVLW  01
70BA:  MOVLB  1
70BC:  MOVWF  x05
....................    charac_timeout=0xffffffff; 
70BE:  MOVLB  0
70C0:  SETF   xFC
70C2:  SETF   xFB
....................     
....................    EEPROM_read(strobe_nameconsole,16,console); 
70C4:  MOVLW  66
70C6:  MOVLB  A
70C8:  MOVWF  x8E
70CA:  MOVLW  10
70CC:  MOVWF  x8F
70CE:  MOVLW  09
70D0:  MOVWF  x91
70D2:  MOVLW  B8
70D4:  MOVWF  x90
70D6:  MOVLB  0
70D8:  CALL   5076
....................    EEPROM_read(strobe_pass_addr,20,password); 
70DC:  MOVLB  A
70DE:  CLRF   x8E
70E0:  MOVLW  14
70E2:  MOVWF  x8F
70E4:  CLRF   x91
70E6:  MOVLW  55
70E8:  MOVWF  x90
70EA:  MOVLB  0
70EC:  CALL   5076
....................    set_tris_a(0xff);  
70F0:  MOVLW  FF
70F2:  MOVWF  F92
....................     
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_VDD); 
70F4:  MOVLW  E0
70F6:  MOVLB  F
70F8:  MOVWF  x48
70FA:  BCF    FC2.6
70FC:  BCF    FC2.7
70FE:  MOVF   x49,W
7100:  ANDLW  E0
7102:  IORLW  1F
7104:  MOVWF  x49
....................    setup_adc(ADC_CLOCK_INTERNAL); 
7106:  MOVF   FC1,W
7108:  ANDLW  C0
710A:  IORLW  03
710C:  MOVWF  FC1
710E:  BCF    FC1.7
7110:  BSF    FC2.0
7112:  BSF    FC1.6
7114:  BSF    FC2.1
7116:  BTFSC  FC2.1
7118:  BRA    7116
711A:  BCF    FC1.6
711C:  CLRF   19
711E:  BTFSC  FF2.7
7120:  BSF    19.7
7122:  BCF    FF2.7
....................     
....................    KP_mode=read_ext_eeprom(strobe_keypressmode); 
7124:  MOVLB  A
7126:  CLRF   xC0
7128:  MOVLW  7F
712A:  MOVWF  xBF
712C:  MOVLB  0
712E:  CALL   395A
7132:  BTFSC  19.7
7134:  BSF    FF2.7
7136:  MOVFF  01,10F
713A:  CLRF   19
713C:  BTFSC  FF2.7
713E:  BSF    19.7
7140:  BCF    FF2.7
....................    type_KB=read_ext_eeprom(kindofKB); 
7142:  MOVLB  A
7144:  CLRF   xC0
7146:  MOVLW  7E
7148:  MOVWF  xBF
714A:  MOVLB  0
714C:  CALL   395A
7150:  BTFSC  19.7
7152:  BSF    FF2.7
7154:  MOVFF  01,113
....................    if(type_KB!=0) fprintf(COM2,"new keboard mode\n\r"); 
7158:  MOVLB  1
715A:  MOVF   x13,F
715C:  BZ    717C
715E:  MOVLW  18
7160:  MOVWF  FF6
7162:  MOVLW  4A
7164:  MOVWF  FF7
7166:  CLRF   19
7168:  BTFSC  FF2.7
716A:  BSF    19.7
716C:  BCF    FF2.7
716E:  MOVLB  0
7170:  CALL   07A0
7174:  BTFSC  19.7
7176:  BSF    FF2.7
7178:  BRA    7196
717A:  MOVLB  1
....................       else fprintf(COM2,"Old keboard mode\n\r"); 
717C:  MOVLW  2C
717E:  MOVWF  FF6
7180:  MOVLW  4A
7182:  MOVWF  FF7
7184:  CLRF   19
7186:  BTFSC  FF2.7
7188:  BSF    19.7
718A:  BCF    FF2.7
718C:  MOVLB  0
718E:  CALL   07A0
7192:  BTFSC  19.7
7194:  BSF    FF2.7
....................    if(mode_sl==0)fprintf(COM2,"Slaver mode is disable\n\r"); 
7196:  MOVLB  9
7198:  MOVF   xB3,F
719A:  BNZ   71BA
719C:  MOVLW  40
719E:  MOVWF  FF6
71A0:  MOVLW  4A
71A2:  MOVWF  FF7
71A4:  CLRF   19
71A6:  BTFSC  FF2.7
71A8:  BSF    19.7
71AA:  BCF    FF2.7
71AC:  MOVLB  0
71AE:  CALL   07A0
71B2:  BTFSC  19.7
71B4:  BSF    FF2.7
71B6:  BRA    71D4
71B8:  MOVLB  9
....................       else fprintf(COM2,"Slaver mode is enable\n\r"); 
71BA:  MOVLW  5A
71BC:  MOVWF  FF6
71BE:  MOVLW  4A
71C0:  MOVWF  FF7
71C2:  CLRF   19
71C4:  BTFSC  FF2.7
71C6:  BSF    19.7
71C8:  BCF    FF2.7
71CA:  MOVLB  0
71CC:  CALL   07A0
71D0:  BTFSC  19.7
71D2:  BSF    FF2.7
....................     
....................    #if defined(SIM900) 
....................       #if defined(twonumber) 
....................          fprintf(COM2,"two numbers mode ver\n\r"); 
71D4:  MOVLW  72
71D6:  MOVWF  FF6
71D8:  MOVLW  4A
71DA:  MOVWF  FF7
71DC:  CLRF   19
71DE:  BTFSC  FF2.7
71E0:  BSF    19.7
71E2:  BCF    FF2.7
71E4:  CALL   07A0
71E8:  BTFSC  19.7
71EA:  BSF    FF2.7
71EC:  CLRF   19
71EE:  BTFSC  FF2.7
71F0:  BSF    19.7
71F2:  BCF    FF2.7
....................          #else    
....................             fprintf(COM2,"one numbers mode ver\n\r"); 
....................       #endif 
....................       //twonumber=read_ext_eeprom(strobe_two_number); 
....................       auto_sending=read_ext_eeprom(strobe_autosending);   
71F4:  MOVLB  A
71F6:  CLRF   xC0
71F8:  MOVLW  93
71FA:  MOVWF  xBF
71FC:  MOVLB  0
71FE:  CALL   395A
7202:  BTFSC  19.7
7204:  BSF    FF2.7
7206:  MOVFF  01,499
....................       if(auto_sending==0)fprintf(COM2,"autosending is disable\n\r"); 
720A:  MOVLB  4
720C:  MOVF   x99,F
720E:  BNZ   722E
7210:  MOVLW  8A
7212:  MOVWF  FF6
7214:  MOVLW  4A
7216:  MOVWF  FF7
7218:  CLRF   19
721A:  BTFSC  FF2.7
721C:  BSF    19.7
721E:  BCF    FF2.7
7220:  MOVLB  0
7222:  CALL   07A0
7226:  BTFSC  19.7
7228:  BSF    FF2.7
722A:  BRA    7248
722C:  MOVLB  4
....................          else fprintf(COM2,"autosending is enable\n\r"); 
722E:  MOVLW  A4
7230:  MOVWF  FF6
7232:  MOVLW  4A
7234:  MOVWF  FF7
7236:  CLRF   19
7238:  BTFSC  FF2.7
723A:  BSF    19.7
723C:  BCF    FF2.7
723E:  MOVLB  0
7240:  CALL   07A0
7244:  BTFSC  19.7
7246:  BSF    FF2.7
....................    #endif 
....................    memset(reply_buffer,0,sizeof(reply_buffer));  
7248:  MOVLW  03
724A:  MOVWF  FEA
724C:  MOVLW  48
724E:  MOVWF  FE9
7250:  CLRF   00
7252:  MOVLW  01
7254:  MOVWF  02
7256:  MOVLW  18
7258:  MOVWF  01
725A:  CALL   4476
....................    memset(msg_data_sending,0,sizeof(msg_data_sending));  
725E:  MOVLW  01
7260:  MOVWF  FEA
7262:  MOVLW  B8
7264:  MOVWF  FE9
7266:  CLRF   00
7268:  MOVLW  01
726A:  MOVWF  02
726C:  MOVLW  18
726E:  MOVWF  01
7270:  CALL   4476
....................     
....................    //save_coutcard(349); 
....................      /* write_ext_eeprom(200,'I'); 
....................       write_ext_eeprom(201,'J'); 
....................       write_ext_eeprom(202,'K'); 
....................        
....................       fprintf(COM2,"reading eeprom =%c",read_ext_eeprom(200)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(201)); 
....................       fprintf(COM2,"%c",read_ext_eeprom(202));*/ 
....................     
....................    while(1) 
....................    { 
....................      #if defined(SIM900) 
....................       count_polling++; 
7274:  MOVLB  4
7276:  INCF   x93,F
7278:  BTFSC  FD8.2
727A:  INCF   x94,F
....................       if(count_polling>=timing_wait) 
727C:  MOVF   x98,W
727E:  SUBWF  x94,W
7280:  BTFSS  FD8.0
7282:  GOTO   991E
7286:  BNZ   7292
7288:  MOVF   x97,W
728A:  SUBWF  x93,W
728C:  BTFSS  FD8.0
728E:  GOTO   991E
....................       { 
....................          count_polling=0; 
7292:  CLRF   x94
7294:  CLRF   x93
....................          //fprintf(COM2,"SIM_state %d\n\r",SIM_state); 
....................          switch(SIM_state) 
7296:  MOVF   x95,W
7298:  ADDLW  EB
729A:  BTFSC  FD8.0
729C:  GOTO   991E
72A0:  ADDLW  15
72A2:  MOVLB  0
72A4:  GOTO   9948
....................          { 
....................             case config_sms: 
....................                receiver_state=1; 
72A8:  MOVLW  01
72AA:  MOVLB  1
72AC:  MOVWF  xB4
....................                //fprintf(COM2,"AT+CMGF=1...\n\r"); 
....................                fprintf(COM1,"AT+CMGF=1\r\n"); 
72AE:  MOVLW  BC
72B0:  MOVWF  FF6
72B2:  MOVLW  4A
72B4:  MOVWF  FF7
72B6:  MOVLB  0
72B8:  CALL   53E0
....................                SIM_state=reading_sms_cmd; 
72BC:  MOVLW  01
72BE:  MOVLB  4
72C0:  MOVWF  x95
....................                timing_wait=1000; 
72C2:  MOVLW  03
72C4:  MOVWF  x98
72C6:  MOVLW  E8
72C8:  MOVWF  x97
....................             break; 
72CA:  GOTO   991E
....................             case reading_sms_cmd:     
....................                booting_done=1; 
72CE:  MOVLW  01
72D0:  MOVLB  1
72D2:  MOVWF  xB5
72D4:  CLRF   19
72D6:  BTFSC  FF2.7
72D8:  BSF    19.7
72DA:  BCF    FF2.7
....................                cards=get_countcard(); 
72DC:  MOVLB  0
72DE:  CALL   3A02
72E2:  BTFSC  19.7
72E4:  BSF    FF2.7
72E6:  MOVFF  02,9CB
72EA:  MOVFF  01,9CA
....................                receiver_state=1; 
72EE:  MOVLW  01
72F0:  MOVLB  1
72F2:  MOVWF  xB4
....................                memset(buffer_uart,0,sizeof(buffer_uart));  
72F4:  MOVWF  FEA
72F6:  MOVLW  4E
72F8:  MOVWF  FE9
72FA:  CLRF   00
72FC:  CLRF   02
72FE:  MOVLW  64
7300:  MOVWF  01
7302:  MOVLB  0
7304:  CALL   4476
....................                memset(mobilenumb,0,sizeof(mobilenumb));  
7308:  MOVLW  04
730A:  MOVWF  FEA
730C:  MOVLW  79
730E:  MOVWF  FE9
7310:  CLRF   00
7312:  CLRF   02
7314:  MOVLW  1A
7316:  MOVWF  01
7318:  CALL   4476
....................                memset(msg_buffer2,0,sizeof(msg_buffer2));                               
731C:  MOVLW  03
731E:  MOVWF  FEA
7320:  MOVLW  16
7322:  MOVWF  FE9
7324:  CLRF   00
7326:  CLRF   02
7328:  MOVLW  32
732A:  MOVWF  01
732C:  CALL   4476
....................                fprintf(COM2,"reading_sms...\n\r"); 
7330:  MOVLW  C8
7332:  MOVWF  FF6
7334:  MOVLW  4A
7336:  MOVWF  FF7
7338:  CLRF   19
733A:  BTFSC  FF2.7
733C:  BSF    19.7
733E:  BCF    FF2.7
7340:  CALL   07A0
7344:  BTFSC  19.7
7346:  BSF    FF2.7
....................                #ASM BCF    0xF94.7 #ENDASM                   
7348:  BCF    F94.7
....................                   fprintf(COM1,"AT+CMGR=1\r\n"); 
734A:  MOVLW  DA
734C:  MOVWF  FF6
734E:  MOVLW  4A
7350:  MOVWF  FF7
7352:  CALL   53E0
....................                #ASM BSF    0xF94.7 #ENDASM 
7356:  BSF    F94.7
....................                //fprintf(COM1,"AT+CPOWD=1\r\n"); 
....................                SIM_state=MSG_avai; 
7358:  MOVLW  02
735A:  MOVLB  4
735C:  MOVWF  x95
....................                UART_index=0; 
735E:  MOVLB  1
7360:  CLRF   xB2
....................                timing_wait=5000; 
7362:  MOVLW  13
7364:  MOVLB  4
7366:  MOVWF  x98
7368:  MOVLW  88
736A:  MOVWF  x97
....................                //fprintf(COM2,"device has %lu charactions\n\r",cards); 
....................             break; 
736C:  GOTO   991E
....................             case MSG_avai: 
....................                //fprintf(COM2,"MSG_avai...\n\r"); 
....................                //temp=checking_msg_avai(); 
....................                fprintf(COM2,"MSG_avai...%d\n\r",temp); 
7370:  MOVLW  E6
7372:  MOVWF  FF6
7374:  MOVLW  4A
7376:  MOVWF  FF7
7378:  CLRF   19
737A:  BTFSC  FF2.7
737C:  BSF    19.7
737E:  BCF    FF2.7
7380:  MOVLW  0B
7382:  MOVLB  A
7384:  MOVWF  xD3
7386:  MOVLB  0
7388:  CALL   1718
738C:  BTFSC  19.7
738E:  BSF    FF2.7
7390:  CLRF   19
7392:  BTFSC  FF2.7
7394:  BSF    19.7
7396:  BCF    FF2.7
7398:  MOVFF  9D3,ABF
739C:  MOVLW  18
739E:  MOVLB  A
73A0:  MOVWF  xC0
73A2:  MOVLB  0
73A4:  CALL   1836
73A8:  BTFSC  19.7
73AA:  BSF    FF2.7
73AC:  CLRF   19
73AE:  BTFSC  FF2.7
73B0:  BSF    19.7
73B2:  BCF    FF2.7
73B4:  MOVLW  0A
73B6:  MOVLB  A
73B8:  MOVWF  xDF
73BA:  MOVLB  0
73BC:  CALL   075A
73C0:  BTFSC  19.7
73C2:  BSF    FF2.7
73C4:  CLRF   19
73C6:  BTFSC  FF2.7
73C8:  BSF    19.7
73CA:  BCF    FF2.7
73CC:  MOVLW  0D
73CE:  MOVLB  A
73D0:  MOVWF  xDF
73D2:  MOVLB  0
73D4:  CALL   075A
73D8:  BTFSC  19.7
73DA:  BSF    FF2.7
....................                //if(temp==1) SIM_state=reading_sms_cmd; 
....................                /*for(i=0;i<100;i++) 
....................                { 
....................                   fprintf(COM2,"%c",buffer_uart[i]);  
....................                }*/ 
....................                SIM_state=analyze_sms;  
73DC:  MOVLW  03
73DE:  MOVLB  4
73E0:  MOVWF  x95
....................                //fprintf(COM2,"\r\ntemp=%d\r\n",temp); 
....................                //timing_wait=2000; 
....................             break; 
73E2:  GOTO   991E
....................             case analyze_sms: 
....................                booting_done=0; 
73E6:  MOVLB  1
73E8:  CLRF   xB5
....................                fprintf(COM2,"analyze_sms...\n\r");  
73EA:  MOVLW  F6
73EC:  MOVWF  FF6
73EE:  MOVLW  4A
73F0:  MOVWF  FF7
73F2:  CLRF   19
73F4:  BTFSC  FF2.7
73F6:  BSF    19.7
73F8:  BCF    FF2.7
73FA:  MOVLB  0
73FC:  CALL   07A0
7400:  BTFSC  19.7
7402:  BSF    FF2.7
7404:  CLRF   19
7406:  BTFSC  FF2.7
7408:  BSF    19.7
740A:  BCF    FF2.7
....................                del_buf(20,msg_buffer1); 
740C:  MOVLW  14
740E:  MOVLB  A
7410:  MOVWF  xC5
7412:  MOVLW  03
7414:  MOVWF  xC7
7416:  MOVLW  02
7418:  MOVWF  xC6
741A:  MOVLB  0
741C:  CALL   3A74
7420:  BTFSC  19.7
7422:  BSF    FF2.7
7424:  CLRF   19
7426:  BTFSC  FF2.7
7428:  BSF    19.7
742A:  BCF    FF2.7
....................                del_buf(50,msg_buffer2); 
742C:  MOVLW  32
742E:  MOVLB  A
7430:  MOVWF  xC5
7432:  MOVLW  03
7434:  MOVWF  xC7
7436:  MOVLW  16
7438:  MOVWF  xC6
743A:  MOVLB  0
743C:  CALL   3A74
7440:  BTFSC  19.7
7442:  BSF    FF2.7
7444:  CLRF   19
7446:  BTFSC  FF2.7
7448:  BSF    19.7
744A:  BCF    FF2.7
....................                del_buf(50,sim_bug); 
744C:  MOVLW  32
744E:  MOVLB  A
7450:  MOVWF  xC5
7452:  MOVLW  02
7454:  MOVWF  xC7
7456:  MOVLW  D0
7458:  MOVWF  xC6
745A:  MOVLB  0
745C:  CALL   3A74
7460:  BTFSC  19.7
7462:  BSF    FF2.7
....................                //memset(msg_buffer1,0,sizeof(msg_buffer1)); 
....................                //memset(msg_buffer2,0,sizeof(msg_buffer2)); 
....................                //memset(sim_bug,0,sizeof(sim_bug)); 
....................                analyzing_msg(sim_bug,mobilenumb); 
7464:  MOVLW  02
7466:  MOVLB  A
7468:  MOVWF  x8F
746A:  MOVLW  D0
746C:  MOVWF  x8E
746E:  MOVLW  04
7470:  MOVWF  x91
7472:  MOVLW  79
7474:  MOVWF  x90
7476:  MOVLB  0
7478:  GOTO   5402
....................                /*for(i=0;i<25;i++) 
....................                { 
....................                   fprintf(COM2,"%d",sim_bug[i]); 
....................                }*/ 
....................                 
....................                memset(buffer_uart,0,sizeof(buffer_uart));  
747C:  MOVLW  01
747E:  MOVWF  FEA
7480:  MOVLW  4E
7482:  MOVWF  FE9
7484:  CLRF   00
7486:  CLRF   02
7488:  MOVLW  64
748A:  MOVWF  01
748C:  CALL   4476
....................                #if defined(twonumber)  
....................                   SIM_state=checking_MN0; 
7490:  MOVLW  12
7492:  MOVLB  4
7494:  MOVWF  x95
....................                   #else SIM_state=checking_MN; 
....................                #endif     
....................                if((mobilenumb[0]==0)&&(mobilenumb[1]==0)&&(mobilenumb[2]==0)&&(mobilenumb[3]==0)&&(mobilenumb[4]==0)) 
7496:  MOVF   x79,F
7498:  BNZ   74D0
749A:  MOVF   x7A,F
749C:  BNZ   74D0
749E:  MOVF   x7B,F
74A0:  BNZ   74D0
74A2:  MOVF   x7C,F
74A4:  BNZ   74D0
74A6:  MOVF   x7D,F
74A8:  BNZ   74D0
....................                { 
....................                   SIM_state= delete_MSG; 
74AA:  MOVLW  06
74AC:  MOVWF  x95
....................                   //SIM_state=config_sms; 
....................                   output_low(rst_sim); 
74AE:  BCF    F94.1
74B0:  BCF    F8B.1
....................                   fprintf(COM2,"the signal is not good, device will reboot\n\r"); 
74B2:  MOVLW  08
74B4:  MOVWF  FF6
74B6:  MOVLW  4B
74B8:  MOVWF  FF7
74BA:  CLRF   19
74BC:  BTFSC  FF2.7
74BE:  BSF    19.7
74C0:  BCF    FF2.7
74C2:  MOVLB  0
74C4:  CALL   07A0
74C8:  BTFSC  19.7
74CA:  BSF    FF2.7
....................                   setup_wdt(WDT_ON); 
74CC:  BSF    FC0.0
74CE:  MOVLB  4
....................                } 
....................                timing_wait=1500; 
74D0:  MOVLW  05
74D2:  MOVWF  x98
74D4:  MOVLW  DC
74D6:  MOVWF  x97
....................                count_char=0; 
74D8:  MOVLB  9
74DA:  CLRF   xD4
....................             break; 
74DC:  MOVLB  4
74DE:  GOTO   991E
....................             #if defined(twonumber)  
....................             case checking_MN0: 
....................                fprintf(COM2,"\n\rchecking the first number\n\r"); 
74E2:  MOVLW  36
74E4:  MOVWF  FF6
74E6:  MOVLW  4B
74E8:  MOVWF  FF7
74EA:  CLRF   19
74EC:  BTFSC  FF2.7
74EE:  BSF    19.7
74F0:  BCF    FF2.7
74F2:  CALL   07A0
74F6:  BTFSC  19.7
74F8:  BSF    FF2.7
....................                fprintf(COM2,"\n\rMobile phone number is "); 
74FA:  MOVLW  54
74FC:  MOVWF  FF6
74FE:  MOVLW  4B
7500:  MOVWF  FF7
7502:  CLRF   19
7504:  BTFSC  FF2.7
7506:  BSF    19.7
7508:  BCF    FF2.7
750A:  CALL   07A0
750E:  BTFSC  19.7
7510:  BSF    FF2.7
....................                for(i=0;i<20;i++) fprintf(COM2,"%c",mobilenumb[i]);  
7512:  MOVLB  9
7514:  CLRF   xD2
7516:  MOVF   xD2,W
7518:  SUBLW  13
751A:  BNC   754A
751C:  CLRF   03
751E:  MOVF   xD2,W
7520:  ADDLW  79
7522:  MOVWF  FE9
7524:  MOVLW  04
7526:  ADDWFC 03,W
7528:  MOVWF  FEA
752A:  MOVFF  FEF,A8E
752E:  CLRF   19
7530:  BTFSC  FF2.7
7532:  BSF    19.7
7534:  BCF    FF2.7
7536:  MOVFF  A8E,ADF
753A:  MOVLB  0
753C:  CALL   075A
7540:  BTFSC  19.7
7542:  BSF    FF2.7
7544:  MOVLB  9
7546:  INCF   xD2,F
7548:  BRA    7516
....................                fprintf(COM2,"\n\rMSG: "); 
754A:  MOVLW  6E
754C:  MOVWF  FF6
754E:  MOVLW  4B
7550:  MOVWF  FF7
7552:  CLRF   19
7554:  BTFSC  FF2.7
7556:  BSF    19.7
7558:  BCF    FF2.7
755A:  MOVLB  0
755C:  CALL   07A0
7560:  BTFSC  19.7
7562:  BSF    FF2.7
....................                for(i=0;i<50;i++) fprintf(COM2,"%c",sim_bug[i]); 
7564:  MOVLB  9
7566:  CLRF   xD2
7568:  MOVF   xD2,W
756A:  SUBLW  31
756C:  BNC   759C
756E:  CLRF   03
7570:  MOVF   xD2,W
7572:  ADDLW  D0
7574:  MOVWF  FE9
7576:  MOVLW  02
7578:  ADDWFC 03,W
757A:  MOVWF  FEA
757C:  MOVFF  FEF,A8E
7580:  CLRF   19
7582:  BTFSC  FF2.7
7584:  BSF    19.7
7586:  BCF    FF2.7
7588:  MOVFF  A8E,ADF
758C:  MOVLB  0
758E:  CALL   075A
7592:  BTFSC  19.7
7594:  BSF    FF2.7
7596:  MOVLB  9
7598:  INCF   xD2,F
759A:  BRA    7568
....................                fprintf(COM2,"\n\rTIME: "); 
759C:  MOVLW  76
759E:  MOVWF  FF6
75A0:  MOVLW  4B
75A2:  MOVWF  FF7
75A4:  CLRF   19
75A6:  BTFSC  FF2.7
75A8:  BSF    19.7
75AA:  BCF    FF2.7
75AC:  MOVLB  0
75AE:  CALL   07A0
75B2:  BTFSC  19.7
75B4:  BSF    FF2.7
....................                for(i=0;i<25;i++) 
75B6:  MOVLB  9
75B8:  CLRF   xD2
75BA:  MOVF   xD2,W
75BC:  SUBLW  18
75BE:  BNC   7604
....................                { 
....................                   if(datetime[i]=='"')break; 
75C0:  CLRF   03
75C2:  MOVF   xD2,W
75C4:  ADDLW  60
75C6:  MOVWF  FE9
75C8:  MOVLW  04
75CA:  ADDWFC 03,W
75CC:  MOVWF  FEA
75CE:  MOVF   FEF,W
75D0:  SUBLW  22
75D2:  BTFSC  FD8.2
75D4:  BRA    7604
....................                   fprintf(COM2,"%c",datetime[i]); 
75D6:  CLRF   03
75D8:  MOVF   xD2,W
75DA:  ADDLW  60
75DC:  MOVWF  FE9
75DE:  MOVLW  04
75E0:  ADDWFC 03,W
75E2:  MOVWF  FEA
75E4:  MOVFF  FEF,A8E
75E8:  CLRF   19
75EA:  BTFSC  FF2.7
75EC:  BSF    19.7
75EE:  BCF    FF2.7
75F0:  MOVFF  A8E,ADF
75F4:  MOVLB  0
75F6:  CALL   075A
75FA:  BTFSC  19.7
75FC:  BSF    FF2.7
75FE:  MOVLB  9
7600:  INCF   xD2,F
7602:  BRA    75BA
....................                } 
....................                EEPROM_read(strobe_mobile_num0,20,msg_buffer1);  
7604:  MOVLW  41
7606:  MOVLB  A
7608:  MOVWF  x8E
760A:  MOVLW  14
760C:  MOVWF  x8F
760E:  MOVLW  03
7610:  MOVWF  x91
7612:  MOVLW  02
7614:  MOVWF  x90
7616:  MOVLB  0
7618:  CALL   5076
....................                strcpy(msg_buffer2,"redoo"); 
761C:  MOVLW  03
761E:  MOVWF  FEA
7620:  MOVLW  16
7622:  MOVWF  FE9
7624:  MOVLW  00
7626:  CALL   01AE
762A:  TBLRD*-
762C:  TBLRD*+
762E:  MOVF   FF5,W
7630:  MOVWF  FEE
7632:  IORLW  00
7634:  BNZ   762C
....................                if(!strncmp(msg_buffer2,sim_bug,5))  
7636:  MOVLW  03
7638:  MOVLB  A
763A:  MOVWF  x8F
763C:  MOVLW  16
763E:  MOVWF  x8E
7640:  MOVLW  02
7642:  MOVWF  x91
7644:  MOVLW  D0
7646:  MOVWF  x90
7648:  CLRF   x93
764A:  MOVLW  05
764C:  MOVWF  x92
764E:  MOVLB  0
7650:  CALL   56A2
7654:  MOVF   01,F
7656:  BNZ   76BA
....................                { 
....................                  fprintf(COM2,"\n\rreset the password\n\r"); 
7658:  MOVLW  80
765A:  MOVWF  FF6
765C:  MOVLW  4B
765E:  MOVWF  FF7
7660:  CLRF   19
7662:  BTFSC  FF2.7
7664:  BSF    19.7
7666:  BCF    FF2.7
7668:  CALL   07A0
766C:  BTFSC  19.7
766E:  BSF    FF2.7
....................                  reset_password(); 
7670:  GOTO   5738
....................                  init_password(); 
7674:  CALL   511E
....................                  reset_2nd_number(); 
7678:  GOTO   576C
....................                  strcpy(reply_buffer,"done"); 
767C:  MOVLW  03
767E:  MOVWF  FEA
7680:  MOVLW  48
7682:  MOVWF  FE9
7684:  MOVLW  00
7686:  CALL   0134
768A:  TBLRD*-
768C:  TBLRD*+
768E:  MOVF   FF5,W
7690:  MOVWF  FEE
7692:  IORLW  00
7694:  BNZ   768C
....................                  fprintf(COM2,"done\n\r"); 
7696:  MOVLW  98
7698:  MOVWF  FF6
769A:  MOVLW  4B
769C:  MOVWF  FF7
769E:  CLRF   19
76A0:  BTFSC  FF2.7
76A2:  BSF    19.7
76A4:  BCF    FF2.7
76A6:  CALL   07A0
76AA:  BTFSC  19.7
76AC:  BSF    FF2.7
....................                  SIM_state=SIM_reply;  
76AE:  MOVLW  0E
76B0:  MOVLB  4
76B2:  MOVWF  x95
....................                  break; 
76B4:  GOTO   991E
76B8:  MOVLB  0
....................                } 
....................                if(!stringcomp(mobilenumb,msg_buffer1))   
76BA:  MOVLW  04
76BC:  MOVLB  A
76BE:  MOVWF  x8F
76C0:  MOVLW  79
76C2:  MOVWF  x8E
76C4:  MOVLW  03
76C6:  MOVWF  x91
76C8:  MOVLW  02
76CA:  MOVWF  x90
76CC:  MOVLB  0
76CE:  CALL   57A2
76D2:  MOVF   01,F
76D4:  BNZ   76FC
....................                { 
....................                   fprintf(COM2,"\n\rchecking phone number is done\n\r");  
76D6:  MOVLW  A0
76D8:  MOVWF  FF6
76DA:  MOVLW  4B
76DC:  MOVWF  FF7
76DE:  CLRF   19
76E0:  BTFSC  FF2.7
76E2:  BSF    19.7
76E4:  BCF    FF2.7
76E6:  CALL   07A0
76EA:  BTFSC  19.7
76EC:  BSF    FF2.7
....................                   updatetime2ds1307(); 
76EE:  CALL   59EC
....................                   SIM_state=doing_sms; 
76F2:  MOVLW  05
76F4:  MOVLB  4
76F6:  MOVWF  x95
....................                } 
76F8:  BRA    794E
76FA:  MOVLB  0
....................                else 
....................                { 
....................                  SIM_state=checking_MN; 
76FC:  MOVLW  04
76FE:  MOVLB  4
7700:  MOVWF  x95
....................                  strcpy(msg_buffer2,"goodbye"); 
7702:  MOVLW  03
7704:  MOVWF  FEA
7706:  MOVLW  16
7708:  MOVWF  FE9
770A:  MOVLW  00
770C:  MOVLB  0
770E:  CALL   01C4
7712:  TBLRD*-
7714:  TBLRD*+
7716:  MOVF   FF5,W
7718:  MOVWF  FEE
771A:  IORLW  00
771C:  BNZ   7714
....................                  if(!strncmp(msg_buffer2,sim_bug,7))  
771E:  MOVLW  03
7720:  MOVLB  A
7722:  MOVWF  x8F
7724:  MOVLW  16
7726:  MOVWF  x8E
7728:  MOVLW  02
772A:  MOVWF  x91
772C:  MOVLW  D0
772E:  MOVWF  x90
7730:  CLRF   x93
7732:  MOVLW  07
7734:  MOVWF  x92
7736:  MOVLB  0
7738:  CALL   56A2
773C:  MOVF   01,F
773E:  BTFSS  FD8.2
7740:  BRA    7950
....................                  { 
....................                    SIM_state=delete_MSG;   
7742:  MOVLW  06
7744:  MOVLB  4
7746:  MOVWF  x95
....................                    for(i=0;i<20;i++)msg_buffer2[i]=sim_bug[i+8];                 
7748:  MOVLB  9
774A:  CLRF   xD2
774C:  MOVF   xD2,W
774E:  SUBLW  13
7750:  BNC   778E
7752:  CLRF   03
7754:  MOVF   xD2,W
7756:  ADDLW  16
7758:  MOVWF  01
775A:  MOVLW  03
775C:  ADDWFC 03,F
775E:  MOVFF  01,A8E
7762:  MOVFF  03,A8F
7766:  MOVLW  08
7768:  MOVLB  9
776A:  ADDWF  xD2,W
776C:  CLRF   03
776E:  ADDLW  D0
7770:  MOVWF  FE9
7772:  MOVLW  02
7774:  ADDWFC 03,W
7776:  MOVWF  FEA
7778:  MOVFF  FEF,A90
777C:  MOVFF  A8F,FEA
7780:  MOVFF  01,FE9
7784:  MOVFF  A90,FEF
7788:  MOVLB  9
778A:  INCF   xD2,F
778C:  BRA    774C
....................                    fprintf(COM2,"\n\rconfigured mobile phone number\n\r");  
778E:  MOVLW  C2
7790:  MOVWF  FF6
7792:  MOVLW  4B
7794:  MOVWF  FF7
7796:  CLRF   19
7798:  BTFSC  FF2.7
779A:  BSF    19.7
779C:  BCF    FF2.7
779E:  MOVLB  0
77A0:  CALL   07A0
77A4:  BTFSC  19.7
77A6:  BSF    FF2.7
....................                    for(i=0;i<20;i++)fprintf(COM2,"%c",msg_buffer2[i]);  
77A8:  MOVLB  9
77AA:  CLRF   xD2
77AC:  MOVF   xD2,W
77AE:  SUBLW  13
77B0:  BNC   77E0
77B2:  CLRF   03
77B4:  MOVF   xD2,W
77B6:  ADDLW  16
77B8:  MOVWF  FE9
77BA:  MOVLW  03
77BC:  ADDWFC 03,W
77BE:  MOVWF  FEA
77C0:  MOVFF  FEF,A8E
77C4:  CLRF   19
77C6:  BTFSC  FF2.7
77C8:  BSF    19.7
77CA:  BCF    FF2.7
77CC:  MOVFF  A8E,ADF
77D0:  MOVLB  0
77D2:  CALL   075A
77D6:  BTFSC  19.7
77D8:  BSF    FF2.7
77DA:  MOVLB  9
77DC:  INCF   xD2,F
77DE:  BRA    77AC
77E0:  CLRF   19
77E2:  BTFSC  FF2.7
77E4:  BSF    19.7
77E6:  BCF    FF2.7
....................                    //for(i=0;i<20;i++)fprintf(COM2,"%d ",msg_buffer2[i]); 
....................                    fprintf(COM2,"\n\r");  
77E8:  MOVLW  0A
77EA:  MOVLB  A
77EC:  MOVWF  xDF
77EE:  MOVLB  0
77F0:  CALL   075A
77F4:  BTFSC  19.7
77F6:  BSF    FF2.7
77F8:  CLRF   19
77FA:  BTFSC  FF2.7
77FC:  BSF    19.7
77FE:  BCF    FF2.7
7800:  MOVLW  0D
7802:  MOVLB  A
7804:  MOVWF  xDF
7806:  MOVLB  0
7808:  CALL   075A
780C:  BTFSC  19.7
780E:  BSF    FF2.7
....................                    EEPROM_read(strobe_pass_addr,20,password); 
7810:  MOVLB  A
7812:  CLRF   x8E
7814:  MOVLW  14
7816:  MOVWF  x8F
7818:  CLRF   x91
781A:  MOVLW  55
781C:  MOVWF  x90
781E:  MOVLB  0
7820:  CALL   5076
....................                    //for(i=0;i<20;i++)fprintf(COM2,"%c",password[i]); 
....................                    for(i=0;i<20;i++) 
7824:  MOVLB  9
7826:  CLRF   xD2
7828:  MOVF   xD2,W
782A:  SUBLW  13
782C:  BNC   784A
....................                    { 
....................                      if(password[i]==0)break; 
782E:  CLRF   03
7830:  MOVF   xD2,W
7832:  ADDLW  55
7834:  MOVWF  FE9
7836:  MOVLW  00
7838:  ADDWFC 03,W
783A:  MOVWF  FEA
783C:  MOVF   FEF,F
783E:  BNZ   7844
7840:  BRA    784A
7842:  BRA    7846
....................                            else count_char++; 
7844:  INCF   xD4,F
7846:  INCF   xD2,F
7848:  BRA    7828
....................                    } 
....................                    //for(i=0;i<20;i++)fprintf(COM2,"%d ",password[i]); 
....................                    //fprintf(COM2,"count_char=%d\n\r",count_char);  
....................                    //fprintf(COM2,"\n\r"); 
....................                    if(!strncmp(password,msg_buffer2,count_char))  
784A:  MOVLB  A
784C:  CLRF   x8F
784E:  MOVLW  55
7850:  MOVWF  x8E
7852:  MOVLW  03
7854:  MOVWF  x91
7856:  MOVLW  16
7858:  MOVWF  x90
785A:  CLRF   x93
785C:  MOVFF  9D4,A92
7860:  MOVLB  0
7862:  CALL   56A2
7866:  MOVF   01,F
7868:  BNZ   7916
....................                    { 
....................                       EEPROM_write(strobe_mobile_num0,20,mobilenumb); 
786A:  MOVLW  41
786C:  MOVLB  A
786E:  MOVWF  xA3
7870:  MOVLW  14
7872:  MOVWF  xA4
7874:  MOVLW  04
7876:  MOVWF  xA6
7878:  MOVLW  79
787A:  MOVWF  xA5
787C:  MOVLB  0
787E:  CALL   50CE
....................                       fprintf(COM2,"changed phone number\n\r("); 
7882:  MOVLW  E6
7884:  MOVWF  FF6
7886:  MOVLW  4B
7888:  MOVWF  FF7
788A:  CLRF   19
788C:  BTFSC  FF2.7
788E:  BSF    19.7
7890:  BCF    FF2.7
7892:  CALL   07A0
7896:  BTFSC  19.7
7898:  BSF    FF2.7
....................                       for(i=0;i<20;i++)fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num0+i));  
789A:  MOVLB  9
789C:  CLRF   xD2
789E:  MOVF   xD2,W
78A0:  SUBLW  13
78A2:  BNC   78E0
78A4:  MOVLW  41
78A6:  ADDWF  xD2,W
78A8:  MOVLB  A
78AA:  MOVWF  x8E
78AC:  CLRF   19
78AE:  BTFSC  FF2.7
78B0:  BSF    19.7
78B2:  BCF    FF2.7
78B4:  CLRF   xC0
78B6:  MOVWF  xBF
78B8:  MOVLB  0
78BA:  CALL   395A
78BE:  BTFSC  19.7
78C0:  BSF    FF2.7
78C2:  MOVFF  01,A8E
78C6:  CLRF   19
78C8:  BTFSC  FF2.7
78CA:  BSF    19.7
78CC:  BCF    FF2.7
78CE:  MOVFF  01,ADF
78D2:  CALL   075A
78D6:  BTFSC  19.7
78D8:  BSF    FF2.7
78DA:  MOVLB  9
78DC:  INCF   xD2,F
78DE:  BRA    789E
....................                       strcpy(reply_buffer,"done"); 
78E0:  MOVLW  03
78E2:  MOVWF  FEA
78E4:  MOVLW  48
78E6:  MOVWF  FE9
78E8:  MOVLW  00
78EA:  MOVLB  0
78EC:  CALL   0134
78F0:  TBLRD*-
78F2:  TBLRD*+
78F4:  MOVF   FF5,W
78F6:  MOVWF  FEE
78F8:  IORLW  00
78FA:  BNZ   78F2
....................                       fprintf(COM2,")\n\r"); 
78FC:  MOVLW  FE
78FE:  MOVWF  FF6
7900:  MOVLW  4B
7902:  MOVWF  FF7
7904:  CLRF   19
7906:  BTFSC  FF2.7
7908:  BSF    19.7
790A:  BCF    FF2.7
790C:  CALL   07A0
7910:  BTFSC  19.7
7912:  BSF    FF2.7
....................                    } 
7914:  BRA    7948
....................                      else 
....................                      { 
....................                         fprintf(COM2,"wrong password\n\r"); 
7916:  MOVLW  02
7918:  MOVWF  FF6
791A:  MOVLW  4C
791C:  MOVWF  FF7
791E:  CLRF   19
7920:  BTFSC  FF2.7
7922:  BSF    19.7
7924:  BCF    FF2.7
7926:  CALL   07A0
792A:  BTFSC  19.7
792C:  BSF    FF2.7
....................                         strcpy(reply_buffer,"wrong password"); 
792E:  MOVLW  03
7930:  MOVWF  FEA
7932:  MOVLW  48
7934:  MOVWF  FE9
7936:  MOVLW  00
7938:  CALL   01DC
793C:  TBLRD*-
793E:  TBLRD*+
7940:  MOVF   FF5,W
7942:  MOVWF  FEE
7944:  IORLW  00
7946:  BNZ   793E
....................                      }                      
....................                    SIM_state=SIM_reply;   
7948:  MOVLW  0E
794A:  MOVLB  4
794C:  MOVWF  x95
794E:  MOVLB  0
....................                  } 
....................  
....................                } 
....................             break; 
7950:  MOVLB  4
7952:  GOTO   991E
....................             #endif  
....................             case checking_MN: 
....................                #if defined(twonumber)  
....................                   fprintf(COM2,"\n\rchecking the second number\n\r"); 
7956:  MOVLW  14
7958:  MOVWF  FF6
795A:  MOVLW  4C
795C:  MOVWF  FF7
795E:  CLRF   19
7960:  BTFSC  FF2.7
7962:  BSF    19.7
7964:  BCF    FF2.7
7966:  CALL   07A0
796A:  BTFSC  19.7
796C:  BSF    FF2.7
....................                #endif 
....................                fprintf(COM2,"\n\rMobile phone number is "); 
796E:  MOVLW  34
7970:  MOVWF  FF6
7972:  MOVLW  4C
7974:  MOVWF  FF7
7976:  CLRF   19
7978:  BTFSC  FF2.7
797A:  BSF    19.7
797C:  BCF    FF2.7
797E:  CALL   07A0
7982:  BTFSC  19.7
7984:  BSF    FF2.7
....................                for(i=0;i<20;i++) fprintf(COM2,"%c",mobilenumb[i]);   
7986:  MOVLB  9
7988:  CLRF   xD2
798A:  MOVF   xD2,W
798C:  SUBLW  13
798E:  BNC   79BE
7990:  CLRF   03
7992:  MOVF   xD2,W
7994:  ADDLW  79
7996:  MOVWF  FE9
7998:  MOVLW  04
799A:  ADDWFC 03,W
799C:  MOVWF  FEA
799E:  MOVFF  FEF,A8E
79A2:  CLRF   19
79A4:  BTFSC  FF2.7
79A6:  BSF    19.7
79A8:  BCF    FF2.7
79AA:  MOVFF  A8E,ADF
79AE:  MOVLB  0
79B0:  CALL   075A
79B4:  BTFSC  19.7
79B6:  BSF    FF2.7
79B8:  MOVLB  9
79BA:  INCF   xD2,F
79BC:  BRA    798A
....................                fprintf(COM2,"\n\rMSG: "); 
79BE:  MOVLW  4E
79C0:  MOVWF  FF6
79C2:  MOVLW  4C
79C4:  MOVWF  FF7
79C6:  CLRF   19
79C8:  BTFSC  FF2.7
79CA:  BSF    19.7
79CC:  BCF    FF2.7
79CE:  MOVLB  0
79D0:  CALL   07A0
79D4:  BTFSC  19.7
79D6:  BSF    FF2.7
....................                for(i=0;i<50;i++) fprintf(COM2,"%c",sim_bug[i]); 
79D8:  MOVLB  9
79DA:  CLRF   xD2
79DC:  MOVF   xD2,W
79DE:  SUBLW  31
79E0:  BNC   7A10
79E2:  CLRF   03
79E4:  MOVF   xD2,W
79E6:  ADDLW  D0
79E8:  MOVWF  FE9
79EA:  MOVLW  02
79EC:  ADDWFC 03,W
79EE:  MOVWF  FEA
79F0:  MOVFF  FEF,A8E
79F4:  CLRF   19
79F6:  BTFSC  FF2.7
79F8:  BSF    19.7
79FA:  BCF    FF2.7
79FC:  MOVFF  A8E,ADF
7A00:  MOVLB  0
7A02:  CALL   075A
7A06:  BTFSC  19.7
7A08:  BSF    FF2.7
7A0A:  MOVLB  9
7A0C:  INCF   xD2,F
7A0E:  BRA    79DC
....................                fprintf(COM2,"\n\rTIME: "); 
7A10:  MOVLW  56
7A12:  MOVWF  FF6
7A14:  MOVLW  4C
7A16:  MOVWF  FF7
7A18:  CLRF   19
7A1A:  BTFSC  FF2.7
7A1C:  BSF    19.7
7A1E:  BCF    FF2.7
7A20:  MOVLB  0
7A22:  CALL   07A0
7A26:  BTFSC  19.7
7A28:  BSF    FF2.7
....................                for(i=0;i<25;i++) 
7A2A:  MOVLB  9
7A2C:  CLRF   xD2
7A2E:  MOVF   xD2,W
7A30:  SUBLW  18
7A32:  BNC   7A78
....................                { 
....................                   if(datetime[i]=='"')break; 
7A34:  CLRF   03
7A36:  MOVF   xD2,W
7A38:  ADDLW  60
7A3A:  MOVWF  FE9
7A3C:  MOVLW  04
7A3E:  ADDWFC 03,W
7A40:  MOVWF  FEA
7A42:  MOVF   FEF,W
7A44:  SUBLW  22
7A46:  BTFSC  FD8.2
7A48:  BRA    7A78
....................                   fprintf(COM2,"%c",datetime[i]); 
7A4A:  CLRF   03
7A4C:  MOVF   xD2,W
7A4E:  ADDLW  60
7A50:  MOVWF  FE9
7A52:  MOVLW  04
7A54:  ADDWFC 03,W
7A56:  MOVWF  FEA
7A58:  MOVFF  FEF,A8E
7A5C:  CLRF   19
7A5E:  BTFSC  FF2.7
7A60:  BSF    19.7
7A62:  BCF    FF2.7
7A64:  MOVFF  A8E,ADF
7A68:  MOVLB  0
7A6A:  CALL   075A
7A6E:  BTFSC  19.7
7A70:  BSF    FF2.7
7A72:  MOVLB  9
7A74:  INCF   xD2,F
7A76:  BRA    7A2E
....................                }               
....................                EEPROM_read(strobe_mobile_num1,20,msg_buffer1);                 
7A78:  MOVLW  55
7A7A:  MOVLB  A
7A7C:  MOVWF  x8E
7A7E:  MOVLW  14
7A80:  MOVWF  x8F
7A82:  MOVLW  03
7A84:  MOVWF  x91
7A86:  MOVLW  02
7A88:  MOVWF  x90
7A8A:  MOVLB  0
7A8C:  CALL   5076
....................               //strcpy(msg_buffer1,"+84903219082"); 
....................               //strcpy(msg_buffer1,"+16612891316");//+16612891316 
....................               #if defined(twonumber)  
....................               #else 
....................               strcpy(msg_buffer2,"redoo"); 
....................               if(!strncmp(msg_buffer2,sim_bug,5))  
....................               { 
....................                  fprintf(COM2,"\n\rreset the password\n\r"); 
....................                  reset_password(); 
....................                  init_password(); 
....................                  strcpy(reply_buffer,"done"); 
....................                  fprintf(COM2,"done\n\r"); 
....................                  SIM_state=SIM_reply;  
....................                  break; 
....................               } 
....................               #endif 
....................               if(!stringcomp(mobilenumb,msg_buffer1))   
7A90:  MOVLW  04
7A92:  MOVLB  A
7A94:  MOVWF  x8F
7A96:  MOVLW  79
7A98:  MOVWF  x8E
7A9A:  MOVLW  03
7A9C:  MOVWF  x91
7A9E:  MOVLW  02
7AA0:  MOVWF  x90
7AA2:  MOVLB  0
7AA4:  CALL   57A2
7AA8:  MOVF   01,F
7AAA:  BNZ   7AD2
....................               { 
....................                   fprintf(COM2,"\n\rchecking phone number is done\n\r");  
7AAC:  MOVLW  60
7AAE:  MOVWF  FF6
7AB0:  MOVLW  4C
7AB2:  MOVWF  FF7
7AB4:  CLRF   19
7AB6:  BTFSC  FF2.7
7AB8:  BSF    19.7
7ABA:  BCF    FF2.7
7ABC:  CALL   07A0
7AC0:  BTFSC  19.7
7AC2:  BSF    FF2.7
....................                   updatetime2ds1307(); 
7AC4:  CALL   59EC
....................                   SIM_state=doing_sms; 
7AC8:  MOVLW  05
7ACA:  MOVLB  4
7ACC:  MOVWF  x95
....................               } 
7ACE:  BRA    7D42
7AD0:  MOVLB  0
....................                else 
....................                { 
....................                  SIM_state=delete_MSG; 
7AD2:  MOVLW  06
7AD4:  MOVLB  4
7AD6:  MOVWF  x95
....................                  strcpy(msg_buffer2,"hello"); 
7AD8:  MOVLW  03
7ADA:  MOVWF  FEA
7ADC:  MOVLW  16
7ADE:  MOVWF  FE9
7AE0:  MOVLW  00
7AE2:  MOVLB  0
7AE4:  CALL   01FC
7AE8:  TBLRD*-
7AEA:  TBLRD*+
7AEC:  MOVF   FF5,W
7AEE:  MOVWF  FEE
7AF0:  IORLW  00
7AF2:  BNZ   7AEA
....................                  if(!strncmp(msg_buffer2,sim_bug,5))  
7AF4:  MOVLW  03
7AF6:  MOVLB  A
7AF8:  MOVWF  x8F
7AFA:  MOVLW  16
7AFC:  MOVWF  x8E
7AFE:  MOVLW  02
7B00:  MOVWF  x91
7B02:  MOVLW  D0
7B04:  MOVWF  x90
7B06:  CLRF   x93
7B08:  MOVLW  05
7B0A:  MOVWF  x92
7B0C:  MOVLB  0
7B0E:  CALL   56A2
7B12:  MOVF   01,F
7B14:  BTFSS  FD8.2
7B16:  BRA    7D28
....................                  { 
....................                    SIM_state=delete_MSG;   
7B18:  MOVLW  06
7B1A:  MOVLB  4
7B1C:  MOVWF  x95
....................                    for(i=0;i<20;i++)msg_buffer2[i]=sim_bug[i+6];                 
7B1E:  MOVLB  9
7B20:  CLRF   xD2
7B22:  MOVF   xD2,W
7B24:  SUBLW  13
7B26:  BNC   7B64
7B28:  CLRF   03
7B2A:  MOVF   xD2,W
7B2C:  ADDLW  16
7B2E:  MOVWF  01
7B30:  MOVLW  03
7B32:  ADDWFC 03,F
7B34:  MOVFF  01,A8E
7B38:  MOVFF  03,A8F
7B3C:  MOVLW  06
7B3E:  MOVLB  9
7B40:  ADDWF  xD2,W
7B42:  CLRF   03
7B44:  ADDLW  D0
7B46:  MOVWF  FE9
7B48:  MOVLW  02
7B4A:  ADDWFC 03,W
7B4C:  MOVWF  FEA
7B4E:  MOVFF  FEF,A90
7B52:  MOVFF  A8F,FEA
7B56:  MOVFF  01,FE9
7B5A:  MOVFF  A90,FEF
7B5E:  MOVLB  9
7B60:  INCF   xD2,F
7B62:  BRA    7B22
....................                    fprintf(COM2,"\n\rconfigured mobile phone number\n\r");  
7B64:  MOVLW  82
7B66:  MOVWF  FF6
7B68:  MOVLW  4C
7B6A:  MOVWF  FF7
7B6C:  CLRF   19
7B6E:  BTFSC  FF2.7
7B70:  BSF    19.7
7B72:  BCF    FF2.7
7B74:  MOVLB  0
7B76:  CALL   07A0
7B7A:  BTFSC  19.7
7B7C:  BSF    FF2.7
....................                    for(i=0;i<20;i++)fprintf(COM2,"%c",msg_buffer2[i]);  
7B7E:  MOVLB  9
7B80:  CLRF   xD2
7B82:  MOVF   xD2,W
7B84:  SUBLW  13
7B86:  BNC   7BB6
7B88:  CLRF   03
7B8A:  MOVF   xD2,W
7B8C:  ADDLW  16
7B8E:  MOVWF  FE9
7B90:  MOVLW  03
7B92:  ADDWFC 03,W
7B94:  MOVWF  FEA
7B96:  MOVFF  FEF,A8E
7B9A:  CLRF   19
7B9C:  BTFSC  FF2.7
7B9E:  BSF    19.7
7BA0:  BCF    FF2.7
7BA2:  MOVFF  A8E,ADF
7BA6:  MOVLB  0
7BA8:  CALL   075A
7BAC:  BTFSC  19.7
7BAE:  BSF    FF2.7
7BB0:  MOVLB  9
7BB2:  INCF   xD2,F
7BB4:  BRA    7B82
7BB6:  CLRF   19
7BB8:  BTFSC  FF2.7
7BBA:  BSF    19.7
7BBC:  BCF    FF2.7
....................                    //for(i=0;i<20;i++)fprintf(COM2,"%d ",msg_buffer2[i]); 
....................                    fprintf(COM2,"\n\r");  
7BBE:  MOVLW  0A
7BC0:  MOVLB  A
7BC2:  MOVWF  xDF
7BC4:  MOVLB  0
7BC6:  CALL   075A
7BCA:  BTFSC  19.7
7BCC:  BSF    FF2.7
7BCE:  CLRF   19
7BD0:  BTFSC  FF2.7
7BD2:  BSF    19.7
7BD4:  BCF    FF2.7
7BD6:  MOVLW  0D
7BD8:  MOVLB  A
7BDA:  MOVWF  xDF
7BDC:  MOVLB  0
7BDE:  CALL   075A
7BE2:  BTFSC  19.7
7BE4:  BSF    FF2.7
....................                    EEPROM_read(strobe_pass_addr,20,password); 
7BE6:  MOVLB  A
7BE8:  CLRF   x8E
7BEA:  MOVLW  14
7BEC:  MOVWF  x8F
7BEE:  CLRF   x91
7BF0:  MOVLW  55
7BF2:  MOVWF  x90
7BF4:  MOVLB  0
7BF6:  CALL   5076
....................                    //for(i=0;i<20;i++)fprintf(COM2,"%c",password[i]); 
....................                    for(i=0;i<20;i++) 
7BFA:  MOVLB  9
7BFC:  CLRF   xD2
7BFE:  MOVF   xD2,W
7C00:  SUBLW  13
7C02:  BNC   7C20
....................                    { 
....................                      if(password[i]==0)break; 
7C04:  CLRF   03
7C06:  MOVF   xD2,W
7C08:  ADDLW  55
7C0A:  MOVWF  FE9
7C0C:  MOVLW  00
7C0E:  ADDWFC 03,W
7C10:  MOVWF  FEA
7C12:  MOVF   FEF,F
7C14:  BNZ   7C1A
7C16:  BRA    7C20
7C18:  BRA    7C1C
....................                            else count_char++; 
7C1A:  INCF   xD4,F
7C1C:  INCF   xD2,F
7C1E:  BRA    7BFE
....................                    } 
....................                    //for(i=0;i<20;i++)fprintf(COM2,"%d ",password[i]); 
....................                    //fprintf(COM2,"count_char=%d\n\r",count_char);  
....................                    //fprintf(COM2,"\n\r"); 
....................                    if(!strncmp(password,msg_buffer2,count_char))  
7C20:  MOVLB  A
7C22:  CLRF   x8F
7C24:  MOVLW  55
7C26:  MOVWF  x8E
7C28:  MOVLW  03
7C2A:  MOVWF  x91
7C2C:  MOVLW  16
7C2E:  MOVWF  x90
7C30:  CLRF   x93
7C32:  MOVFF  9D4,A92
7C36:  MOVLB  0
7C38:  CALL   56A2
7C3C:  MOVF   01,F
7C3E:  BNZ   7CEC
....................                    { 
....................                       EEPROM_write(strobe_mobile_num1,20,mobilenumb); 
7C40:  MOVLW  55
7C42:  MOVLB  A
7C44:  MOVWF  xA3
7C46:  MOVLW  14
7C48:  MOVWF  xA4
7C4A:  MOVLW  04
7C4C:  MOVWF  xA6
7C4E:  MOVLW  79
7C50:  MOVWF  xA5
7C52:  MOVLB  0
7C54:  CALL   50CE
....................                       fprintf(COM2,"changed phone number\n\r("); 
7C58:  MOVLW  A6
7C5A:  MOVWF  FF6
7C5C:  MOVLW  4C
7C5E:  MOVWF  FF7
7C60:  CLRF   19
7C62:  BTFSC  FF2.7
7C64:  BSF    19.7
7C66:  BCF    FF2.7
7C68:  CALL   07A0
7C6C:  BTFSC  19.7
7C6E:  BSF    FF2.7
....................                       for(i=0;i<20;i++)fprintf(COM2,"%c",read_ext_eeprom(strobe_mobile_num1+i));  
7C70:  MOVLB  9
7C72:  CLRF   xD2
7C74:  MOVF   xD2,W
7C76:  SUBLW  13
7C78:  BNC   7CB6
7C7A:  MOVLW  55
7C7C:  ADDWF  xD2,W
7C7E:  MOVLB  A
7C80:  MOVWF  x8E
7C82:  CLRF   19
7C84:  BTFSC  FF2.7
7C86:  BSF    19.7
7C88:  BCF    FF2.7
7C8A:  CLRF   xC0
7C8C:  MOVWF  xBF
7C8E:  MOVLB  0
7C90:  CALL   395A
7C94:  BTFSC  19.7
7C96:  BSF    FF2.7
7C98:  MOVFF  01,A8E
7C9C:  CLRF   19
7C9E:  BTFSC  FF2.7
7CA0:  BSF    19.7
7CA2:  BCF    FF2.7
7CA4:  MOVFF  01,ADF
7CA8:  CALL   075A
7CAC:  BTFSC  19.7
7CAE:  BSF    FF2.7
7CB0:  MOVLB  9
7CB2:  INCF   xD2,F
7CB4:  BRA    7C74
....................                       strcpy(reply_buffer,"done"); 
7CB6:  MOVLW  03
7CB8:  MOVWF  FEA
7CBA:  MOVLW  48
7CBC:  MOVWF  FE9
7CBE:  MOVLW  00
7CC0:  MOVLB  0
7CC2:  CALL   0134
7CC6:  TBLRD*-
7CC8:  TBLRD*+
7CCA:  MOVF   FF5,W
7CCC:  MOVWF  FEE
7CCE:  IORLW  00
7CD0:  BNZ   7CC8
....................                       fprintf(COM2,")\n\r"); 
7CD2:  MOVLW  BE
7CD4:  MOVWF  FF6
7CD6:  MOVLW  4C
7CD8:  MOVWF  FF7
7CDA:  CLRF   19
7CDC:  BTFSC  FF2.7
7CDE:  BSF    19.7
7CE0:  BCF    FF2.7
7CE2:  CALL   07A0
7CE6:  BTFSC  19.7
7CE8:  BSF    FF2.7
....................                    } 
7CEA:  BRA    7D1E
....................                      else 
....................                      { 
....................                         fprintf(COM2,"wrong password\n\r"); 
7CEC:  MOVLW  C2
7CEE:  MOVWF  FF6
7CF0:  MOVLW  4C
7CF2:  MOVWF  FF7
7CF4:  CLRF   19
7CF6:  BTFSC  FF2.7
7CF8:  BSF    19.7
7CFA:  BCF    FF2.7
7CFC:  CALL   07A0
7D00:  BTFSC  19.7
7D02:  BSF    FF2.7
....................                         strcpy(reply_buffer,"wrong password"); 
7D04:  MOVLW  03
7D06:  MOVWF  FEA
7D08:  MOVLW  48
7D0A:  MOVWF  FE9
7D0C:  MOVLW  00
7D0E:  CALL   01DC
7D12:  TBLRD*-
7D14:  TBLRD*+
7D16:  MOVF   FF5,W
7D18:  MOVWF  FEE
7D1A:  IORLW  00
7D1C:  BNZ   7D14
....................                      }                      
....................                    SIM_state=SIM_reply;   
7D1E:  MOVLW  0E
7D20:  MOVLB  4
7D22:  MOVWF  x95
....................                  } 
7D24:  BRA    7D42
7D26:  MOVLB  0
....................                   else fprintf(COM2,"\n\r this phone unable to send commands \n\r"); 
7D28:  MOVLW  D4
7D2A:  MOVWF  FF6
7D2C:  MOVLW  4C
7D2E:  MOVWF  FF7
7D30:  CLRF   19
7D32:  BTFSC  FF2.7
7D34:  BSF    19.7
7D36:  BCF    FF2.7
7D38:  CALL   07A0
7D3C:  BTFSC  19.7
7D3E:  BSF    FF2.7
7D40:  MOVLB  4
....................                } 
....................             break; 
7D42:  GOTO   991E
....................             case doing_sms: 
....................                
....................               memset(msg_data_sending,0,sizeof(msg_data_sending)); 
7D46:  MOVLW  01
7D48:  MOVWF  FEA
7D4A:  MOVLW  B8
7D4C:  MOVWF  FE9
7D4E:  CLRF   00
7D50:  MOVLW  01
7D52:  MOVWF  02
7D54:  MOVLW  18
7D56:  MOVWF  01
7D58:  CALL   4476
....................                
....................               strcpy(msg_buffer2,"password"); 
7D5C:  MOVLW  03
7D5E:  MOVWF  FEA
7D60:  MOVLW  16
7D62:  MOVWF  FE9
7D64:  MOVLW  00
7D66:  CALL   0162
7D6A:  TBLRD*-
7D6C:  TBLRD*+
7D6E:  MOVF   FF5,W
7D70:  MOVWF  FEE
7D72:  IORLW  00
7D74:  BNZ   7D6C
....................               if(!strncmp(msg_buffer2,sim_bug,8))  
7D76:  MOVLW  03
7D78:  MOVLB  A
7D7A:  MOVWF  x8F
7D7C:  MOVLW  16
7D7E:  MOVWF  x8E
7D80:  MOVLW  02
7D82:  MOVWF  x91
7D84:  MOVLW  D0
7D86:  MOVWF  x90
7D88:  CLRF   x93
7D8A:  MOVLW  08
7D8C:  MOVWF  x92
7D8E:  MOVLB  0
7D90:  CALL   56A2
7D94:  MOVF   01,F
7D96:  BTFSS  FD8.2
7D98:  BRA    7EA0
....................               { 
....................                 //SIM_state=delete_MSG;   
....................                 SIM_state=SIM_reply; 
7D9A:  MOVLW  0E
7D9C:  MOVLB  4
7D9E:  MOVWF  x95
....................                 for(i=0;i<20;i++) 
7DA0:  MOVLB  9
7DA2:  CLRF   xD2
7DA4:  MOVF   xD2,W
7DA6:  SUBLW  13
7DA8:  BNC   7DEC
....................                 { 
....................                   write_ext_eeprom(strobe_pass_addr+i,sim_bug[i+9]); 
7DAA:  MOVLW  09
7DAC:  ADDWF  xD2,W
7DAE:  CLRF   03
7DB0:  ADDLW  D0
7DB2:  MOVWF  FE9
7DB4:  MOVLW  02
7DB6:  ADDWFC 03,W
7DB8:  MOVWF  FEA
7DBA:  MOVFF  FEF,A8E
7DBE:  CLRF   19
7DC0:  BTFSC  FF2.7
7DC2:  BSF    19.7
7DC4:  BCF    FF2.7
7DC6:  MOVLB  A
7DC8:  CLRF   xC8
7DCA:  MOVFF  9D2,AC7
7DCE:  MOVFF  A8E,AC9
7DD2:  MOVLB  0
7DD4:  CALL   3E74
7DD8:  BTFSC  19.7
7DDA:  BSF    FF2.7
....................                   delay_us(10); 
7DDC:  MOVLW  1A
7DDE:  MOVWF  00
7DE0:  DECFSZ 00,F
7DE2:  BRA    7DE0
7DE4:  NOP   
7DE6:  MOVLB  9
7DE8:  INCF   xD2,F
7DEA:  BRA    7DA4
....................                 } 
....................                 //EEPROM_write(strobe_pass_addr,20,sim_bug); 
....................                 fprintf(COM2,"changed the password\n\r");               
7DEC:  MOVLW  FE
7DEE:  MOVWF  FF6
7DF0:  MOVLW  4C
7DF2:  MOVWF  FF7
7DF4:  CLRF   19
7DF6:  BTFSC  FF2.7
7DF8:  BSF    19.7
7DFA:  BCF    FF2.7
7DFC:  MOVLB  0
7DFE:  CALL   07A0
7E02:  BTFSC  19.7
7E04:  BSF    FF2.7
....................                 memset(password,0,sizeof(password)); 
7E06:  CLRF   FEA
7E08:  MOVLW  55
7E0A:  MOVWF  FE9
7E0C:  CLRF   00
7E0E:  CLRF   02
7E10:  MOVLW  14
7E12:  MOVWF  01
7E14:  CALL   4476
....................                 EEPROM_read(strobe_pass_addr,20,password); 
7E18:  MOVLB  A
7E1A:  CLRF   x8E
7E1C:  MOVLW  14
7E1E:  MOVWF  x8F
7E20:  CLRF   x91
7E22:  MOVLW  55
7E24:  MOVWF  x90
7E26:  MOVLB  0
7E28:  CALL   5076
....................                 for(i=0;i<20;i++) fprintf(COM2,"%c",password[i]); 
7E2C:  MOVLB  9
7E2E:  CLRF   xD2
7E30:  MOVF   xD2,W
7E32:  SUBLW  13
7E34:  BNC   7E64
7E36:  CLRF   03
7E38:  MOVF   xD2,W
7E3A:  ADDLW  55
7E3C:  MOVWF  FE9
7E3E:  MOVLW  00
7E40:  ADDWFC 03,W
7E42:  MOVWF  FEA
7E44:  MOVFF  FEF,A8E
7E48:  CLRF   19
7E4A:  BTFSC  FF2.7
7E4C:  BSF    19.7
7E4E:  BCF    FF2.7
7E50:  MOVFF  A8E,ADF
7E54:  MOVLB  0
7E56:  CALL   075A
7E5A:  BTFSC  19.7
7E5C:  BSF    FF2.7
7E5E:  MOVLB  9
7E60:  INCF   xD2,F
7E62:  BRA    7E30
....................                 fprintf(COM2,"\n\rexit\n\r"); 
7E64:  MOVLW  16
7E66:  MOVWF  FF6
7E68:  MOVLW  4D
7E6A:  MOVWF  FF7
7E6C:  CLRF   19
7E6E:  BTFSC  FF2.7
7E70:  BSF    19.7
7E72:  BCF    FF2.7
7E74:  MOVLB  0
7E76:  CALL   07A0
7E7A:  BTFSC  19.7
7E7C:  BSF    FF2.7
....................                 strcpy(reply_buffer,"done"); 
7E7E:  MOVLW  03
7E80:  MOVWF  FEA
7E82:  MOVLW  48
7E84:  MOVWF  FE9
7E86:  MOVLW  00
7E88:  CALL   0134
7E8C:  TBLRD*-
7E8E:  TBLRD*+
7E90:  MOVF   FF5,W
7E92:  MOVWF  FEE
7E94:  IORLW  00
7E96:  BNZ   7E8E
....................                 break; 
7E98:  MOVLB  4
7E9A:  GOTO   991E
7E9E:  MOVLB  0
....................               } 
....................                
....................               strcpy(msg_buffer2,"keypress"); 
7EA0:  MOVLW  03
7EA2:  MOVWF  FEA
7EA4:  MOVLW  16
7EA6:  MOVWF  FE9
7EA8:  MOVLW  00
7EAA:  CALL   0212
7EAE:  TBLRD*-
7EB0:  TBLRD*+
7EB2:  MOVF   FF5,W
7EB4:  MOVWF  FEE
7EB6:  IORLW  00
7EB8:  BNZ   7EB0
....................               if(!strncmp(msg_buffer2,sim_bug,8))  
7EBA:  MOVLW  03
7EBC:  MOVLB  A
7EBE:  MOVWF  x8F
7EC0:  MOVLW  16
7EC2:  MOVWF  x8E
7EC4:  MOVLW  02
7EC6:  MOVWF  x91
7EC8:  MOVLW  D0
7ECA:  MOVWF  x90
7ECC:  CLRF   x93
7ECE:  MOVLW  08
7ED0:  MOVWF  x92
7ED2:  MOVLB  0
7ED4:  CALL   56A2
7ED8:  MOVF   01,F
7EDA:  BTFSS  FD8.2
7EDC:  BRA    80C6
....................               { 
....................                 //SIM_state=delete_MSG; 
....................                 //SIM_state=SIM_reply; 
....................                 SIM_state=SIM_reply; 
7EDE:  MOVLW  0E
7EE0:  MOVLB  4
7EE2:  MOVWF  x95
....................                 for(i=0;i<20;i++)msg_buffer2[i]=sim_bug[i+9]; 
7EE4:  MOVLB  9
7EE6:  CLRF   xD2
7EE8:  MOVF   xD2,W
7EEA:  SUBLW  13
7EEC:  BNC   7F2A
7EEE:  CLRF   03
7EF0:  MOVF   xD2,W
7EF2:  ADDLW  16
7EF4:  MOVWF  01
7EF6:  MOVLW  03
7EF8:  ADDWFC 03,F
7EFA:  MOVFF  01,A8E
7EFE:  MOVFF  03,A8F
7F02:  MOVLW  09
7F04:  MOVLB  9
7F06:  ADDWF  xD2,W
7F08:  CLRF   03
7F0A:  ADDLW  D0
7F0C:  MOVWF  FE9
7F0E:  MOVLW  02
7F10:  ADDWFC 03,W
7F12:  MOVWF  FEA
7F14:  MOVFF  FEF,A90
7F18:  MOVFF  A8F,FEA
7F1C:  MOVFF  01,FE9
7F20:  MOVFF  A90,FEF
7F24:  MOVLB  9
7F26:  INCF   xD2,F
7F28:  BRA    7EE8
....................                 strcpy(msg_buffer1,"on"); 
7F2A:  MOVLW  03
7F2C:  MOVWF  FEA
7F2E:  MOVLW  02
7F30:  MOVWF  FE9
7F32:  MOVLW  00
7F34:  MOVLB  0
7F36:  CALL   022C
7F3A:  TBLRD*-
7F3C:  TBLRD*+
7F3E:  MOVF   FF5,W
7F40:  MOVWF  FEE
7F42:  IORLW  00
7F44:  BNZ   7F3C
....................                 if(!strncmp(msg_buffer2,msg_buffer1,2)) 
7F46:  MOVLW  03
7F48:  MOVLB  A
7F4A:  MOVWF  x8F
7F4C:  MOVLW  16
7F4E:  MOVWF  x8E
7F50:  MOVLW  03
7F52:  MOVWF  x91
7F54:  MOVLW  02
7F56:  MOVWF  x90
7F58:  CLRF   x93
7F5A:  MOVWF  x92
7F5C:  MOVLB  0
7F5E:  CALL   56A2
7F62:  MOVF   01,F
7F64:  BNZ   7FDC
....................                 { 
....................                   fprintf(COM2,"\n\rkeypress turn on\n\r"); 
7F66:  MOVLW  20
7F68:  MOVWF  FF6
7F6A:  MOVLW  4D
7F6C:  MOVWF  FF7
7F6E:  CLRF   19
7F70:  BTFSC  FF2.7
7F72:  BSF    19.7
7F74:  BCF    FF2.7
7F76:  CALL   07A0
7F7A:  BTFSC  19.7
7F7C:  BSF    FF2.7
....................                   KP_mode = 1; 
7F7E:  MOVLW  01
7F80:  MOVLB  1
7F82:  MOVWF  x0F
7F84:  CLRF   19
7F86:  BTFSC  FF2.7
7F88:  BSF    19.7
7F8A:  BCF    FF2.7
....................                   write_ext_eeprom(strobe_keypressmode,KP_mode); 
7F8C:  MOVLB  A
7F8E:  CLRF   xC8
7F90:  MOVLW  7F
7F92:  MOVWF  xC7
7F94:  MOVFF  10F,AC9
7F98:  MOVLB  0
7F9A:  CALL   3E74
7F9E:  BTFSC  19.7
7FA0:  BSF    FF2.7
....................                   fprintf(COM2," exit\n\r");                  
7FA2:  MOVLW  36
7FA4:  MOVWF  FF6
7FA6:  MOVLW  4D
7FA8:  MOVWF  FF7
7FAA:  CLRF   19
7FAC:  BTFSC  FF2.7
7FAE:  BSF    19.7
7FB0:  BCF    FF2.7
7FB2:  CALL   07A0
7FB6:  BTFSC  19.7
7FB8:  BSF    FF2.7
....................                   strcpy(reply_buffer,"done"); 
7FBA:  MOVLW  03
7FBC:  MOVWF  FEA
7FBE:  MOVLW  48
7FC0:  MOVWF  FE9
7FC2:  MOVLW  00
7FC4:  CALL   0134
7FC8:  TBLRD*-
7FCA:  TBLRD*+
7FCC:  MOVF   FF5,W
7FCE:  MOVWF  FEE
7FD0:  IORLW  00
7FD2:  BNZ   7FCA
....................                   break; 
7FD4:  MOVLB  4
7FD6:  GOTO   991E
7FDA:  MOVLB  0
....................                 } 
....................                 strcpy(msg_buffer1,"off"); 
7FDC:  MOVLW  03
7FDE:  MOVWF  FEA
7FE0:  MOVLW  02
7FE2:  MOVWF  FE9
7FE4:  MOVLW  00
7FE6:  CALL   0240
7FEA:  TBLRD*-
7FEC:  TBLRD*+
7FEE:  MOVF   FF5,W
7FF0:  MOVWF  FEE
7FF2:  IORLW  00
7FF4:  BNZ   7FEC
....................                 if(!strncmp(msg_buffer2,msg_buffer1,3)) 
7FF6:  MOVLW  03
7FF8:  MOVLB  A
7FFA:  MOVWF  x8F
7FFC:  MOVLW  16
7FFE:  MOVWF  x8E
8000:  MOVLW  03
8002:  MOVWF  x91
8004:  MOVLW  02
8006:  MOVWF  x90
8008:  CLRF   x93
800A:  MOVLW  03
800C:  MOVWF  x92
800E:  MOVLB  0
8010:  CALL   56A2
8014:  MOVF   01,F
8016:  BNZ   808C
....................                 { 
....................                   fprintf(COM2,"\n\rkeypress turn off\n\r"); 
8018:  MOVLW  3E
801A:  MOVWF  FF6
801C:  MOVLW  4D
801E:  MOVWF  FF7
8020:  CLRF   19
8022:  BTFSC  FF2.7
8024:  BSF    19.7
8026:  BCF    FF2.7
8028:  CALL   07A0
802C:  BTFSC  19.7
802E:  BSF    FF2.7
....................                   KP_mode = 0; 
8030:  MOVLB  1
8032:  CLRF   x0F
8034:  CLRF   19
8036:  BTFSC  FF2.7
8038:  BSF    19.7
803A:  BCF    FF2.7
....................                   write_ext_eeprom(strobe_keypressmode,KP_mode); 
803C:  MOVLB  A
803E:  CLRF   xC8
8040:  MOVLW  7F
8042:  MOVWF  xC7
8044:  MOVFF  10F,AC9
8048:  MOVLB  0
804A:  CALL   3E74
804E:  BTFSC  19.7
8050:  BSF    FF2.7
....................                   fprintf(COM2," exit\n\r"); 
8052:  MOVLW  54
8054:  MOVWF  FF6
8056:  MOVLW  4D
8058:  MOVWF  FF7
805A:  CLRF   19
805C:  BTFSC  FF2.7
805E:  BSF    19.7
8060:  BCF    FF2.7
8062:  CALL   07A0
8066:  BTFSC  19.7
8068:  BSF    FF2.7
....................                   strcpy(reply_buffer,"done"); 
806A:  MOVLW  03
806C:  MOVWF  FEA
806E:  MOVLW  48
8070:  MOVWF  FE9
8072:  MOVLW  00
8074:  CALL   0134
8078:  TBLRD*-
807A:  TBLRD*+
807C:  MOVF   FF5,W
807E:  MOVWF  FEE
8080:  IORLW  00
8082:  BNZ   807A
....................                   break; 
8084:  MOVLB  4
8086:  GOTO   991E
808A:  MOVLB  0
....................                 } 
....................                 strcpy(reply_buffer,"please check your syntax");  
808C:  MOVLW  03
808E:  MOVWF  FEA
8090:  MOVLW  48
8092:  MOVWF  FE9
8094:  MOVLW  00
8096:  CALL   0254
809A:  TBLRD*-
809C:  TBLRD*+
809E:  MOVF   FF5,W
80A0:  MOVWF  FEE
80A2:  IORLW  00
80A4:  BNZ   809C
....................                 fprintf(COM2,"\n\rplease check your syntax\n\r"); 
80A6:  MOVLW  5C
80A8:  MOVWF  FF6
80AA:  MOVLW  4D
80AC:  MOVWF  FF7
80AE:  CLRF   19
80B0:  BTFSC  FF2.7
80B2:  BSF    19.7
80B4:  BCF    FF2.7
80B6:  CALL   07A0
80BA:  BTFSC  19.7
80BC:  BSF    FF2.7
....................                 break; 
80BE:  MOVLB  4
80C0:  GOTO   991E
80C4:  MOVLB  0
....................               } 
....................               strcpy(msg_buffer2,"master"); 
80C6:  MOVLW  03
80C8:  MOVWF  FEA
80CA:  MOVLW  16
80CC:  MOVWF  FE9
80CE:  MOVLW  00
80D0:  CALL   027E
80D4:  TBLRD*-
80D6:  TBLRD*+
80D8:  MOVF   FF5,W
80DA:  MOVWF  FEE
80DC:  IORLW  00
80DE:  BNZ   80D6
....................               if(!strncmp(msg_buffer2,sim_bug,6))  
80E0:  MOVLW  03
80E2:  MOVLB  A
80E4:  MOVWF  x8F
80E6:  MOVLW  16
80E8:  MOVWF  x8E
80EA:  MOVLW  02
80EC:  MOVWF  x91
80EE:  MOVLW  D0
80F0:  MOVWF  x90
80F2:  CLRF   x93
80F4:  MOVLW  06
80F6:  MOVWF  x92
80F8:  MOVLB  0
80FA:  CALL   56A2
80FE:  MOVF   01,F
8100:  BTFSS  FD8.2
8102:  BRA    82EC
....................               { 
....................                 //SIM_state=delete_MSG; 
....................                 SIM_state=SIM_reply; 
8104:  MOVLW  0E
8106:  MOVLB  4
8108:  MOVWF  x95
....................                 for(i=0;i<20;i++)msg_buffer2[i]=sim_bug[i+7]; 
810A:  MOVLB  9
810C:  CLRF   xD2
810E:  MOVF   xD2,W
8110:  SUBLW  13
8112:  BNC   8150
8114:  CLRF   03
8116:  MOVF   xD2,W
8118:  ADDLW  16
811A:  MOVWF  01
811C:  MOVLW  03
811E:  ADDWFC 03,F
8120:  MOVFF  01,A8E
8124:  MOVFF  03,A8F
8128:  MOVLW  07
812A:  MOVLB  9
812C:  ADDWF  xD2,W
812E:  CLRF   03
8130:  ADDLW  D0
8132:  MOVWF  FE9
8134:  MOVLW  02
8136:  ADDWFC 03,W
8138:  MOVWF  FEA
813A:  MOVFF  FEF,A90
813E:  MOVFF  A8F,FEA
8142:  MOVFF  01,FE9
8146:  MOVFF  A90,FEF
814A:  MOVLB  9
814C:  INCF   xD2,F
814E:  BRA    810E
....................                 strcpy(msg_buffer1,"on"); 
8150:  MOVLW  03
8152:  MOVWF  FEA
8154:  MOVLW  02
8156:  MOVWF  FE9
8158:  MOVLW  00
815A:  MOVLB  0
815C:  CALL   022C
8160:  TBLRD*-
8162:  TBLRD*+
8164:  MOVF   FF5,W
8166:  MOVWF  FEE
8168:  IORLW  00
816A:  BNZ   8162
....................                 if(!strncmp(msg_buffer2,msg_buffer1,2)) 
816C:  MOVLW  03
816E:  MOVLB  A
8170:  MOVWF  x8F
8172:  MOVLW  16
8174:  MOVWF  x8E
8176:  MOVLW  03
8178:  MOVWF  x91
817A:  MOVLW  02
817C:  MOVWF  x90
817E:  CLRF   x93
8180:  MOVWF  x92
8182:  MOVLB  0
8184:  CALL   56A2
8188:  MOVF   01,F
818A:  BNZ   8200
....................                 { 
....................                   fprintf(COM2,"\n\rmaster mode turn on\n\r"); 
818C:  MOVLW  7A
818E:  MOVWF  FF6
8190:  MOVLW  4D
8192:  MOVWF  FF7
8194:  CLRF   19
8196:  BTFSC  FF2.7
8198:  BSF    19.7
819A:  BCF    FF2.7
819C:  CALL   07A0
81A0:  BTFSC  19.7
81A2:  BSF    FF2.7
....................                    mode_sl = 0; 
81A4:  MOVLB  9
81A6:  CLRF   xB3
81A8:  CLRF   19
81AA:  BTFSC  FF2.7
81AC:  BSF    19.7
81AE:  BCF    FF2.7
....................                    write_ext_eeprom(strobe_Master_SLV,mode_sl); 
81B0:  MOVLB  A
81B2:  CLRF   xC8
81B4:  MOVLW  91
81B6:  MOVWF  xC7
81B8:  MOVFF  9B3,AC9
81BC:  MOVLB  0
81BE:  CALL   3E74
81C2:  BTFSC  19.7
81C4:  BSF    FF2.7
....................                    strcpy(reply_buffer,"done"); 
81C6:  MOVLW  03
81C8:  MOVWF  FEA
81CA:  MOVLW  48
81CC:  MOVWF  FE9
81CE:  MOVLW  00
81D0:  CALL   0134
81D4:  TBLRD*-
81D6:  TBLRD*+
81D8:  MOVF   FF5,W
81DA:  MOVWF  FEE
81DC:  IORLW  00
81DE:  BNZ   81D6
....................                    fprintf(COM2," exit\n\r"); 
81E0:  MOVLW  92
81E2:  MOVWF  FF6
81E4:  MOVLW  4D
81E6:  MOVWF  FF7
81E8:  CLRF   19
81EA:  BTFSC  FF2.7
81EC:  BSF    19.7
81EE:  BCF    FF2.7
81F0:  CALL   07A0
81F4:  BTFSC  19.7
81F6:  BSF    FF2.7
....................                    break; 
81F8:  MOVLB  4
81FA:  GOTO   991E
81FE:  MOVLB  0
....................                 } 
....................                 strcpy(msg_buffer1,"off"); 
8200:  MOVLW  03
8202:  MOVWF  FEA
8204:  MOVLW  02
8206:  MOVWF  FE9
8208:  MOVLW  00
820A:  CALL   0240
820E:  TBLRD*-
8210:  TBLRD*+
8212:  MOVF   FF5,W
8214:  MOVWF  FEE
8216:  IORLW  00
8218:  BNZ   8210
....................                 if(!strncmp(msg_buffer2,msg_buffer1,3)) 
821A:  MOVLW  03
821C:  MOVLB  A
821E:  MOVWF  x8F
8220:  MOVLW  16
8222:  MOVWF  x8E
8224:  MOVLW  03
8226:  MOVWF  x91
8228:  MOVLW  02
822A:  MOVWF  x90
822C:  CLRF   x93
822E:  MOVLW  03
8230:  MOVWF  x92
8232:  MOVLB  0
8234:  CALL   56A2
8238:  MOVF   01,F
823A:  BNZ   82B2
....................                 { 
....................                   fprintf(COM2,"\n\rmaster mode turn off\n\r"); 
823C:  MOVLW  9A
823E:  MOVWF  FF6
8240:  MOVLW  4D
8242:  MOVWF  FF7
8244:  CLRF   19
8246:  BTFSC  FF2.7
8248:  BSF    19.7
824A:  BCF    FF2.7
824C:  CALL   07A0
8250:  BTFSC  19.7
8252:  BSF    FF2.7
....................                   mode_sl = 1; 
8254:  MOVLW  01
8256:  MOVLB  9
8258:  MOVWF  xB3
825A:  CLRF   19
825C:  BTFSC  FF2.7
825E:  BSF    19.7
8260:  BCF    FF2.7
....................                   write_ext_eeprom(strobe_Master_SLV,mode_sl); 
8262:  MOVLB  A
8264:  CLRF   xC8
8266:  MOVLW  91
8268:  MOVWF  xC7
826A:  MOVFF  9B3,AC9
826E:  MOVLB  0
8270:  CALL   3E74
8274:  BTFSC  19.7
8276:  BSF    FF2.7
....................                   strcpy(reply_buffer,"done"); 
8278:  MOVLW  03
827A:  MOVWF  FEA
827C:  MOVLW  48
827E:  MOVWF  FE9
8280:  MOVLW  00
8282:  CALL   0134
8286:  TBLRD*-
8288:  TBLRD*+
828A:  MOVF   FF5,W
828C:  MOVWF  FEE
828E:  IORLW  00
8290:  BNZ   8288
....................                   fprintf(COM2," exit\n\r"); 
8292:  MOVLW  B4
8294:  MOVWF  FF6
8296:  MOVLW  4D
8298:  MOVWF  FF7
829A:  CLRF   19
829C:  BTFSC  FF2.7
829E:  BSF    19.7
82A0:  BCF    FF2.7
82A2:  CALL   07A0
82A6:  BTFSC  19.7
82A8:  BSF    FF2.7
....................                   break; 
82AA:  MOVLB  4
82AC:  GOTO   991E
82B0:  MOVLB  0
....................                 } 
....................                 strcpy(reply_buffer,"please check your syntax");  
82B2:  MOVLW  03
82B4:  MOVWF  FEA
82B6:  MOVLW  48
82B8:  MOVWF  FE9
82BA:  MOVLW  00
82BC:  CALL   0254
82C0:  TBLRD*-
82C2:  TBLRD*+
82C4:  MOVF   FF5,W
82C6:  MOVWF  FEE
82C8:  IORLW  00
82CA:  BNZ   82C2
....................                 fprintf(COM2,"\n\rplease check your syntax\n\r"); 
82CC:  MOVLW  BC
82CE:  MOVWF  FF6
82D0:  MOVLW  4D
82D2:  MOVWF  FF7
82D4:  CLRF   19
82D6:  BTFSC  FF2.7
82D8:  BSF    19.7
82DA:  BCF    FF2.7
82DC:  CALL   07A0
82E0:  BTFSC  19.7
82E2:  BSF    FF2.7
....................                 break; 
82E4:  MOVLB  4
82E6:  GOTO   991E
82EA:  MOVLB  0
....................               } 
....................                
....................               strcpy(msg_buffer2,"rsfact"); 
82EC:  MOVLW  03
82EE:  MOVWF  FEA
82F0:  MOVLW  16
82F2:  MOVWF  FE9
82F4:  MOVLW  00
82F6:  CALL   014A
82FA:  TBLRD*-
82FC:  TBLRD*+
82FE:  MOVF   FF5,W
8300:  MOVWF  FEE
8302:  IORLW  00
8304:  BNZ   82FC
....................               if(!strncmp(msg_buffer2,sim_bug,6))  
8306:  MOVLW  03
8308:  MOVLB  A
830A:  MOVWF  x8F
830C:  MOVLW  16
830E:  MOVWF  x8E
8310:  MOVLW  02
8312:  MOVWF  x91
8314:  MOVLW  D0
8316:  MOVWF  x90
8318:  CLRF   x93
831A:  MOVLW  06
831C:  MOVWF  x92
831E:  MOVLB  0
8320:  CALL   56A2
8324:  MOVF   01,F
8326:  BNZ   836E
....................               { 
....................                   //SIM_state=delete_MSG; 
....................                   SIM_state=SIM_reply; 
8328:  MOVLW  0E
832A:  MOVLB  4
832C:  MOVWF  x95
....................                   fprintf(COM2,"reset factory\n\r"); 
832E:  MOVLW  DA
8330:  MOVWF  FF6
8332:  MOVLW  4D
8334:  MOVWF  FF7
8336:  CLRF   19
8338:  BTFSC  FF2.7
833A:  BSF    19.7
833C:  BCF    FF2.7
833E:  MOVLB  0
8340:  CALL   07A0
8344:  BTFSC  19.7
8346:  BSF    FF2.7
....................                   rstfact(); 
8348:  GOTO   5A54
....................                   strcpy(reply_buffer,"done"); 
834C:  MOVLW  03
834E:  MOVWF  FEA
8350:  MOVLW  48
8352:  MOVWF  FE9
8354:  MOVLW  00
8356:  CALL   0134
835A:  TBLRD*-
835C:  TBLRD*+
835E:  MOVF   FF5,W
8360:  MOVWF  FEE
8362:  IORLW  00
8364:  BNZ   835C
....................                   break; 
8366:  MOVLB  4
8368:  GOTO   991E
836C:  MOVLB  0
....................               }    
....................               strcpy(msg_buffer2,"kofkb new"); 
836E:  MOVLW  03
8370:  MOVWF  FEA
8372:  MOVLW  16
8374:  MOVWF  FE9
8376:  MOVLW  00
8378:  CALL   0296
837C:  TBLRD*-
837E:  TBLRD*+
8380:  MOVF   FF5,W
8382:  MOVWF  FEE
8384:  IORLW  00
8386:  BNZ   837E
....................               if(!strncmp(msg_buffer2,sim_bug,9))  
8388:  MOVLW  03
838A:  MOVLB  A
838C:  MOVWF  x8F
838E:  MOVLW  16
8390:  MOVWF  x8E
8392:  MOVLW  02
8394:  MOVWF  x91
8396:  MOVLW  D0
8398:  MOVWF  x90
839A:  CLRF   x93
839C:  MOVLW  09
839E:  MOVWF  x92
83A0:  MOVLB  0
83A2:  CALL   56A2
83A6:  MOVF   01,F
83A8:  BNZ   8410
....................               { 
....................                   //SIM_state=delete_MSG; 
....................                   SIM_state=SIM_reply; 
83AA:  MOVLW  0E
83AC:  MOVLB  4
83AE:  MOVWF  x95
....................                   fprintf(COM2,"changed to new keyboard\n\r"); 
83B0:  MOVLW  EA
83B2:  MOVWF  FF6
83B4:  MOVLW  4D
83B6:  MOVWF  FF7
83B8:  CLRF   19
83BA:  BTFSC  FF2.7
83BC:  BSF    19.7
83BE:  BCF    FF2.7
83C0:  MOVLB  0
83C2:  CALL   07A0
83C6:  BTFSC  19.7
83C8:  BSF    FF2.7
....................                   type_KB=1; 
83CA:  MOVLW  01
83CC:  MOVLB  1
83CE:  MOVWF  x13
83D0:  CLRF   19
83D2:  BTFSC  FF2.7
83D4:  BSF    19.7
83D6:  BCF    FF2.7
....................                   write_ext_eeprom(kindofKB,type_KB); 
83D8:  MOVLB  A
83DA:  CLRF   xC8
83DC:  MOVLW  7E
83DE:  MOVWF  xC7
83E0:  MOVFF  113,AC9
83E4:  MOVLB  0
83E6:  CALL   3E74
83EA:  BTFSC  19.7
83EC:  BSF    FF2.7
....................                   strcpy(reply_buffer,"done"); 
83EE:  MOVLW  03
83F0:  MOVWF  FEA
83F2:  MOVLW  48
83F4:  MOVWF  FE9
83F6:  MOVLW  00
83F8:  CALL   0134
83FC:  TBLRD*-
83FE:  TBLRD*+
8400:  MOVF   FF5,W
8402:  MOVWF  FEE
8404:  IORLW  00
8406:  BNZ   83FE
....................                   break; 
8408:  MOVLB  4
840A:  GOTO   991E
840E:  MOVLB  0
....................               } 
....................               strcpy(msg_buffer2,"kofkb old"); 
8410:  MOVLW  03
8412:  MOVWF  FEA
8414:  MOVLW  16
8416:  MOVWF  FE9
8418:  MOVLW  00
841A:  CALL   02B0
841E:  TBLRD*-
8420:  TBLRD*+
8422:  MOVF   FF5,W
8424:  MOVWF  FEE
8426:  IORLW  00
8428:  BNZ   8420
....................               if(!strncmp(msg_buffer2,sim_bug,9))  
842A:  MOVLW  03
842C:  MOVLB  A
842E:  MOVWF  x8F
8430:  MOVLW  16
8432:  MOVWF  x8E
8434:  MOVLW  02
8436:  MOVWF  x91
8438:  MOVLW  D0
843A:  MOVWF  x90
843C:  CLRF   x93
843E:  MOVLW  09
8440:  MOVWF  x92
8442:  MOVLB  0
8444:  CALL   56A2
8448:  MOVF   01,F
844A:  BNZ   84B0
....................               { 
....................                   //SIM_state=delete_MSG; 
....................                   SIM_state=SIM_reply; 
844C:  MOVLW  0E
844E:  MOVLB  4
8450:  MOVWF  x95
....................                   fprintf(COM2,"changed to old keyboard\n\r"); 
8452:  MOVLW  04
8454:  MOVWF  FF6
8456:  MOVLW  4E
8458:  MOVWF  FF7
845A:  CLRF   19
845C:  BTFSC  FF2.7
845E:  BSF    19.7
8460:  BCF    FF2.7
8462:  MOVLB  0
8464:  CALL   07A0
8468:  BTFSC  19.7
846A:  BSF    FF2.7
....................                   type_KB=0; 
846C:  MOVLB  1
846E:  CLRF   x13
8470:  CLRF   19
8472:  BTFSC  FF2.7
8474:  BSF    19.7
8476:  BCF    FF2.7
....................                   write_ext_eeprom(kindofKB,type_KB); 
8478:  MOVLB  A
847A:  CLRF   xC8
847C:  MOVLW  7E
847E:  MOVWF  xC7
8480:  MOVFF  113,AC9
8484:  MOVLB  0
8486:  CALL   3E74
848A:  BTFSC  19.7
848C:  BSF    FF2.7
....................                   strcpy(reply_buffer,"done"); 
848E:  MOVLW  03
8490:  MOVWF  FEA
8492:  MOVLW  48
8494:  MOVWF  FE9
8496:  MOVLW  00
8498:  CALL   0134
849C:  TBLRD*-
849E:  TBLRD*+
84A0:  MOVF   FF5,W
84A2:  MOVWF  FEE
84A4:  IORLW  00
84A6:  BNZ   849E
....................                   break; 
84A8:  MOVLB  4
84AA:  GOTO   991E
84AE:  MOVLB  0
....................               } 
....................               strcpy(msg_buffer2,"trantime"); 
84B0:  MOVLW  03
84B2:  MOVWF  FEA
84B4:  MOVLW  16
84B6:  MOVWF  FE9
84B8:  MOVLW  00
84BA:  CALL   02CA
84BE:  TBLRD*-
84C0:  TBLRD*+
84C2:  MOVF   FF5,W
84C4:  MOVWF  FEE
84C6:  IORLW  00
84C8:  BNZ   84C0
....................               if(!strncmp(msg_buffer2,sim_bug,8))  
84CA:  MOVLW  03
84CC:  MOVLB  A
84CE:  MOVWF  x8F
84D0:  MOVLW  16
84D2:  MOVWF  x8E
84D4:  MOVLW  02
84D6:  MOVWF  x91
84D8:  MOVLW  D0
84DA:  MOVWF  x90
84DC:  CLRF   x93
84DE:  MOVLW  08
84E0:  MOVWF  x92
84E2:  MOVLB  0
84E4:  CALL   56A2
84E8:  MOVF   01,F
84EA:  BTFSS  FD8.2
84EC:  BRA    8634
....................               { 
....................                 //SIM_state=delete_MSG; 
....................                 SIM_state=SIM_reply; 
84EE:  MOVLW  0E
84F0:  MOVLB  4
84F2:  MOVWF  x95
....................                 memset(msg_buffer2,0,sizeof(msg_buffer2)); 
84F4:  MOVLW  03
84F6:  MOVWF  FEA
84F8:  MOVLW  16
84FA:  MOVWF  FE9
84FC:  CLRF   00
84FE:  CLRF   02
8500:  MOVLW  32
8502:  MOVWF  01
8504:  MOVLB  0
8506:  CALL   4476
....................                 //for(i=0;i<3;i++)msg_buffer2[i]=sim_bug[i+9]; 
....................                 if((sim_bug[9]>47)&&(sim_bug[9]<58))  
850A:  MOVLB  2
850C:  MOVF   xD9,W
850E:  SUBLW  2F
8510:  BC    85F4
8512:  MOVF   xD9,W
8514:  SUBLW  39
8516:  BNC   85F4
....................                 { 
....................                    delaycharaction = (sim_bug[9]-48)*10; 
8518:  MOVLW  30
851A:  SUBWF  xD9,W
851C:  MULLW  0A
851E:  MOVFF  FF3,146
8522:  MOVLB  1
....................                    if((sim_bug[10]>47)&&(sim_bug[10]<58))delaycharaction=delaycharaction+(sim_bug[10]-48); 
8524:  MOVLB  2
8526:  MOVF   xDA,W
8528:  SUBLW  2F
852A:  BC    853E
852C:  MOVF   xDA,W
852E:  SUBLW  39
8530:  BNC   853E
8532:  MOVLW  30
8534:  SUBWF  xDA,W
8536:  MOVLB  1
8538:  ADDWF  x46,F
853A:  BRA    8546
853C:  MOVLB  2
....................                      else delaycharaction = sim_bug[9]-48; 
853E:  MOVLW  30
8540:  SUBWF  xD9,W
8542:  MOVLB  1
8544:  MOVWF  x46
....................                   fprintf(COM2,"tran time = %d\n\r",delaycharaction);   
8546:  MOVLW  1E
8548:  MOVWF  FF6
854A:  MOVLW  4E
854C:  MOVWF  FF7
854E:  CLRF   19
8550:  BTFSC  FF2.7
8552:  BSF    19.7
8554:  BCF    FF2.7
8556:  MOVLW  0C
8558:  MOVLB  A
855A:  MOVWF  xD3
855C:  MOVLB  0
855E:  CALL   1718
8562:  BTFSC  19.7
8564:  BSF    FF2.7
8566:  CLRF   19
8568:  BTFSC  FF2.7
856A:  BSF    19.7
856C:  BCF    FF2.7
856E:  MOVFF  146,ABF
8572:  MOVLW  18
8574:  MOVLB  A
8576:  MOVWF  xC0
8578:  MOVLB  0
857A:  CALL   1836
857E:  BTFSC  19.7
8580:  BSF    FF2.7
8582:  CLRF   19
8584:  BTFSC  FF2.7
8586:  BSF    19.7
8588:  BCF    FF2.7
858A:  MOVLW  0A
858C:  MOVLB  A
858E:  MOVWF  xDF
8590:  MOVLB  0
8592:  CALL   075A
8596:  BTFSC  19.7
8598:  BSF    FF2.7
859A:  CLRF   19
859C:  BTFSC  FF2.7
859E:  BSF    19.7
85A0:  BCF    FF2.7
85A2:  MOVLW  0D
85A4:  MOVLB  A
85A6:  MOVWF  xDF
85A8:  MOVLB  0
85AA:  CALL   075A
85AE:  BTFSC  19.7
85B0:  BSF    FF2.7
85B2:  CLRF   19
85B4:  BTFSC  FF2.7
85B6:  BSF    19.7
85B8:  BCF    FF2.7
....................                   write_ext_eeprom(strobe_delaytime,delaycharaction); 
85BA:  MOVLB  A
85BC:  CLRF   xC8
85BE:  MOVLW  94
85C0:  MOVWF  xC7
85C2:  MOVFF  146,AC9
85C6:  MOVLB  0
85C8:  CALL   3E74
85CC:  BTFSC  19.7
85CE:  BSF    FF2.7
....................                   strcpy(reply_buffer,"done"); 
85D0:  MOVLW  03
85D2:  MOVWF  FEA
85D4:  MOVLW  48
85D6:  MOVWF  FE9
85D8:  MOVLW  00
85DA:  CALL   0134
85DE:  TBLRD*-
85E0:  TBLRD*+
85E2:  MOVF   FF5,W
85E4:  MOVWF  FEE
85E6:  IORLW  00
85E8:  BNZ   85E0
....................                   break; 
85EA:  MOVLB  4
85EC:  GOTO   991E
....................                 } 
85F0:  BRA    862E
85F2:  MOVLB  2
....................                   else  
....................                      { 
....................                         fprintf(COM2,"\n\rplease check your syntax\n\r"); 
85F4:  MOVLW  30
85F6:  MOVWF  FF6
85F8:  MOVLW  4E
85FA:  MOVWF  FF7
85FC:  CLRF   19
85FE:  BTFSC  FF2.7
8600:  BSF    19.7
8602:  BCF    FF2.7
8604:  MOVLB  0
8606:  CALL   07A0
860A:  BTFSC  19.7
860C:  BSF    FF2.7
....................                         strcpy(reply_buffer,"please check your syntax");  
860E:  MOVLW  03
8610:  MOVWF  FEA
8612:  MOVLW  48
8614:  MOVWF  FE9
8616:  MOVLW  00
8618:  CALL   0254
861C:  TBLRD*-
861E:  TBLRD*+
8620:  MOVF   FF5,W
8622:  MOVWF  FEE
8624:  IORLW  00
8626:  BNZ   861E
....................                         break; 
8628:  MOVLB  4
862A:  GOTO   991E
....................                      } 
....................                 break; 
862E:  GOTO   991E
8632:  MOVLB  0
....................               } 
....................                 
....................               strcpy(msg_buffer2,"autosending"); 
8634:  MOVLW  03
8636:  MOVWF  FEA
8638:  MOVLW  16
863A:  MOVWF  FE9
863C:  MOVLW  00
863E:  CALL   02E4
8642:  TBLRD*-
8644:  TBLRD*+
8646:  MOVF   FF5,W
8648:  MOVWF  FEE
864A:  IORLW  00
864C:  BNZ   8644
....................               if(!strncmp(msg_buffer2,sim_bug,11))  
864E:  MOVLW  03
8650:  MOVLB  A
8652:  MOVWF  x8F
8654:  MOVLW  16
8656:  MOVWF  x8E
8658:  MOVLW  02
865A:  MOVWF  x91
865C:  MOVLW  D0
865E:  MOVWF  x90
8660:  CLRF   x93
8662:  MOVLW  0B
8664:  MOVWF  x92
8666:  MOVLB  0
8668:  CALL   56A2
866C:  MOVF   01,F
866E:  BTFSS  FD8.2
8670:  BRA    8860
....................               { 
....................                 //SIM_state=delete_MSG; 
....................                 SIM_state=SIM_reply; 
8672:  MOVLW  0E
8674:  MOVLB  4
8676:  MOVWF  x95
....................                 for(i=0;i<20;i++)msg_buffer2[i]=sim_bug[i+12]; 
8678:  MOVLB  9
867A:  CLRF   xD2
867C:  MOVF   xD2,W
867E:  SUBLW  13
8680:  BNC   86BE
8682:  CLRF   03
8684:  MOVF   xD2,W
8686:  ADDLW  16
8688:  MOVWF  01
868A:  MOVLW  03
868C:  ADDWFC 03,F
868E:  MOVFF  01,A8E
8692:  MOVFF  03,A8F
8696:  MOVLW  0C
8698:  MOVLB  9
869A:  ADDWF  xD2,W
869C:  CLRF   03
869E:  ADDLW  D0
86A0:  MOVWF  FE9
86A2:  MOVLW  02
86A4:  ADDWFC 03,W
86A6:  MOVWF  FEA
86A8:  MOVFF  FEF,A90
86AC:  MOVFF  A8F,FEA
86B0:  MOVFF  01,FE9
86B4:  MOVFF  A90,FEF
86B8:  MOVLB  9
86BA:  INCF   xD2,F
86BC:  BRA    867C
....................                 strcpy(msg_buffer1,"on"); 
86BE:  MOVLW  03
86C0:  MOVWF  FEA
86C2:  MOVLW  02
86C4:  MOVWF  FE9
86C6:  MOVLW  00
86C8:  MOVLB  0
86CA:  CALL   022C
86CE:  TBLRD*-
86D0:  TBLRD*+
86D2:  MOVF   FF5,W
86D4:  MOVWF  FEE
86D6:  IORLW  00
86D8:  BNZ   86D0
....................                 if(!strncmp(msg_buffer2,msg_buffer1,2)) 
86DA:  MOVLW  03
86DC:  MOVLB  A
86DE:  MOVWF  x8F
86E0:  MOVLW  16
86E2:  MOVWF  x8E
86E4:  MOVLW  03
86E6:  MOVWF  x91
86E8:  MOVLW  02
86EA:  MOVWF  x90
86EC:  CLRF   x93
86EE:  MOVWF  x92
86F0:  MOVLB  0
86F2:  CALL   56A2
86F6:  MOVF   01,F
86F8:  BNZ   8776
....................                 { 
....................                   #if defined(twonumber)  
....................                      two_number_sending=0; 
86FA:  MOVLB  4
86FC:  CLRF   x9F
....................                   #endif    
....................                   fprintf(COM2,"\n\rautosending turn on\n\r"); 
86FE:  MOVLW  4E
8700:  MOVWF  FF6
8702:  MOVLW  4E
8704:  MOVWF  FF7
8706:  CLRF   19
8708:  BTFSC  FF2.7
870A:  BSF    19.7
870C:  BCF    FF2.7
870E:  MOVLB  0
8710:  CALL   07A0
8714:  BTFSC  19.7
8716:  BSF    FF2.7
....................                   auto_sending = 1; 
8718:  MOVLW  01
871A:  MOVLB  4
871C:  MOVWF  x99
871E:  CLRF   19
8720:  BTFSC  FF2.7
8722:  BSF    19.7
8724:  BCF    FF2.7
....................                   write_ext_eeprom(strobe_autosending,auto_sending); 
8726:  MOVLB  A
8728:  CLRF   xC8
872A:  MOVLW  93
872C:  MOVWF  xC7
872E:  MOVFF  499,AC9
8732:  MOVLB  0
8734:  CALL   3E74
8738:  BTFSC  19.7
873A:  BSF    FF2.7
....................                   fprintf(COM2," exit\n\r"); 
873C:  MOVLW  66
873E:  MOVWF  FF6
8740:  MOVLW  4E
8742:  MOVWF  FF7
8744:  CLRF   19
8746:  BTFSC  FF2.7
8748:  BSF    19.7
874A:  BCF    FF2.7
874C:  CALL   07A0
8750:  BTFSC  19.7
8752:  BSF    FF2.7
....................                   strcpy(reply_buffer,"done"); 
8754:  MOVLW  03
8756:  MOVWF  FEA
8758:  MOVLW  48
875A:  MOVWF  FE9
875C:  MOVLW  00
875E:  CALL   0134
8762:  TBLRD*-
8764:  TBLRD*+
8766:  MOVF   FF5,W
8768:  MOVWF  FEE
876A:  IORLW  00
876C:  BNZ   8764
....................                   break; 
876E:  MOVLB  4
8770:  GOTO   991E
8774:  MOVLB  0
....................                 } 
....................                 strcpy(msg_buffer1,"off"); 
8776:  MOVLW  03
8778:  MOVWF  FEA
877A:  MOVLW  02
877C:  MOVWF  FE9
877E:  MOVLW  00
8780:  CALL   0240
8784:  TBLRD*-
8786:  TBLRD*+
8788:  MOVF   FF5,W
878A:  MOVWF  FEE
878C:  IORLW  00
878E:  BNZ   8786
....................                 if(!strncmp(msg_buffer2,msg_buffer1,3)) 
8790:  MOVLW  03
8792:  MOVLB  A
8794:  MOVWF  x8F
8796:  MOVLW  16
8798:  MOVWF  x8E
879A:  MOVLW  03
879C:  MOVWF  x91
879E:  MOVLW  02
87A0:  MOVWF  x90
87A2:  CLRF   x93
87A4:  MOVLW  03
87A6:  MOVWF  x92
87A8:  MOVLB  0
87AA:  CALL   56A2
87AE:  MOVF   01,F
87B0:  BNZ   8826
....................                 { 
....................                   fprintf(COM2,"\n\rautosending turn off\n\r"); 
87B2:  MOVLW  6E
87B4:  MOVWF  FF6
87B6:  MOVLW  4E
87B8:  MOVWF  FF7
87BA:  CLRF   19
87BC:  BTFSC  FF2.7
87BE:  BSF    19.7
87C0:  BCF    FF2.7
87C2:  CALL   07A0
87C6:  BTFSC  19.7
87C8:  BSF    FF2.7
....................                   auto_sending = 0; 
87CA:  MOVLB  4
87CC:  CLRF   x99
87CE:  CLRF   19
87D0:  BTFSC  FF2.7
87D2:  BSF    19.7
87D4:  BCF    FF2.7
....................                   write_ext_eeprom(strobe_autosending,auto_sending); 
87D6:  MOVLB  A
87D8:  CLRF   xC8
87DA:  MOVLW  93
87DC:  MOVWF  xC7
87DE:  MOVFF  499,AC9
87E2:  MOVLB  0
87E4:  CALL   3E74
87E8:  BTFSC  19.7
87EA:  BSF    FF2.7
....................                   fprintf(COM2," exit\n\r"); 
87EC:  MOVLW  88
87EE:  MOVWF  FF6
87F0:  MOVLW  4E
87F2:  MOVWF  FF7
87F4:  CLRF   19
87F6:  BTFSC  FF2.7
87F8:  BSF    19.7
87FA:  BCF    FF2.7
87FC:  CALL   07A0
8800:  BTFSC  19.7
8802:  BSF    FF2.7
....................                   strcpy(reply_buffer,"done"); 
8804:  MOVLW  03
8806:  MOVWF  FEA
8808:  MOVLW  48
880A:  MOVWF  FE9
880C:  MOVLW  00
880E:  CALL   0134
8812:  TBLRD*-
8814:  TBLRD*+
8816:  MOVF   FF5,W
8818:  MOVWF  FEE
881A:  IORLW  00
881C:  BNZ   8814
....................                   break; 
881E:  MOVLB  4
8820:  GOTO   991E
8824:  MOVLB  0
....................                 } 
....................                 fprintf(COM2,"\n\rplease check your syntax\n\r"); 
8826:  MOVLW  90
8828:  MOVWF  FF6
882A:  MOVLW  4E
882C:  MOVWF  FF7
882E:  CLRF   19
8830:  BTFSC  FF2.7
8832:  BSF    19.7
8834:  BCF    FF2.7
8836:  CALL   07A0
883A:  BTFSC  19.7
883C:  BSF    FF2.7
....................                 strcpy(reply_buffer,"please check your syntax"); 
883E:  MOVLW  03
8840:  MOVWF  FEA
8842:  MOVLW  48
8844:  MOVWF  FE9
8846:  MOVLW  00
8848:  CALL   0254
884C:  TBLRD*-
884E:  TBLRD*+
8850:  MOVF   FF5,W
8852:  MOVWF  FEE
8854:  IORLW  00
8856:  BNZ   884E
....................                 //fprintf(COM2," exit\n\r"); 
....................                 break; 
8858:  MOVLB  4
885A:  GOTO   991E
885E:  MOVLB  0
....................               } 
....................  
....................               strcpy(msg_buffer2,"qullf"); 
8860:  MOVLW  03
8862:  MOVWF  FEA
8864:  MOVLW  16
8866:  MOVWF  FE9
8868:  MOVLW  00
886A:  CALL   0300
886E:  TBLRD*-
8870:  TBLRD*+
8872:  MOVF   FF5,W
8874:  MOVWF  FEE
8876:  IORLW  00
8878:  BNZ   8870
....................               if(!strncmp(msg_buffer2,sim_bug,5))  
887A:  MOVLW  03
887C:  MOVLB  A
887E:  MOVWF  x8F
8880:  MOVLW  16
8882:  MOVWF  x8E
8884:  MOVLW  02
8886:  MOVWF  x91
8888:  MOVLW  D0
888A:  MOVWF  x90
888C:  CLRF   x93
888E:  MOVLW  05
8890:  MOVWF  x92
8892:  MOVLB  0
8894:  CALL   56A2
8898:  MOVF   01,F
889A:  BNZ   88E0
....................               { 
....................                 SIM_state=delete_MSG; 
889C:  MOVLW  06
889E:  MOVLB  4
88A0:  MOVWF  x95
....................                 fprintf(COM2,"FORMATTING..."); 
88A2:  MOVLW  AE
88A4:  MOVWF  FF6
88A6:  MOVLW  4E
88A8:  MOVWF  FF7
88AA:  CLRF   19
88AC:  BTFSC  FF2.7
88AE:  BSF    19.7
88B0:  BCF    FF2.7
88B2:  MOVLB  0
88B4:  CALL   07A0
88B8:  BTFSC  19.7
88BA:  BSF    FF2.7
....................                 ease_eeprom(); 
88BC:  GOTO   5D24
....................                 fprintf(COM2," exit\n\r"); 
88C0:  MOVLW  BC
88C2:  MOVWF  FF6
88C4:  MOVLW  4E
88C6:  MOVWF  FF7
88C8:  CLRF   19
88CA:  BTFSC  FF2.7
88CC:  BSF    19.7
88CE:  BCF    FF2.7
88D0:  CALL   07A0
88D4:  BTFSC  19.7
88D6:  BSF    FF2.7
....................                 break; 
88D8:  MOVLB  4
88DA:  GOTO   991E
88DE:  MOVLB  0
....................               } 
....................               strcpy(msg_buffer2,"format"); 
88E0:  MOVLW  03
88E2:  MOVWF  FEA
88E4:  MOVLW  16
88E6:  MOVWF  FE9
88E8:  MOVLW  00
88EA:  CALL   0316
88EE:  TBLRD*-
88F0:  TBLRD*+
88F2:  MOVF   FF5,W
88F4:  MOVWF  FEE
88F6:  IORLW  00
88F8:  BNZ   88F0
....................               if(!strncmp(msg_buffer2,sim_bug,6))  
88FA:  MOVLW  03
88FC:  MOVLB  A
88FE:  MOVWF  x8F
8900:  MOVLW  16
8902:  MOVWF  x8E
8904:  MOVLW  02
8906:  MOVWF  x91
8908:  MOVLW  D0
890A:  MOVWF  x90
890C:  CLRF   x93
890E:  MOVLW  06
8910:  MOVWF  x92
8912:  MOVLB  0
8914:  CALL   56A2
8918:  MOVF   01,F
891A:  BNZ   897A
....................               { 
....................                   //SIM_state=delete_MSG; 
....................                   SIM_state=SIM_reply; 
891C:  MOVLW  0E
891E:  MOVLB  4
8920:  MOVWF  x95
....................                   fprintf(COM2,"FORMATTING..."); 
8922:  MOVLW  C4
8924:  MOVWF  FF6
8926:  MOVLW  4E
8928:  MOVWF  FF7
892A:  CLRF   19
892C:  BTFSC  FF2.7
892E:  BSF    19.7
8930:  BCF    FF2.7
8932:  MOVLB  0
8934:  CALL   07A0
8938:  BTFSC  19.7
893A:  BSF    FF2.7
....................                   format_eepromext(); 
893C:  GOTO   5DDC
....................                   fprintf(COM2," exit\n\r"); 
8940:  MOVLW  D2
8942:  MOVWF  FF6
8944:  MOVLW  4E
8946:  MOVWF  FF7
8948:  CLRF   19
894A:  BTFSC  FF2.7
894C:  BSF    19.7
894E:  BCF    FF2.7
8950:  CALL   07A0
8954:  BTFSC  19.7
8956:  BSF    FF2.7
....................                   strcpy(reply_buffer,"done"); 
8958:  MOVLW  03
895A:  MOVWF  FEA
895C:  MOVLW  48
895E:  MOVWF  FE9
8960:  MOVLW  00
8962:  CALL   0134
8966:  TBLRD*-
8968:  TBLRD*+
896A:  MOVF   FF5,W
896C:  MOVWF  FEE
896E:  IORLW  00
8970:  BNZ   8968
....................                   break; 
8972:  MOVLB  4
8974:  GOTO   991E
8978:  MOVLB  0
....................               } 
....................               strcpy(msg_buffer2,"countrec"); 
897A:  MOVLW  03
897C:  MOVWF  FEA
897E:  MOVLW  16
8980:  MOVWF  FE9
8982:  MOVLW  00
8984:  CALL   032E
8988:  TBLRD*-
898A:  TBLRD*+
898C:  MOVF   FF5,W
898E:  MOVWF  FEE
8990:  IORLW  00
8992:  BNZ   898A
....................               if(!strncmp(msg_buffer2,sim_bug,8))  
8994:  MOVLW  03
8996:  MOVLB  A
8998:  MOVWF  x8F
899A:  MOVLW  16
899C:  MOVWF  x8E
899E:  MOVLW  02
89A0:  MOVWF  x91
89A2:  MOVLW  D0
89A4:  MOVWF  x90
89A6:  CLRF   x93
89A8:  MOVLW  08
89AA:  MOVWF  x92
89AC:  MOVLB  0
89AE:  CALL   56A2
89B2:  MOVF   01,F
89B4:  BTFSS  FD8.2
89B6:  BRA    8B1C
....................               {   
....................                   len=0; 
89B8:  MOVLB  9
89BA:  CLRF   xD6
89BC:  CLRF   xD5
89BE:  CLRF   19
89C0:  BTFSC  FF2.7
89C2:  BSF    19.7
89C4:  BCF    FF2.7
....................                   cards=get_countcard(); 
89C6:  MOVLB  0
89C8:  CALL   3A02
89CC:  BTFSC  19.7
89CE:  BSF    FF2.7
89D0:  MOVFF  02,9CB
89D4:  MOVFF  01,9CA
....................                   strcpy(msg_buffer2,"device has "); 
89D8:  MOVLW  03
89DA:  MOVWF  FEA
89DC:  MOVLW  16
89DE:  MOVWF  FE9
89E0:  MOVLW  00
89E2:  CALL   0348
89E6:  TBLRD*-
89E8:  TBLRD*+
89EA:  MOVF   FF5,W
89EC:  MOVWF  FEE
89EE:  IORLW  00
89F0:  BNZ   89E8
....................                   len=pre_msg(msg_buffer2,msg_data_sending,0); 
89F2:  MOVLW  03
89F4:  MOVLB  A
89F6:  MOVWF  x8F
89F8:  MOVLW  16
89FA:  MOVWF  x8E
89FC:  MOVLW  01
89FE:  MOVWF  x91
8A00:  MOVLW  B8
8A02:  MOVWF  x90
8A04:  CLRF   x93
8A06:  CLRF   x92
8A08:  MOVLB  0
8A0A:  CALL   5F36
8A0E:  MOVLB  9
8A10:  CLRF   xD6
8A12:  MOVFF  01,9D5
....................                   itoa(cards,10,string); 
8A16:  MOVLB  A
8A18:  CLRF   x91
8A1A:  CLRF   x90
8A1C:  MOVFF  9CB,A8F
8A20:  MOVFF  9CA,A8E
8A24:  MOVLW  0A
8A26:  MOVWF  x92
8A28:  MOVLW  09
8A2A:  MOVWF  x94
8A2C:  MOVLW  DB
8A2E:  MOVWF  x93
8A30:  MOVLB  0
8A32:  CALL   60E8
....................                   len=pre_msg(string,msg_data_sending,len); 
8A36:  MOVLW  09
8A38:  MOVLB  A
8A3A:  MOVWF  x8F
8A3C:  MOVLW  DB
8A3E:  MOVWF  x8E
8A40:  MOVLW  01
8A42:  MOVWF  x91
8A44:  MOVLW  B8
8A46:  MOVWF  x90
8A48:  MOVFF  9D6,A93
8A4C:  MOVFF  9D5,A92
8A50:  MOVLB  0
8A52:  CALL   5F36
8A56:  MOVLB  9
8A58:  CLRF   xD6
8A5A:  MOVFF  01,9D5
....................                   strcpy(msg_buffer2," transaction "); 
8A5E:  MOVLW  03
8A60:  MOVWF  FEA
8A62:  MOVLW  16
8A64:  MOVWF  FE9
8A66:  MOVLW  00
8A68:  MOVLB  0
8A6A:  CALL   0364
8A6E:  TBLRD*-
8A70:  TBLRD*+
8A72:  MOVF   FF5,W
8A74:  MOVWF  FEE
8A76:  IORLW  00
8A78:  BNZ   8A70
....................                   len=pre_msg(msg_buffer2,msg_data_sending,len); 
8A7A:  MOVLW  03
8A7C:  MOVLB  A
8A7E:  MOVWF  x8F
8A80:  MOVLW  16
8A82:  MOVWF  x8E
8A84:  MOVLW  01
8A86:  MOVWF  x91
8A88:  MOVLW  B8
8A8A:  MOVWF  x90
8A8C:  MOVFF  9D6,A93
8A90:  MOVFF  9D5,A92
8A94:  MOVLB  0
8A96:  CALL   5F36
8A9A:  MOVLB  9
8A9C:  CLRF   xD6
8A9E:  MOVFF  01,9D5
....................                   SIM_state=MSG_sending; 
8AA2:  MOVLW  08
8AA4:  MOVLB  4
8AA6:  MOVWF  x95
....................                   lastlen=0; 
8AA8:  MOVLB  9
8AAA:  CLRF   xD1
8AAC:  CLRF   xD0
....................                   fprintf(COM2,"device has %lu transaction \n\r",cards); 
8AAE:  MOVLW  DA
8AB0:  MOVWF  FF6
8AB2:  MOVLW  4E
8AB4:  MOVWF  FF7
8AB6:  CLRF   19
8AB8:  BTFSC  FF2.7
8ABA:  BSF    19.7
8ABC:  BCF    FF2.7
8ABE:  MOVLW  0B
8AC0:  MOVLB  A
8AC2:  MOVWF  xD3
8AC4:  MOVLB  0
8AC6:  CALL   1718
8ACA:  BTFSC  19.7
8ACC:  BSF    FF2.7
8ACE:  MOVLW  10
8AD0:  MOVWF  FE9
8AD2:  CLRF   19
8AD4:  BTFSC  FF2.7
8AD6:  BSF    19.7
8AD8:  BCF    FF2.7
8ADA:  MOVFF  9CB,ABD
8ADE:  MOVFF  9CA,ABC
8AE2:  CALL   1742
8AE6:  BTFSC  19.7
8AE8:  BSF    FF2.7
8AEA:  MOVLW  E8
8AEC:  MOVWF  FF6
8AEE:  MOVLW  4E
8AF0:  MOVWF  FF7
8AF2:  CLRF   19
8AF4:  BTFSC  FF2.7
8AF6:  BSF    19.7
8AF8:  BCF    FF2.7
8AFA:  MOVLW  0F
8AFC:  MOVLB  A
8AFE:  MOVWF  xD3
8B00:  MOVLB  0
8B02:  CALL   1718
8B06:  BTFSC  19.7
8B08:  BSF    FF2.7
....................                   countc=0; 
8B0A:  MOVLB  9
8B0C:  CLRF   xCD
8B0E:  CLRF   xCC
....................                   count_dwla=0; 
8B10:  CLRF   xCF
8B12:  CLRF   xCE
....................                   break; 
8B14:  MOVLB  4
8B16:  GOTO   991E
8B1A:  MOVLB  0
....................               } 
....................               strcpy(msg_buffer2,"download all"); 
8B1C:  MOVLW  03
8B1E:  MOVWF  FEA
8B20:  MOVLW  16
8B22:  MOVWF  FE9
8B24:  MOVLW  00
8B26:  CALL   0382
8B2A:  TBLRD*-
8B2C:  TBLRD*+
8B2E:  MOVF   FF5,W
8B30:  MOVWF  FEE
8B32:  IORLW  00
8B34:  BNZ   8B2C
....................               if(!strncmp(msg_buffer2,sim_bug,12)) 
8B36:  MOVLW  03
8B38:  MOVLB  A
8B3A:  MOVWF  x8F
8B3C:  MOVLW  16
8B3E:  MOVWF  x8E
8B40:  MOVLW  02
8B42:  MOVWF  x91
8B44:  MOVLW  D0
8B46:  MOVWF  x90
8B48:  CLRF   x93
8B4A:  MOVLW  0C
8B4C:  MOVWF  x92
8B4E:  MOVLB  0
8B50:  CALL   56A2
8B54:  MOVF   01,F
8B56:  BNZ   8BAA
....................               { 
....................                    fprintf(COM2,"download all\n\r");   
8B58:  MOVLW  F8
8B5A:  MOVWF  FF6
8B5C:  MOVLW  4E
8B5E:  MOVWF  FF7
8B60:  CLRF   19
8B62:  BTFSC  FF2.7
8B64:  BSF    19.7
8B66:  BCF    FF2.7
8B68:  CALL   07A0
8B6C:  BTFSC  19.7
8B6E:  BSF    FF2.7
8B70:  CLRF   19
8B72:  BTFSC  FF2.7
8B74:  BSF    19.7
8B76:  BCF    FF2.7
....................                    count_dwla=get_countcard(); 
8B78:  CALL   3A02
8B7C:  BTFSC  19.7
8B7E:  BSF    FF2.7
8B80:  MOVFF  02,9CF
8B84:  MOVFF  01,9CE
....................                    len=0; 
8B88:  MOVLB  9
8B8A:  CLRF   xD6
8B8C:  CLRF   xD5
....................                    num_card=count_dwla; 
8B8E:  MOVFF  9CF,9C9
8B92:  MOVFF  9CE,9C8
....................                    SIM_state=pre_cmd; 
8B96:  MOVLW  07
8B98:  MOVLB  4
8B9A:  MOVWF  x95
....................                    countc=0; 
8B9C:  MOVLB  9
8B9E:  CLRF   xCD
8BA0:  CLRF   xCC
....................                    break; 
8BA2:  MOVLB  4
8BA4:  GOTO   991E
8BA8:  MOVLB  0
....................               } 
....................               strcpy(msg_buffer2,"download "); 
8BAA:  MOVLW  03
8BAC:  MOVWF  FEA
8BAE:  MOVLW  16
8BB0:  MOVWF  FE9
8BB2:  MOVLW  00
8BB4:  CALL   03A0
8BB8:  TBLRD*-
8BBA:  TBLRD*+
8BBC:  MOVF   FF5,W
8BBE:  MOVWF  FEE
8BC0:  IORLW  00
8BC2:  BNZ   8BBA
....................               if(!strncmp(msg_buffer2,sim_bug,9)) 
8BC4:  MOVLW  03
8BC6:  MOVLB  A
8BC8:  MOVWF  x8F
8BCA:  MOVLW  16
8BCC:  MOVWF  x8E
8BCE:  MOVLW  02
8BD0:  MOVWF  x91
8BD2:  MOVLW  D0
8BD4:  MOVWF  x90
8BD6:  CLRF   x93
8BD8:  MOVLW  09
8BDA:  MOVWF  x92
8BDC:  MOVLB  0
8BDE:  CALL   56A2
8BE2:  MOVF   01,F
8BE4:  BTFSS  FD8.2
8BE6:  BRA    8DDA
....................               { 
....................                   if((sim_bug[9]<48)||(sim_bug[9]>57)) 
8BE8:  MOVLB  2
8BEA:  MOVF   xD9,W
8BEC:  SUBLW  2F
8BEE:  BC    8BF6
8BF0:  MOVF   xD9,W
8BF2:  SUBLW  39
8BF4:  BC    8C38
....................                   { 
....................                      SIM_state=SIM_reply; 
8BF6:  MOVLW  0E
8BF8:  MOVLB  4
8BFA:  MOVWF  x95
....................                      fprintf(COM2,"\n\rplease check your syntax\n\r"); 
8BFC:  MOVLW  08
8BFE:  MOVWF  FF6
8C00:  MOVLW  4F
8C02:  MOVWF  FF7
8C04:  CLRF   19
8C06:  BTFSC  FF2.7
8C08:  BSF    19.7
8C0A:  BCF    FF2.7
8C0C:  MOVLB  0
8C0E:  CALL   07A0
8C12:  BTFSC  19.7
8C14:  BSF    FF2.7
....................                      strcpy(reply_buffer,"please check your syntax"); 
8C16:  MOVLW  03
8C18:  MOVWF  FEA
8C1A:  MOVLW  48
8C1C:  MOVWF  FE9
8C1E:  MOVLW  00
8C20:  CALL   0254
8C24:  TBLRD*-
8C26:  TBLRD*+
8C28:  MOVF   FF5,W
8C2A:  MOVWF  FEE
8C2C:  IORLW  00
8C2E:  BNZ   8C26
....................                      break; 
8C30:  MOVLB  4
8C32:  GOTO   991E
8C36:  MOVLB  2
....................                   } 
....................                   i=0; 
8C38:  MOVLB  9
8C3A:  CLRF   xD2
....................                   temp=sim_bug[9]; 
8C3C:  MOVFF  2D9,9D3
....................                   while(temp!=0) 
8C40:  MOVF   xD3,F
8C42:  BZ    8C6E
....................                   { 
....................                      temp=sim_bug[i+9]; 
8C44:  MOVLW  09
8C46:  ADDWF  xD2,W
8C48:  CLRF   03
8C4A:  ADDLW  D0
8C4C:  MOVWF  FE9
8C4E:  MOVLW  02
8C50:  ADDWFC 03,W
8C52:  MOVWF  FEA
8C54:  MOVFF  FEF,9D3
....................                      string[i++]=temp; 
8C58:  MOVF   xD2,W
8C5A:  INCF   xD2,F
8C5C:  CLRF   03
8C5E:  ADDLW  DB
8C60:  MOVWF  FE9
8C62:  MOVLW  09
8C64:  ADDWFC 03,W
8C66:  MOVWF  FEA
8C68:  MOVFF  9D3,FEF
8C6C:  BRA    8C40
....................                   } 
....................                   countc=atoi(string); 
8C6E:  MOVLW  09
8C70:  MOVLB  A
8C72:  MOVWF  x8F
8C74:  MOVLW  DB
8C76:  MOVWF  x8E
8C78:  MOVLB  0
8C7A:  GOTO   62F0
8C7E:  CLRF   03
8C80:  MOVFF  01,9CC
8C84:  MOVLB  9
8C86:  MOVFF  03,9CD
8C8A:  CLRF   19
8C8C:  BTFSC  FF2.7
8C8E:  BSF    19.7
8C90:  BCF    FF2.7
....................                   //fprintf(COM2,"countc=%lu\n\r",countc); 
....................                   count_dwla=get_countcard(); 
8C92:  MOVLB  0
8C94:  CALL   3A02
8C98:  BTFSC  19.7
8C9A:  BSF    FF2.7
8C9C:  MOVFF  02,9CF
8CA0:  MOVFF  01,9CE
....................                   if(count_dwla<countc) 
8CA4:  MOVLB  9
8CA6:  MOVF   xCF,W
8CA8:  SUBWF  xCD,W
8CAA:  BTFSS  FD8.0
8CAC:  BRA    8DA4
8CAE:  BNZ   8CB6
8CB0:  MOVF   xCC,W
8CB2:  SUBWF  xCE,W
8CB4:  BC    8DA4
....................                   { 
....................                      len=0; 
8CB6:  CLRF   xD6
8CB8:  CLRF   xD5
....................                      strcpy(buftemp2,"Device has only "); 
8CBA:  MOVLW  0A
8CBC:  MOVWF  FEA
8CBE:  MOVLW  5C
8CC0:  MOVWF  FE9
8CC2:  MOVLW  00
8CC4:  MOVLB  0
8CC6:  CALL   03BA
8CCA:  TBLRD*-
8CCC:  TBLRD*+
8CCE:  MOVF   FF5,W
8CD0:  MOVWF  FEE
8CD2:  IORLW  00
8CD4:  BNZ   8CCC
....................                      len=pre_msg(buftemp2,msg_data_sending,0); 
8CD6:  MOVLW  0A
8CD8:  MOVLB  A
8CDA:  MOVWF  x8F
8CDC:  MOVLW  5C
8CDE:  MOVWF  x8E
8CE0:  MOVLW  01
8CE2:  MOVWF  x91
8CE4:  MOVLW  B8
8CE6:  MOVWF  x90
8CE8:  CLRF   x93
8CEA:  CLRF   x92
8CEC:  MOVLB  0
8CEE:  CALL   5F36
8CF2:  MOVLB  9
8CF4:  CLRF   xD6
8CF6:  MOVFF  01,9D5
....................                      itoa(count_dwla,10,string); 
8CFA:  MOVLB  A
8CFC:  CLRF   x91
8CFE:  CLRF   x90
8D00:  MOVFF  9CF,A8F
8D04:  MOVFF  9CE,A8E
8D08:  MOVLW  0A
8D0A:  MOVWF  x92
8D0C:  MOVLW  09
8D0E:  MOVWF  x94
8D10:  MOVLW  DB
8D12:  MOVWF  x93
8D14:  MOVLB  0
8D16:  CALL   60E8
....................                      len=pre_msg(string,msg_data_sending,len); 
8D1A:  MOVLW  09
8D1C:  MOVLB  A
8D1E:  MOVWF  x8F
8D20:  MOVLW  DB
8D22:  MOVWF  x8E
8D24:  MOVLW  01
8D26:  MOVWF  x91
8D28:  MOVLW  B8
8D2A:  MOVWF  x90
8D2C:  MOVFF  9D6,A93
8D30:  MOVFF  9D5,A92
8D34:  MOVLB  0
8D36:  CALL   5F36
8D3A:  MOVLB  9
8D3C:  CLRF   xD6
8D3E:  MOVFF  01,9D5
....................                      strcpy(buftemp2," transaction ");//transaction\n\r 
8D42:  MOVLW  0A
8D44:  MOVWF  FEA
8D46:  MOVLW  5C
8D48:  MOVWF  FE9
8D4A:  MOVLW  00
8D4C:  MOVLB  0
8D4E:  CALL   0364
8D52:  TBLRD*-
8D54:  TBLRD*+
8D56:  MOVF   FF5,W
8D58:  MOVWF  FEE
8D5A:  IORLW  00
8D5C:  BNZ   8D54
....................                      len=pre_msg(buftemp2,msg_data_sending,len); 
8D5E:  MOVLW  0A
8D60:  MOVLB  A
8D62:  MOVWF  x8F
8D64:  MOVLW  5C
8D66:  MOVWF  x8E
8D68:  MOVLW  01
8D6A:  MOVWF  x91
8D6C:  MOVLW  B8
8D6E:  MOVWF  x90
8D70:  MOVFF  9D6,A93
8D74:  MOVFF  9D5,A92
8D78:  MOVLB  0
8D7A:  CALL   5F36
8D7E:  MOVLB  9
8D80:  CLRF   xD6
8D82:  MOVFF  01,9D5
....................                      SIM_state=MSG_sending; 
8D86:  MOVLW  08
8D88:  MOVLB  4
8D8A:  MOVWF  x95
....................                      lastlen=0; 
8D8C:  MOVLB  9
8D8E:  CLRF   xD1
8D90:  CLRF   xD0
....................                      count_dwla=0; 
8D92:  CLRF   xCF
8D94:  CLRF   xCE
....................                      num_card=0; 
8D96:  CLRF   xC9
8D98:  CLRF   xC8
....................                      break; 
8D9A:  MOVLB  4
8D9C:  GOTO   991E
....................                   } 
8DA0:  BRA    8DD8
8DA2:  MOVLB  9
....................                   else  
....................                   { 
....................                      num_card=count_dwla; 
8DA4:  MOVFF  9CF,9C9
8DA8:  MOVFF  9CE,9C8
....................                      countc=num_card-countc; 
8DAC:  MOVF   xCC,W
8DAE:  SUBWF  xC8,W
8DB0:  MOVWF  xCC
8DB2:  MOVF   xCD,W
8DB4:  SUBWFB xC9,W
8DB6:  MOVWF  xCD
....................                      if(countc==0)count_dwla=num_card; 
8DB8:  MOVF   xCC,F
8DBA:  BNZ   8DCA
8DBC:  MOVF   xCD,F
8DBE:  BNZ   8DCA
8DC0:  MOVFF  9C9,9CF
8DC4:  MOVFF  9C8,9CE
8DC8:  BRA    8DCE
....................                      else count_dwla=0; 
8DCA:  CLRF   xCF
8DCC:  CLRF   xCE
....................                      SIM_state=pre_cmd; 
8DCE:  MOVLW  07
8DD0:  MOVLB  4
8DD2:  MOVWF  x95
....................                      break; 
8DD4:  GOTO   991E
....................                   } 
....................                   //SIM_state=delete_MSG; 
....................               } 
8DD8:  BRA    8DE0
....................               else SIM_state=delete_MSG; 
8DDA:  MOVLW  06
8DDC:  MOVLB  4
8DDE:  MOVWF  x95
....................             break; 
8DE0:  GOTO   991E
....................             case delete_MSG: 
....................                receiver_state=1; 
8DE4:  MOVLW  01
8DE6:  MOVLB  1
8DE8:  MOVWF  xB4
....................                fprintf(COM2,"delete_MSG...\n\r"); 
8DEA:  MOVLW  26
8DEC:  MOVWF  FF6
8DEE:  MOVLW  4F
8DF0:  MOVWF  FF7
8DF2:  CLRF   19
8DF4:  BTFSC  FF2.7
8DF6:  BSF    19.7
8DF8:  BCF    FF2.7
8DFA:  MOVLB  0
8DFC:  CALL   07A0
8E00:  BTFSC  19.7
8E02:  BSF    FF2.7
....................                #ASM BCF    0xF94.7 #ENDASM  
8E04:  BCF    F94.7
....................                   fprintf(COM1,"AT+CMGD=1\r\n"); 
8E06:  MOVLW  36
8E08:  MOVWF  FF6
8E0A:  MOVLW  4F
8E0C:  MOVWF  FF7
8E0E:  CALL   53E0
....................                #ASM BSF    0xF94.7 #ENDASM  
8E12:  BSF    F94.7
8E14:  CLRF   19
8E16:  BTFSC  FF2.7
8E18:  BSF    19.7
8E1A:  BCF    FF2.7
....................                del_buf(200,buffer_uart); 
8E1C:  MOVLW  C8
8E1E:  MOVLB  A
8E20:  MOVWF  xC5
8E22:  MOVLW  01
8E24:  MOVWF  xC7
8E26:  MOVLW  4E
8E28:  MOVWF  xC6
8E2A:  MOVLB  0
8E2C:  CALL   3A74
8E30:  BTFSC  19.7
8E32:  BSF    FF2.7
....................                //SIM_state=sending_cmd;        
....................                timing_wait=10000; 
8E34:  MOVLW  27
8E36:  MOVLB  4
8E38:  MOVWF  x98
8E3A:  MOVLW  10
8E3C:  MOVWF  x97
....................                SIM_state= idle; 
8E3E:  MOVLW  0C
8E40:  MOVWF  x95
....................                over_byte=0; 
8E42:  MOVLB  1
8E44:  CLRF   xB7
8E46:  CLRF   xB6
....................                output_low(LED); 
8E48:  BCF    F92.6
8E4A:  BCF    F89.6
....................                memset(reply_buffer,0,sizeof(reply_buffer));  
8E4C:  MOVLW  03
8E4E:  MOVWF  FEA
8E50:  MOVLW  48
8E52:  MOVWF  FE9
8E54:  CLRF   00
8E56:  MOVLW  01
8E58:  MOVWF  02
8E5A:  MOVLW  18
8E5C:  MOVWF  01
8E5E:  MOVLB  0
8E60:  CALL   4476
....................                memset(buffer_uart,0,sizeof(buffer_uart));                 
8E64:  MOVLW  01
8E66:  MOVWF  FEA
8E68:  MOVLW  4E
8E6A:  MOVWF  FE9
8E6C:  CLRF   00
8E6E:  CLRF   02
8E70:  MOVLW  64
8E72:  MOVWF  01
8E74:  CALL   4476
....................                SIM_reply_st=0; 
8E78:  MOVLB  4
8E7A:  CLRF   x9B
....................                #if defined(twonumber) 
....................                   if(two_number_sending==1) 
8E7C:  DECFSZ x9F,W
8E7E:  BRA    8E86
....................                   { 
....................                     SIM_state=autosending1;  
8E80:  MOVLW  13
8E82:  MOVWF  x95
....................                     two_number_sending=0; 
8E84:  CLRF   x9F
....................                   } 
....................                #endif 
....................             break; 
8E86:  GOTO   991E
....................             case pre_cmd: 
....................                    //fprintf(COM2,"pre_cmd-> num_card,countc, count_dwla=%lu,%lu,%lu\r\n",num_card,countc,count_dwla);   
....................                    if(num_card==0)  
8E8A:  MOVLB  9
8E8C:  MOVF   xC8,F
8E8E:  BNZ   8EA0
8E90:  MOVF   xC9,F
8E92:  BNZ   8EA0
....................                    { 
....................                      SIM_state=delete_MSG; 
8E94:  MOVLW  06
8E96:  MOVLB  4
8E98:  MOVWF  x95
....................                      break; 
8E9A:  GOTO   991E
8E9E:  MOVLB  9
....................                    } 
....................                    len=0; 
8EA0:  CLRF   xD6
8EA2:  CLRF   xD5
....................                    //num_card=1; 
....................                    memset(msg_data_sending,0,sizeof(msg_data_sending));  
8EA4:  MOVLW  01
8EA6:  MOVWF  FEA
8EA8:  MOVLW  B8
8EAA:  MOVWF  FE9
8EAC:  CLRF   00
8EAE:  MOVLW  01
8EB0:  MOVWF  02
8EB2:  MOVLW  18
8EB4:  MOVWF  01
8EB6:  MOVLB  0
8EB8:  CALL   4476
8EBC:  CLRF   19
8EBE:  BTFSC  FF2.7
8EC0:  BSF    19.7
8EC2:  BCF    FF2.7
....................                    addr_dat=num_card*numdata+ptr_start; 
8EC4:  MOVFF  9C9,ABC
8EC8:  MOVFF  9C8,ABB
8ECC:  MOVLB  A
8ECE:  CLRF   xBE
8ED0:  MOVLW  7C
8ED2:  MOVWF  xBD
8ED4:  MOVLB  0
8ED6:  CALL   3A52
8EDA:  BTFSC  19.7
8EDC:  BSF    FF2.7
8EDE:  MOVLW  96
8EE0:  MOVLB  A
8EE2:  ADDWF  01,W
8EE4:  MOVLB  9
8EE6:  MOVWF  xD7
8EE8:  MOVLW  00
8EEA:  MOVLB  A
8EEC:  ADDWFC 02,W
8EEE:  MOVLB  9
8EF0:  MOVWF  xD8
....................                    I2CEEPROM_read((unsigned int16)(addr_dat-numdata),numdata,buftemp); 
8EF2:  MOVLW  7C
8EF4:  SUBWF  xD7,W
8EF6:  MOVLB  A
8EF8:  MOVWF  x8E
8EFA:  MOVLW  00
8EFC:  MOVLB  9
8EFE:  SUBWFB xD8,W
8F00:  MOVLB  A
8F02:  MOVWF  x8F
8F04:  MOVWF  x91
8F06:  MOVFF  A8E,A90
8F0A:  CLRF   x93
8F0C:  MOVLW  7C
8F0E:  MOVWF  x92
8F10:  MOVLW  09
8F12:  MOVWF  x95
8F14:  MOVLW  E0
8F16:  MOVWF  x94
8F18:  MOVLB  0
8F1A:  GOTO   6484
....................                    itoa(buftemp[0],10,string); 
8F1E:  MOVLB  A
8F20:  CLRF   x91
8F22:  CLRF   x90
8F24:  CLRF   x8F
8F26:  MOVFF  9E0,A8E
8F2A:  MOVLW  0A
8F2C:  MOVWF  x92
8F2E:  MOVLW  09
8F30:  MOVWF  x94
8F32:  MOVLW  DB
8F34:  MOVWF  x93
8F36:  MOVLB  0
8F38:  CALL   60E8
....................                    len=pre_msg(string,msg_data_sending,0); 
8F3C:  MOVLW  09
8F3E:  MOVLB  A
8F40:  MOVWF  x8F
8F42:  MOVLW  DB
8F44:  MOVWF  x8E
8F46:  MOVLW  01
8F48:  MOVWF  x91
8F4A:  MOVLW  B8
8F4C:  MOVWF  x90
8F4E:  CLRF   x93
8F50:  CLRF   x92
8F52:  MOVLB  0
8F54:  CALL   5F36
8F58:  MOVLB  9
8F5A:  CLRF   xD6
8F5C:  MOVFF  01,9D5
....................                    msg_data_sending[len++]='/'; 
8F60:  MOVFF  9D6,03
8F64:  MOVF   xD5,W
8F66:  INCF   xD5,F
8F68:  BTFSC  FD8.2
8F6A:  INCF   xD6,F
8F6C:  MOVLB  A
8F6E:  MOVWF  x8E
8F70:  MOVLW  B8
8F72:  ADDWF  x8E,W
8F74:  MOVWF  FE9
8F76:  MOVLW  01
8F78:  ADDWFC 03,W
8F7A:  MOVWF  FEA
8F7C:  MOVLW  2F
8F7E:  MOVWF  FEF
....................                    itoa(buftemp[1],10,string); 
8F80:  CLRF   x91
8F82:  CLRF   x90
8F84:  CLRF   x8F
8F86:  MOVFF  9E1,A8E
8F8A:  MOVLW  0A
8F8C:  MOVWF  x92
8F8E:  MOVLW  09
8F90:  MOVWF  x94
8F92:  MOVLW  DB
8F94:  MOVWF  x93
8F96:  MOVLB  0
8F98:  CALL   60E8
....................                    len=pre_msg(string,msg_data_sending,len); 
8F9C:  MOVLW  09
8F9E:  MOVLB  A
8FA0:  MOVWF  x8F
8FA2:  MOVLW  DB
8FA4:  MOVWF  x8E
8FA6:  MOVLW  01
8FA8:  MOVWF  x91
8FAA:  MOVLW  B8
8FAC:  MOVWF  x90
8FAE:  MOVFF  9D6,A93
8FB2:  MOVFF  9D5,A92
8FB6:  MOVLB  0
8FB8:  CALL   5F36
8FBC:  MOVLB  9
8FBE:  CLRF   xD6
8FC0:  MOVFF  01,9D5
....................                    msg_data_sending[len++]='/'; 
8FC4:  MOVFF  9D6,03
8FC8:  MOVF   xD5,W
8FCA:  INCF   xD5,F
8FCC:  BTFSC  FD8.2
8FCE:  INCF   xD6,F
8FD0:  MOVLB  A
8FD2:  MOVWF  x8E
8FD4:  MOVLW  B8
8FD6:  ADDWF  x8E,W
8FD8:  MOVWF  FE9
8FDA:  MOVLW  01
8FDC:  ADDWFC 03,W
8FDE:  MOVWF  FEA
8FE0:  MOVLW  2F
8FE2:  MOVWF  FEF
....................                    msg_data_sending[len++]=' '; 
8FE4:  MOVLB  9
8FE6:  MOVFF  9D6,03
8FEA:  MOVF   xD5,W
8FEC:  INCF   xD5,F
8FEE:  BTFSC  FD8.2
8FF0:  INCF   xD6,F
8FF2:  MOVLB  A
8FF4:  MOVWF  x8E
8FF6:  MOVLW  B8
8FF8:  ADDWF  x8E,W
8FFA:  MOVWF  FE9
8FFC:  MOVLW  01
8FFE:  ADDWFC 03,W
9000:  MOVWF  FEA
9002:  MOVLW  20
9004:  MOVWF  FEF
....................                    itoa(buftemp[2],10,string); 
9006:  CLRF   x91
9008:  CLRF   x90
900A:  CLRF   x8F
900C:  MOVFF  9E2,A8E
9010:  MOVLW  0A
9012:  MOVWF  x92
9014:  MOVLW  09
9016:  MOVWF  x94
9018:  MOVLW  DB
901A:  MOVWF  x93
901C:  MOVLB  0
901E:  CALL   60E8
....................                    len=pre_msg(string,msg_data_sending,len); 
9022:  MOVLW  09
9024:  MOVLB  A
9026:  MOVWF  x8F
9028:  MOVLW  DB
902A:  MOVWF  x8E
902C:  MOVLW  01
902E:  MOVWF  x91
9030:  MOVLW  B8
9032:  MOVWF  x90
9034:  MOVFF  9D6,A93
9038:  MOVFF  9D5,A92
903C:  MOVLB  0
903E:  CALL   5F36
9042:  MOVLB  9
9044:  CLRF   xD6
9046:  MOVFF  01,9D5
....................                    msg_data_sending[len++]=':'; 
904A:  MOVFF  9D6,03
904E:  MOVF   xD5,W
9050:  INCF   xD5,F
9052:  BTFSC  FD8.2
9054:  INCF   xD6,F
9056:  MOVLB  A
9058:  MOVWF  x8E
905A:  MOVLW  B8
905C:  ADDWF  x8E,W
905E:  MOVWF  FE9
9060:  MOVLW  01
9062:  ADDWFC 03,W
9064:  MOVWF  FEA
9066:  MOVLW  3A
9068:  MOVWF  FEF
....................                    itoa(buftemp[3],10,string); 
906A:  CLRF   x91
906C:  CLRF   x90
906E:  CLRF   x8F
9070:  MOVFF  9E3,A8E
9074:  MOVLW  0A
9076:  MOVWF  x92
9078:  MOVLW  09
907A:  MOVWF  x94
907C:  MOVLW  DB
907E:  MOVWF  x93
9080:  MOVLB  0
9082:  CALL   60E8
....................                    len=pre_msg(string,msg_data_sending,len); 
9086:  MOVLW  09
9088:  MOVLB  A
908A:  MOVWF  x8F
908C:  MOVLW  DB
908E:  MOVWF  x8E
9090:  MOVLW  01
9092:  MOVWF  x91
9094:  MOVLW  B8
9096:  MOVWF  x90
9098:  MOVFF  9D6,A93
909C:  MOVFF  9D5,A92
90A0:  MOVLB  0
90A2:  CALL   5F36
90A6:  MOVLB  9
90A8:  CLRF   xD6
90AA:  MOVFF  01,9D5
....................                    msg_data_sending[len++]=':'; 
90AE:  MOVFF  9D6,03
90B2:  MOVF   xD5,W
90B4:  INCF   xD5,F
90B6:  BTFSC  FD8.2
90B8:  INCF   xD6,F
90BA:  MOVLB  A
90BC:  MOVWF  x8E
90BE:  MOVLW  B8
90C0:  ADDWF  x8E,W
90C2:  MOVWF  FE9
90C4:  MOVLW  01
90C6:  ADDWFC 03,W
90C8:  MOVWF  FEA
90CA:  MOVLW  3A
90CC:  MOVWF  FEF
....................                    itoa(buftemp[4],10,string); 
90CE:  CLRF   x91
90D0:  CLRF   x90
90D2:  CLRF   x8F
90D4:  MOVFF  9E4,A8E
90D8:  MOVLW  0A
90DA:  MOVWF  x92
90DC:  MOVLW  09
90DE:  MOVWF  x94
90E0:  MOVLW  DB
90E2:  MOVWF  x93
90E4:  MOVLB  0
90E6:  CALL   60E8
....................                    len=pre_msg(string,msg_data_sending,len); 
90EA:  MOVLW  09
90EC:  MOVLB  A
90EE:  MOVWF  x8F
90F0:  MOVLW  DB
90F2:  MOVWF  x8E
90F4:  MOVLW  01
90F6:  MOVWF  x91
90F8:  MOVLW  B8
90FA:  MOVWF  x90
90FC:  MOVFF  9D6,A93
9100:  MOVFF  9D5,A92
9104:  MOVLB  0
9106:  CALL   5F36
910A:  MOVLB  9
910C:  CLRF   xD6
910E:  MOVFF  01,9D5
....................                    //msg_data_sending[len++]=' '; 
....................                    i=0; 
9112:  CLRF   xD2
....................                    strcpy(buftemp2," Track1>"); 
9114:  MOVLW  0A
9116:  MOVWF  FEA
9118:  MOVLW  5C
911A:  MOVWF  FE9
911C:  MOVLW  00
911E:  MOVLB  0
9120:  CALL   03DC
9124:  TBLRD*-
9126:  TBLRD*+
9128:  MOVF   FF5,W
912A:  MOVWF  FEE
912C:  IORLW  00
912E:  BNZ   9126
....................                    len=pre_msg(buftemp2,msg_data_sending,len); 
9130:  MOVLW  0A
9132:  MOVLB  A
9134:  MOVWF  x8F
9136:  MOVLW  5C
9138:  MOVWF  x8E
913A:  MOVLW  01
913C:  MOVWF  x91
913E:  MOVLW  B8
9140:  MOVWF  x90
9142:  MOVFF  9D6,A93
9146:  MOVFF  9D5,A92
914A:  MOVLB  0
914C:  CALL   5F36
9150:  MOVLB  9
9152:  CLRF   xD6
9154:  MOVFF  01,9D5
....................                    temp=0; 
9158:  CLRF   xD3
....................                    while((i<numbyteoftrack1)&&(temp!='?')) 
915A:  MOVF   xD2,W
915C:  SUBLW  4E
915E:  BNC   91B6
9160:  MOVF   xD3,W
9162:  SUBLW  3F
9164:  BZ    91B6
....................                    { 
....................                      temp = buftemp[i+5]; 
9166:  MOVLW  05
9168:  ADDWF  xD2,W
916A:  CLRF   03
916C:  ADDLW  E0
916E:  MOVWF  FE9
9170:  MOVLW  09
9172:  ADDWFC 03,W
9174:  MOVWF  FEA
9176:  MOVFF  FEF,9D3
....................                      //fprintf(COM2,"%c",temp);  
....................                      if((temp>31)&&(temp<127))msg_data_sending[len++]=temp; 
917A:  MOVF   xD3,W
917C:  SUBLW  1F
917E:  BC    91AC
9180:  MOVF   xD3,W
9182:  SUBLW  7E
9184:  BNC   91AC
9186:  MOVFF  9D6,03
918A:  MOVF   xD5,W
918C:  INCF   xD5,F
918E:  BTFSC  FD8.2
9190:  INCF   xD6,F
9192:  MOVLB  A
9194:  MOVWF  x8E
9196:  MOVFF  03,A8F
919A:  MOVLW  B8
919C:  ADDWF  x8E,W
919E:  MOVWF  FE9
91A0:  MOVLW  01
91A2:  ADDWFC 03,W
91A4:  MOVWF  FEA
91A6:  MOVFF  9D3,FEF
91AA:  MOVLB  9
....................                      i++; 
91AC:  INCF   xD2,F
....................                      if(temp==0)break; 
91AE:  MOVF   xD3,F
91B0:  BTFSC  FD8.2
91B2:  BRA    91B6
91B4:  BRA    915A
....................                    } 
....................                    i=0; 
91B6:  CLRF   xD2
....................                    temp=0; 
91B8:  CLRF   xD3
....................                    strcpy(buftemp2," Track2>"); 
91BA:  MOVLW  0A
91BC:  MOVWF  FEA
91BE:  MOVLW  5C
91C0:  MOVWF  FE9
91C2:  MOVLW  00
91C4:  MOVLB  0
91C6:  CALL   03F6
91CA:  TBLRD*-
91CC:  TBLRD*+
91CE:  MOVF   FF5,W
91D0:  MOVWF  FEE
91D2:  IORLW  00
91D4:  BNZ   91CC
....................                    len=pre_msg(buftemp2,msg_data_sending,len); 
91D6:  MOVLW  0A
91D8:  MOVLB  A
91DA:  MOVWF  x8F
91DC:  MOVLW  5C
91DE:  MOVWF  x8E
91E0:  MOVLW  01
91E2:  MOVWF  x91
91E4:  MOVLW  B8
91E6:  MOVWF  x90
91E8:  MOVFF  9D6,A93
91EC:  MOVFF  9D5,A92
91F0:  MOVLB  0
91F2:  CALL   5F36
91F6:  MOVLB  9
91F8:  CLRF   xD6
91FA:  MOVFF  01,9D5
....................                    while((i<numbyteoftrack2)&&(temp!='?')) 
91FE:  MOVF   xD2,W
9200:  SUBLW  27
9202:  BNC   925C
9204:  MOVF   xD3,W
9206:  SUBLW  3F
9208:  BZ    925C
....................                    { 
....................                      temp = buftemp[i+5+numbyteoftrack1]; 
920A:  MOVLW  05
920C:  ADDWF  xD2,W
920E:  ADDLW  4F
9210:  CLRF   03
9212:  ADDLW  E0
9214:  MOVWF  FE9
9216:  MOVLW  09
9218:  ADDWFC 03,W
921A:  MOVWF  FEA
921C:  MOVFF  FEF,9D3
....................                      //fprintf(COM2,"%c",temp);  
....................                      if((temp>31)&&(temp<127))msg_data_sending[len++]=temp; 
9220:  MOVF   xD3,W
9222:  SUBLW  1F
9224:  BC    9252
9226:  MOVF   xD3,W
9228:  SUBLW  7E
922A:  BNC   9252
922C:  MOVFF  9D6,03
9230:  MOVF   xD5,W
9232:  INCF   xD5,F
9234:  BTFSC  FD8.2
9236:  INCF   xD6,F
9238:  MOVLB  A
923A:  MOVWF  x8E
923C:  MOVFF  03,A8F
9240:  MOVLW  B8
9242:  ADDWF  x8E,W
9244:  MOVWF  FE9
9246:  MOVLW  01
9248:  ADDWFC 03,W
924A:  MOVWF  FEA
924C:  MOVFF  9D3,FEF
9250:  MOVLB  9
....................                      i++; 
9252:  INCF   xD2,F
....................                      if(temp==0)break; 
9254:  MOVF   xD3,F
9256:  BTFSC  FD8.2
9258:  BRA    925C
925A:  BRA    91FE
....................                    } 
....................                    addr_key=EEPROM_KEY_ST+((num_card-1)*50); 
925C:  MOVLW  01
925E:  SUBWF  xC8,W
9260:  MOVLB  A
9262:  MOVWF  x8E
9264:  MOVLW  00
9266:  MOVLB  9
9268:  SUBWFB xC9,W
926A:  MOVLB  A
926C:  MOVWF  x8F
926E:  CLRF   19
9270:  BTFSC  FF2.7
9272:  BSF    19.7
9274:  BCF    FF2.7
9276:  MOVWF  xBC
9278:  MOVFF  A8E,ABB
927C:  CLRF   xBE
927E:  MOVLW  32
9280:  MOVWF  xBD
9282:  MOVLB  0
9284:  CALL   3A52
9288:  BTFSC  19.7
928A:  BSF    FF2.7
928C:  MOVF   01,W
928E:  ADDLW  47
9290:  MOVLB  9
9292:  MOVWF  xB4
9294:  MOVLW  AA
9296:  ADDWFC 02,W
9298:  MOVWF  xB5
929A:  CLRF   xB6
929C:  CLRF   xB7
....................                    //if(ptr_card_key>addr_key) 
....................                    //{ 
....................                       strcpy(buftemp2," PIN:"); 
929E:  MOVLW  0A
92A0:  MOVWF  FEA
92A2:  MOVLW  5C
92A4:  MOVWF  FE9
92A6:  MOVLW  00
92A8:  MOVLB  0
92AA:  CALL   0410
92AE:  TBLRD*-
92B0:  TBLRD*+
92B2:  MOVF   FF5,W
92B4:  MOVWF  FEE
92B6:  IORLW  00
92B8:  BNZ   92B0
....................                       len=pre_msg(buftemp2,msg_data_sending,len); 
92BA:  MOVLW  0A
92BC:  MOVLB  A
92BE:  MOVWF  x8F
92C0:  MOVLW  5C
92C2:  MOVWF  x8E
92C4:  MOVLW  01
92C6:  MOVWF  x91
92C8:  MOVLW  B8
92CA:  MOVWF  x90
92CC:  MOVFF  9D6,A93
92D0:  MOVFF  9D5,A92
92D4:  MOVLB  0
92D6:  CALL   5F36
92DA:  MOVLB  9
92DC:  CLRF   xD6
92DE:  MOVFF  01,9D5
....................                       j=0; 
92E2:  CLRF   xDA
....................                       do 
....................                       { 
....................                         temp=read_ext_eeprom(j+addr_key); 
92E4:  MOVF   xDA,W
92E6:  ADDWF  xB4,W
92E8:  MOVLB  A
92EA:  MOVWF  x8E
92EC:  MOVLW  00
92EE:  MOVLB  9
92F0:  ADDWFC xB5,W
92F2:  MOVLB  A
92F4:  MOVWF  x8F
92F6:  CLRF   19
92F8:  BTFSC  FF2.7
92FA:  BSF    19.7
92FC:  BCF    FF2.7
92FE:  MOVWF  xC0
9300:  MOVFF  A8E,ABF
9304:  MOVLB  0
9306:  CALL   395A
930A:  BTFSC  19.7
930C:  BSF    FF2.7
930E:  MOVFF  01,9D3
....................                         if(((temp>47)&&(temp<58))||((temp=='#')||(temp=='*'))||(temp>64)&&(temp<91)) 
9312:  MOVLB  9
9314:  MOVF   xD3,W
9316:  SUBLW  2F
9318:  BC    9320
931A:  MOVF   xD3,W
931C:  SUBLW  39
931E:  BC    9338
9320:  MOVF   xD3,W
9322:  SUBLW  23
9324:  BZ    9338
9326:  MOVF   xD3,W
9328:  SUBLW  2A
932A:  BZ    9338
932C:  MOVF   xD3,W
932E:  SUBLW  40
9330:  BC    935E
9332:  MOVF   xD3,W
9334:  SUBLW  5A
9336:  BNC   935E
....................                            msg_data_sending[len++]=temp; 
9338:  MOVFF  9D6,03
933C:  MOVF   xD5,W
933E:  INCF   xD5,F
9340:  BTFSC  FD8.2
9342:  INCF   xD6,F
9344:  MOVLB  A
9346:  MOVWF  x8E
9348:  MOVFF  03,A8F
934C:  MOVLW  B8
934E:  ADDWF  x8E,W
9350:  MOVWF  FE9
9352:  MOVLW  01
9354:  ADDWFC 03,W
9356:  MOVWF  FEA
9358:  MOVFF  9D3,FEF
935C:  MOVLB  9
....................                         j++; 
935E:  INCF   xDA,F
....................                       } 
....................                       while((j<key_numbyte)&&(temp!=0)); 
9360:  MOVF   xDA,W
9362:  SUBLW  31
9364:  BNC   936A
9366:  MOVF   xD3,F
9368:  BNZ   92E4
....................                       fprintf(COM2,"%lu character\n\r",len);   
936A:  MOVLW  10
936C:  MOVWF  FE9
936E:  CLRF   19
9370:  BTFSC  FF2.7
9372:  BSF    19.7
9374:  BCF    FF2.7
9376:  MOVFF  9D6,ABD
937A:  MOVFF  9D5,ABC
937E:  MOVLB  0
9380:  CALL   1742
9384:  BTFSC  19.7
9386:  BSF    FF2.7
9388:  MOVLW  45
938A:  MOVWF  FF6
938C:  MOVLW  4F
938E:  MOVWF  FF7
9390:  CLRF   19
9392:  BTFSC  FF2.7
9394:  BSF    19.7
9396:  BCF    FF2.7
9398:  MOVLW  0C
939A:  MOVLB  A
939C:  MOVWF  xD3
939E:  MOVLB  0
93A0:  CALL   1718
93A4:  BTFSC  19.7
93A6:  BSF    FF2.7
....................                      //fprintf(COM2," addr_key=%lu\n\r",addr_key); 
....................                       //addr_key=addr_key+(50); 
....................                     //}        
....................                    lastlen=0;  
93A8:  MOVLB  9
93AA:  CLRF   xD1
93AC:  CLRF   xD0
....................                    //fprintf(COM2,"countc,num_card =%lu,%lu\n\r",countc,num_card); 
....................                    if((countc==num_card)&&(countc!=0)) 
93AE:  MOVF   xC8,W
93B0:  SUBWF  xCC,W
93B2:  BNZ   93CC
93B4:  MOVF   xC9,W
93B6:  SUBWF  xCD,W
93B8:  BNZ   93CC
93BA:  MOVF   xCC,F
93BC:  BNZ   93C2
93BE:  MOVF   xCD,F
93C0:  BZ    93CC
....................                    { 
....................                      SIM_state=delete_MSG;  
93C2:  MOVLW  06
93C4:  MOVLB  4
93C6:  MOVWF  x95
....................                      break; 
93C8:  BRA    991E
93CA:  MOVLB  9
....................                    } 
....................                    num_card--; 
93CC:  MOVF   xC8,W
93CE:  BTFSC  FD8.2
93D0:  DECF   xC9,F
93D2:  DECF   xC8,F
....................                    //fprintf(COM2,"send_oneMSG =%d\n\r",send_oneMSG); 
....................                    if(send_oneMSG==1) 
93D4:  MOVLB  4
93D6:  DECFSZ x9A,W
93D8:  BRA    93E4
....................                    { 
....................                      num_card=0; 
93DA:  MOVLB  9
93DC:  CLRF   xC9
93DE:  CLRF   xC8
....................                      send_oneMSG=0; 
93E0:  MOVLB  4
93E2:  CLRF   x9A
....................                    } 
....................                    SIM_state=MSG_sending;               
93E4:  MOVLW  08
93E6:  MOVWF  x95
....................             break; 
93E8:  BRA    991E
....................             case MSG_sending: 
....................                   fprintf(COM2,"MSG_sending %d\n\r",MSG_sending_st); 
93EA:  MOVLW  52
93EC:  MOVWF  FF6
93EE:  MOVLW  4F
93F0:  MOVWF  FF7
93F2:  CLRF   19
93F4:  BTFSC  FF2.7
93F6:  BSF    19.7
93F8:  BCF    FF2.7
93FA:  MOVLW  0C
93FC:  MOVLB  A
93FE:  MOVWF  xD3
9400:  MOVLB  0
9402:  CALL   1718
9406:  BTFSC  19.7
9408:  BSF    FF2.7
940A:  CLRF   19
940C:  BTFSC  FF2.7
940E:  BSF    19.7
9410:  BCF    FF2.7
9412:  MOVFF  496,ABF
9416:  MOVLW  18
9418:  MOVLB  A
941A:  MOVWF  xC0
941C:  MOVLB  0
941E:  CALL   1836
9422:  BTFSC  19.7
9424:  BSF    FF2.7
9426:  CLRF   19
9428:  BTFSC  FF2.7
942A:  BSF    19.7
942C:  BCF    FF2.7
942E:  MOVLW  0A
9430:  MOVLB  A
9432:  MOVWF  xDF
9434:  MOVLB  0
9436:  CALL   075A
943A:  BTFSC  19.7
943C:  BSF    FF2.7
943E:  CLRF   19
9440:  BTFSC  FF2.7
9442:  BSF    19.7
9444:  BCF    FF2.7
9446:  MOVLW  0D
9448:  MOVLB  A
944A:  MOVWF  xDF
944C:  MOVLB  0
944E:  CALL   075A
9452:  BTFSC  19.7
9454:  BSF    FF2.7
....................                   //fprintf(COM2,"lastlen = %ld\n\r",lastlen); 
....................                    
....................                   //fprintf(COM2,"MSG_sending_st %d\n\r",MSG_sending_st); 
....................                   timing_wait=10000; 
9456:  MOVLW  27
9458:  MOVLB  4
945A:  MOVWF  x98
945C:  MOVLW  10
945E:  MOVWF  x97
....................                output_high(LED); 
9460:  BCF    F92.6
9462:  BSF    F89.6
....................                #ASM BCF    0xF94.7 #ENDASM  
9464:  BCF    F94.7
....................                switch(MSG_sending_st) 
9466:  MOVF   x96,W
9468:  XORLW  00
946A:  MOVLB  0
946C:  BZ    9478
946E:  XORLW  01
9470:  BZ    94D4
9472:  XORLW  03
9474:  BZ    9546
9476:  BRA    9606
....................                { 
....................                   case 0:// configure MSG 
....................                      receiver_state=1; 
9478:  MOVLW  01
947A:  MOVLB  1
947C:  MOVWF  xB4
....................                         fprintf(COM1,"AT+CMGF=1\r\n"); // text mode 
947E:  MOVLW  64
9480:  MOVWF  FF6
9482:  MOVLW  4F
9484:  MOVWF  FF7
9486:  MOVLB  0
9488:  CALL   53E0
....................                      //fprintf(COM2,"AT+CMGF=1\r\n"); // text mode 
....................                      strl= strlen(msg_data_sending); 
948C:  MOVLW  01
948E:  MOVLB  A
9490:  MOVWF  x97
9492:  MOVLW  B8
9494:  MOVWF  x96
9496:  MOVLB  0
9498:  CALL   5EFC
949C:  MOVFF  01,9D9
....................                      MSG_sending_st=1; 
94A0:  MOVLW  01
94A2:  MOVLB  4
94A4:  MOVWF  x96
....................                      if((lastlen==140)&&(msg_data_sending[lastlen]==0)) 
94A6:  MOVLB  9
94A8:  MOVF   xD0,W
94AA:  SUBLW  8C
94AC:  BNZ   94D0
94AE:  MOVF   xD1,F
94B0:  BNZ   94D0
94B2:  MOVLW  B8
94B4:  ADDWF  xD0,W
94B6:  MOVWF  FE9
94B8:  MOVLW  01
94BA:  ADDWFC xD1,W
94BC:  MOVWF  FEA
94BE:  MOVF   FEF,F
94C0:  BNZ   94D0
....................                      { 
....................                         MSG_sending_st=0; 
94C2:  MOVLB  4
94C4:  CLRF   x96
....................                         SIM_state=delete_MSG; 
94C6:  MOVLW  06
94C8:  MOVWF  x95
....................                         break; 
94CA:  MOVLB  0
94CC:  BRA    9606
94CE:  MOVLB  9
....................                      } 
....................                      //EEPROM_read(strobe_mobile_num1,20,mobilenumb);  
....................                   break; 
94D0:  MOVLB  0
94D2:  BRA    9606
....................                   case 1: 
....................                         fprintf(COM1,"AT+CMGS="); 
94D4:  MOVLW  70
94D6:  MOVWF  FF6
94D8:  MOVLW  4F
94DA:  MOVWF  FF7
94DC:  CALL   53E0
....................                      //fprintf(COM2,"AT+CMGS="); 
....................                      fputc('"',COM1); 
94E0:  MOVLW  22
94E2:  CALL   650A
....................                      i=0; 
94E6:  MOVLB  9
94E8:  CLRF   xD2
....................                      while((mobilenumb[i]!=0)&&(i<20)) 
94EA:  CLRF   03
94EC:  MOVF   xD2,W
94EE:  ADDLW  79
94F0:  MOVWF  FE9
94F2:  MOVLW  04
94F4:  ADDWFC 03,W
94F6:  MOVWF  FEA
94F8:  MOVF   FEF,F
94FA:  BZ    9524
94FC:  MOVF   xD2,W
94FE:  SUBLW  13
9500:  BNC   9524
....................                      { 
....................                         fputc(mobilenumb[i],COM1); 
9502:  CLRF   03
9504:  MOVF   xD2,W
9506:  ADDLW  79
9508:  MOVWF  FE9
950A:  MOVLW  04
950C:  ADDWFC 03,W
950E:  MOVWF  FEA
9510:  MOVFF  FEF,A8E
9514:  MOVLB  A
9516:  MOVF   x8E,W
9518:  MOVLB  0
951A:  CALL   650A
....................                         //fprintf(COM2,"%c",mobilenumb[i]);  
....................                         i++; 
951E:  MOVLB  9
9520:  INCF   xD2,F
9522:  BRA    94EA
....................                      } 
....................                      fputc('"',COM1); 
9524:  MOVLW  22
9526:  MOVLB  0
9528:  CALL   650A
....................                      fprintf(COM1,"\r\n"); 
952C:  MOVLW  0D
952E:  BTFSS  F9E.4
9530:  BRA    952E
9532:  MOVWF  FAE
9534:  MOVLW  0A
9536:  BTFSS  F9E.4
9538:  BRA    9536
953A:  MOVWF  FAE
....................                      MSG_sending_st=2; 
953C:  MOVLW  02
953E:  MOVLB  4
9540:  MOVWF  x96
....................                   break; 
9542:  MOVLB  0
9544:  BRA    9606
....................                   case 2: 
....................                      //while((msg_data_sending[i]!=0)&&(i<140)) 
....................                      for(i=0;i<140;i++) 
9546:  MOVLB  9
9548:  CLRF   xD2
954A:  MOVF   xD2,W
954C:  SUBLW  8B
954E:  BNC   95BA
....................                      { 
....................                         if(msg_data_sending[i+lastlen]==0) 
9550:  MOVF   xD2,W
9552:  ADDWF  xD0,W
9554:  MOVLB  A
9556:  MOVWF  x8E
9558:  MOVLW  00
955A:  MOVLB  9
955C:  ADDWFC xD1,W
955E:  MOVLB  A
9560:  MOVWF  x8F
9562:  MOVLW  B8
9564:  ADDWF  x8E,W
9566:  MOVWF  FE9
9568:  MOVLW  01
956A:  ADDWFC x8F,W
956C:  MOVWF  FEA
956E:  MOVF   FEF,F
9570:  BNZ   9588
....................                         { 
....................                            SIM_state=delete_MSG;    
9572:  MOVLW  06
9574:  MOVLB  4
9576:  MOVWF  x95
....................                            MSG_sending_st=0; 
9578:  CLRF   x96
....................                            fputc(26,COM1); 
957A:  MOVLW  1A
957C:  MOVLB  0
957E:  CALL   650A
....................                            break; 
9582:  MOVLB  9
9584:  BRA    95BA
9586:  MOVLB  A
....................                         } 
....................                         fputc(msg_data_sending[i+lastlen],COM1); 
9588:  MOVLB  9
958A:  MOVF   xD2,W
958C:  ADDWF  xD0,W
958E:  MOVLB  A
9590:  MOVWF  x8E
9592:  MOVLW  00
9594:  MOVLB  9
9596:  ADDWFC xD1,W
9598:  MOVLB  A
959A:  MOVWF  x8F
959C:  MOVLW  B8
959E:  ADDWF  x8E,W
95A0:  MOVWF  FE9
95A2:  MOVLW  01
95A4:  ADDWFC x8F,W
95A6:  MOVWF  FEA
95A8:  MOVFF  FEF,A90
95AC:  MOVF   x90,W
95AE:  MOVLB  0
95B0:  CALL   650A
95B4:  MOVLB  9
95B6:  INCF   xD2,F
95B8:  BRA    954A
....................                      } 
....................                      //fprintf(COM2,"i= %u\n\r",i);  
....................                      fputc(26,COM1); 
95BA:  MOVLW  1A
95BC:  MOVLB  0
95BE:  CALL   650A
....................                      MSG_sending_st=0; 
95C2:  MOVLB  4
95C4:  CLRF   x96
....................                      if(i<140) 
95C6:  MOVLB  9
95C8:  MOVF   xD2,W
95CA:  SUBLW  8B
95CC:  BNC   95DC
....................                      { 
....................                         SIM_state=check_st; 
95CE:  MOVLW  09
95D0:  MOVLB  4
95D2:  MOVWF  x95
....................                         lastlen=0; 
95D4:  MOVLB  9
95D6:  CLRF   xD1
95D8:  CLRF   xD0
....................                      } 
95DA:  BRA    95F2
....................                      else 
....................                      { 
....................                         lastlen=140; 
95DC:  CLRF   xD1
95DE:  MOVLW  8C
95E0:  MOVWF  xD0
....................                         if(msg_data_sending[140]==0)SIM_state=check_st; 
95E2:  MOVLB  2
95E4:  MOVF   x44,F
95E6:  BNZ   95F0
95E8:  MOVLW  09
95EA:  MOVLB  4
95EC:  MOVWF  x95
95EE:  MOVLB  2
95F0:  MOVLB  9
....................                      } 
....................                      if(lastlen==140)SIM_state=MSG_sending; 
95F2:  MOVF   xD0,W
95F4:  SUBLW  8C
95F6:  BNZ   9604
95F8:  MOVF   xD1,F
95FA:  BNZ   9604
95FC:  MOVLW  08
95FE:  MOVLB  4
9600:  MOVWF  x95
9602:  MOVLB  9
....................                      //fprintf(COM2,"lastlen %lu\n\r",lastlen);   
....................                   break; 
9604:  MOVLB  0
....................                } 
....................                #ASM BSF    0xF94.7 #ENDASM  
9606:  BSF    F94.7
....................             break; 
9608:  MOVLB  4
960A:  BRA    991E
....................             case check_st: 
....................                //fprintf(COM2,"check_st->num_card,countc, count_dwla, lastlen =%lu,%lu,%lu,%lu\r\n",num_card,countc,count_dwla,lastlen);   
....................                if(count_dwla>1) 
960C:  MOVLB  9
960E:  MOVF   xCF,F
9610:  BNZ   9618
9612:  MOVF   xCE,W
9614:  SUBLW  01
9616:  BC    962C
....................                { 
....................                   count_dwla--; 
9618:  MOVF   xCE,W
961A:  BTFSC  FD8.2
961C:  DECF   xCF,F
961E:  DECF   xCE,F
....................                   SIM_state=pre_cmd; 
9620:  MOVLW  07
9622:  MOVLB  4
9624:  MOVWF  x95
....................                   break; 
9626:  BRA    991E
....................                } 
9628:  BRA    9644
962A:  MOVLB  9
....................                else if(countc>0)  
962C:  MOVF   xCC,F
962E:  BNZ   9634
9630:  MOVF   xCD,F
9632:  BZ    963E
....................                { 
....................                   SIM_state=pre_cmd; 
9634:  MOVLW  07
9636:  MOVLB  4
9638:  MOVWF  x95
....................                   break; 
963A:  BRA    991E
....................                } 
963C:  BRA    9644
....................                else SIM_state=delete_MSG; 
963E:  MOVLW  06
9640:  MOVLB  4
9642:  MOVWF  x95
....................             break; 
9644:  BRA    991E
....................             case autosending:  
....................                   //auto_sending=read_ext_eeprom(strobe_autosending); 
....................                   //if(auto_sending==1) 
....................                   //{ 
....................                      EEPROM_read(strobe_mobile_num1,20,mobilenumb);  
9646:  MOVLW  55
9648:  MOVLB  A
964A:  MOVWF  x8E
964C:  MOVLW  14
964E:  MOVWF  x8F
9650:  MOVLW  04
9652:  MOVWF  x91
9654:  MOVLW  79
9656:  MOVWF  x90
9658:  MOVLB  0
965A:  CALL   5076
....................                      #if defined(twonumber)  
....................                         fprintf(COM2,"\r\nSending to the first number\r\n"); 
965E:  MOVLW  7A
9660:  MOVWF  FF6
9662:  MOVLW  4F
9664:  MOVWF  FF7
9666:  CLRF   19
9668:  BTFSC  FF2.7
966A:  BSF    19.7
966C:  BCF    FF2.7
966E:  CALL   07A0
9672:  BTFSC  19.7
9674:  BSF    FF2.7
9676:  CLRF   19
9678:  BTFSC  FF2.7
967A:  BSF    19.7
967C:  BCF    FF2.7
....................                      #else  
....................                         fprintf(COM2,"\r\nSending\r\n"); 
....................                      #endif 
....................                      num_card=get_countcard(); 
967E:  CALL   3A02
9682:  BTFSC  19.7
9684:  BSF    FF2.7
9686:  MOVFF  02,9C9
968A:  MOVFF  01,9C8
....................                      countc=0; 
968E:  MOVLB  9
9690:  CLRF   xCD
9692:  CLRF   xCC
....................                      count_dwla=0; 
9694:  CLRF   xCF
9696:  CLRF   xCE
....................                      lastlen=0; 
9698:  CLRF   xD1
969A:  CLRF   xD0
....................                      send_oneMSG=1; 
969C:  MOVLW  01
969E:  MOVLB  4
96A0:  MOVWF  x9A
....................                      SIM_state=pre_cmd; 
96A2:  MOVLW  07
96A4:  MOVWF  x95
....................                   //} 
....................                   //else SIM_state= reading_sms_cmd; 
....................             break; 
96A6:  BRA    991E
....................             #if defined(twonumber)  
....................             case autosending1:  
....................                   //auto_sending=read_ext_eeprom(strobe_autosending); 
....................                   //if(auto_sending==1) 
....................                   //{ 
....................                      EEPROM_read(strobe_mobile_num0,20,mobilenumb);  
96A8:  MOVLW  41
96AA:  MOVLB  A
96AC:  MOVWF  x8E
96AE:  MOVLW  14
96B0:  MOVWF  x8F
96B2:  MOVLW  04
96B4:  MOVWF  x91
96B6:  MOVLW  79
96B8:  MOVWF  x90
96BA:  MOVLB  0
96BC:  CALL   5076
....................                      if((mobilenumb[0]==0)&&(mobilenumb[1]==0)&&(mobilenumb[2]==0)&&(mobilenumb[3]==0)&&(mobilenumb[5]==0)&&(mobilenumb[7]==0)&&(mobilenumb[9]==0)) 
96C0:  MOVLB  4
96C2:  MOVF   x79,F
96C4:  BNZ   9702
96C6:  MOVF   x7A,F
96C8:  BNZ   9702
96CA:  MOVF   x7B,F
96CC:  BNZ   9702
96CE:  MOVF   x7C,F
96D0:  BNZ   9702
96D2:  MOVF   x7E,F
96D4:  BNZ   9702
96D6:  MOVF   x80,F
96D8:  BNZ   9702
96DA:  MOVF   x82,F
96DC:  BNZ   9702
....................                      { 
....................                         send_oneMSG=0; 
96DE:  CLRF   x9A
....................                         fprintf(COM2,"\r\nthe 2nd number is not installed\r\n"); 
96E0:  MOVLW  9A
96E2:  MOVWF  FF6
96E4:  MOVLW  4F
96E6:  MOVWF  FF7
96E8:  CLRF   19
96EA:  BTFSC  FF2.7
96EC:  BSF    19.7
96EE:  BCF    FF2.7
96F0:  MOVLB  0
96F2:  CALL   07A0
96F6:  BTFSC  19.7
96F8:  BSF    FF2.7
....................                         SIM_state=delete_MSG;    
96FA:  MOVLW  06
96FC:  MOVLB  4
96FE:  MOVWF  x95
....................                      } 
9700:  BRA    9742
....................                      else 
....................                      { 
....................                         fprintf(COM2,"\r\nSending to the second number\r\n"); 
9702:  MOVLW  BE
9704:  MOVWF  FF6
9706:  MOVLW  4F
9708:  MOVWF  FF7
970A:  CLRF   19
970C:  BTFSC  FF2.7
970E:  BSF    19.7
9710:  BCF    FF2.7
9712:  MOVLB  0
9714:  CALL   07A0
9718:  BTFSC  19.7
971A:  BSF    FF2.7
....................                         send_oneMSG=1; 
971C:  MOVLW  01
971E:  MOVLB  4
9720:  MOVWF  x9A
9722:  CLRF   19
9724:  BTFSC  FF2.7
9726:  BSF    19.7
9728:  BCF    FF2.7
....................                         num_card=get_countcard(); 
972A:  MOVLB  0
972C:  CALL   3A02
9730:  BTFSC  19.7
9732:  BSF    FF2.7
9734:  MOVFF  02,9C9
9738:  MOVFF  01,9C8
....................                         SIM_state=pre_cmd; 
973C:  MOVLW  07
973E:  MOVLB  4
9740:  MOVWF  x95
....................                      }                      
....................                      countc=0; 
9742:  MOVLB  9
9744:  CLRF   xCD
9746:  CLRF   xCC
....................                      count_dwla=0; 
9748:  CLRF   xCF
974A:  CLRF   xCE
....................                      lastlen=0;                      
974C:  CLRF   xD1
974E:  CLRF   xD0
....................                   //} 
....................                   //else SIM_state= reading_sms_cmd; 
....................             break; 
9750:  MOVLB  4
9752:  BRA    991E
....................             #endif 
....................             case idle: 
....................                   output_toggle(LED); 
9754:  BCF    F92.6
9756:  BTG    F89.6
....................                   fprintf(COM2,"idle\n\r"); 
9758:  MOVLW  E0
975A:  MOVWF  FF6
975C:  MOVLW  4F
975E:  MOVWF  FF7
9760:  CLRF   19
9762:  BTFSC  FF2.7
9764:  BSF    19.7
9766:  BCF    FF2.7
9768:  CALL   07A0
976C:  BTFSC  19.7
976E:  BSF    FF2.7
....................                   fprintf(COM1,"AT+CMGF=1\r\n"); 
9770:  MOVLW  E8
9772:  MOVWF  FF6
9774:  MOVLW  4F
9776:  MOVWF  FF7
9778:  CALL   53E0
....................                   output_low(LED); 
977C:  BCF    F92.6
977E:  BCF    F89.6
....................                   SIM_state= data_analyze; 
9780:  MOVLW  0D
9782:  MOVLB  4
9784:  MOVWF  x95
....................                   receiver_state=0; 
9786:  MOVLB  1
9788:  CLRF   xB4
....................                   timing_wait=1500; 
978A:  MOVLW  05
978C:  MOVLB  4
978E:  MOVWF  x98
9790:  MOVLW  DC
9792:  MOVWF  x97
....................             break; 
9794:  BRA    991E
....................             case data_analyze: 
....................              
....................                   /*use for debug*/ 
....................                   /*fprintf(COM2,"\n\rcard_timeout %lu\n\r",card_timeout); 
....................                   fprintf(COM2,"\n\rbug_countbit_T1 %lu\n\r",bug_countbit_T1); 
....................                   fprintf(COM2,"\n\rbug_countbit_T2 %lu\n\r",bug_countbit_T2);*/                   
....................                   /*use for debug*/ 
....................                   //fprintf(COM2,"data_analyze=%d\n\r",temp); 
....................                   booting_done=1; 
9796:  MOVLW  01
9798:  MOVLB  1
979A:  MOVWF  xB5
....................                   output_low(LED); 
979C:  BCF    F92.6
979E:  BCF    F89.6
....................                   temp=SMS_coming(); 
97A0:  MOVLB  0
97A2:  GOTO   6512
97A6:  MOVFF  01,9D3
....................                   if(temp==2) 
97AA:  MOVLB  9
97AC:  MOVF   xD3,W
97AE:  SUBLW  02
97B0:  BNZ   97C4
....................                   { 
....................                      output_high(LED); 
97B2:  BCF    F92.6
97B4:  BSF    F89.6
....................                      SIM_state=reading_sms_cmd; 
97B6:  MOVLW  01
97B8:  MOVLB  4
97BA:  MOVWF  x95
....................                      count_checking=0; 
97BC:  MOVLB  1
97BE:  CLRF   x07
97C0:  CLRF   x06
97C2:  MOVLB  9
....................                   } 
....................                   count_checking++; 
97C4:  MOVLB  1
97C6:  INCF   x06,F
97C8:  BTFSC  FD8.2
97CA:  INCF   x07,F
....................                   if(count_checking==20) 
97CC:  MOVF   x06,W
97CE:  SUBLW  14
97D0:  BNZ   97E2
97D2:  MOVF   x07,F
97D4:  BNZ   97E2
....................                   { 
....................                      //SIM_state=phone_activity_status; 
....................                      SIM_state=check_comunication; 
97D6:  MOVLW  0F
97D8:  MOVLB  4
97DA:  MOVWF  x95
....................                      count_checking=0; 
97DC:  MOVLB  1
97DE:  CLRF   x07
97E0:  CLRF   x06
....................                   } 
....................             break; 
97E2:  MOVLB  4
97E4:  BRA    991E
....................             case SIM_reply: 
....................                   fprintf(COM2,"SIM is replying\n\r"); 
97E6:  MOVLW  F4
97E8:  MOVWF  FF6
97EA:  MOVLW  4F
97EC:  MOVWF  FF7
97EE:  CLRF   19
97F0:  BTFSC  FF2.7
97F2:  BSF    19.7
97F4:  BCF    FF2.7
97F6:  CALL   07A0
97FA:  BTFSC  19.7
97FC:  BSF    FF2.7
....................                   //send_sms(mobilenumb,reply_buffer); 
....................                   len=0; 
97FE:  MOVLB  9
9800:  CLRF   xD6
9802:  CLRF   xD5
9804:  CLRF   19
9806:  BTFSC  FF2.7
9808:  BSF    19.7
980A:  BCF    FF2.7
....................                   cards=get_countcard(); 
980C:  MOVLB  0
980E:  CALL   3A02
9812:  BTFSC  19.7
9814:  BSF    FF2.7
9816:  MOVFF  02,9CB
981A:  MOVFF  01,9CA
....................                   //strcpy(msg_buffer2,"device has "); 
....................                   len=pre_msg(reply_buffer,msg_data_sending,0); 
981E:  MOVLW  03
9820:  MOVLB  A
9822:  MOVWF  x8F
9824:  MOVLW  48
9826:  MOVWF  x8E
9828:  MOVLW  01
982A:  MOVWF  x91
982C:  MOVLW  B8
982E:  MOVWF  x90
9830:  CLRF   x93
9832:  CLRF   x92
9834:  MOVLB  0
9836:  CALL   5F36
983A:  MOVLB  9
983C:  CLRF   xD6
983E:  MOVFF  01,9D5
....................                   //itoa(cards,10,string); 
....................                   //len=pre_msg(string,msg_data_sending,len); 
....................                   //strcpy(msg_buffer2," transaction "); 
....................                   //len=pre_msg(msg_buffer2,msg_data_sending,len); 
....................                   SIM_state=MSG_sending; 
9842:  MOVLW  08
9844:  MOVLB  4
9846:  MOVWF  x95
....................                   lastlen=0; 
9848:  MOVLB  9
984A:  CLRF   xD1
984C:  CLRF   xD0
....................                   //fprintf(COM2,"device has %lu transaction \n\r",cards); 
....................                   countc=0; 
984E:  CLRF   xCD
9850:  CLRF   xCC
....................                   count_dwla=0; 
9852:  CLRF   xCF
9854:  CLRF   xCE
....................             break; 
9856:  MOVLB  4
9858:  BRA    991E
....................             case check_comunication: 
....................                fprintf(COM2,"check comunication\n\r"); 
985A:  MOVLW  06
985C:  MOVWF  FF6
985E:  MOVLW  50
9860:  MOVWF  FF7
9862:  CLRF   19
9864:  BTFSC  FF2.7
9866:  BSF    19.7
9868:  BCF    FF2.7
986A:  CALL   07A0
986E:  BTFSC  19.7
9870:  BSF    FF2.7
....................                //SIM_state= data_analyze; 
....................                SIM_state= phone_activity_status; 
9872:  MOVLW  10
9874:  MOVLB  4
9876:  MOVWF  x95
....................                booting_done=0; 
9878:  MOVLB  1
987A:  CLRF   xB5
....................                checking_sim=1; 
987C:  MOVLW  01
987E:  MOVLB  4
9880:  MOVWF  x9C
....................                setup_wdt(WDT_ON); 
9882:  BSF    FC0.0
....................                fprintf(COM1,"AT\r\n");   
9884:  MOVLW  1C
9886:  MOVWF  FF6
9888:  MOVLW  50
988A:  MOVWF  FF7
988C:  MOVLB  0
988E:  CALL   53E0
....................             break; 
9892:  MOVLB  4
9894:  BRA    991E
....................             case phone_activity_status: 
....................                booting_done=1; 
9896:  MOVLW  01
9898:  MOVLB  1
989A:  MOVWF  xB5
....................                fprintf(COM2,"SIM activity status\n\r"); 
989C:  MOVLW  22
989E:  MOVWF  FF6
98A0:  MOVLW  50
98A2:  MOVWF  FF7
98A4:  CLRF   19
98A6:  BTFSC  FF2.7
98A8:  BSF    19.7
98AA:  BCF    FF2.7
98AC:  MOVLB  0
98AE:  CALL   07A0
98B2:  BTFSC  19.7
98B4:  BSF    FF2.7
....................                SIM_state= data_analyze; 
98B6:  MOVLW  0D
98B8:  MOVLB  4
98BA:  MOVWF  x95
....................                fprintf(COM1,"AT+CPAS\r\n");  
98BC:  MOVLW  38
98BE:  MOVWF  FF6
98C0:  MOVLW  50
98C2:  MOVWF  FF7
98C4:  MOVLB  0
98C6:  CALL   53E0
....................             break; 
98CA:  MOVLB  4
98CC:  BRA    991E
....................             case check_inbox: 
....................                fprintf(COM2,"check inbox\n\r"); 
98CE:  MOVLW  42
98D0:  MOVWF  FF6
98D2:  MOVLW  50
98D4:  MOVWF  FF7
98D6:  CLRF   19
98D8:  BTFSC  FF2.7
98DA:  BSF    19.7
98DC:  BCF    FF2.7
98DE:  CALL   07A0
98E2:  BTFSC  19.7
98E4:  BSF    FF2.7
....................                SIM_state= data_analyze; 
98E6:  MOVLW  0D
98E8:  MOVLB  4
98EA:  MOVWF  x95
....................                fprintf(COM1,"AT+CMGR=1\r\n"); 
98EC:  MOVLW  50
98EE:  MOVWF  FF6
98F0:  MOVLW  50
98F2:  MOVWF  FF7
98F4:  MOVLB  0
98F6:  CALL   53E0
....................             break; 
98FA:  MOVLB  4
98FC:  BRA    991E
....................             case reset_module: 
....................                setup_wdt(WDT_ON); 
98FE:  BSF    FC0.0
....................                fprintf(COM2,"reset_module\n\r"); 
9900:  MOVLW  5C
9902:  MOVWF  FF6
9904:  MOVLW  50
9906:  MOVWF  FF7
9908:  CLRF   19
990A:  BTFSC  FF2.7
990C:  BSF    19.7
990E:  BCF    FF2.7
9910:  CALL   07A0
9914:  BTFSC  19.7
9916:  BSF    FF2.7
....................             break; 
9918:  MOVLB  4
991A:  BRA    991E
991C:  MOVLB  4
....................          }         
....................       } 
....................       //restart_wdt(); 
....................       delay_us(500); 
991E:  MOVLW  02
9920:  MOVLB  A
9922:  MOVWF  x8E
9924:  CLRF   19
9926:  BTFSC  FF2.7
9928:  BSF    19.7
992A:  BCF    FF2.7
992C:  MOVLW  FA
992E:  MOVWF  xB4
9930:  MOVLB  0
9932:  CALL   0736
9936:  BTFSC  19.7
9938:  BSF    FF2.7
993A:  MOVLB  A
993C:  DECFSZ x8E,F
993E:  BRA    9924
....................      #else 
9940:  MOVLB  0
9942:  GOTO   7274
....................       if(mode==LOGOFF) 
....................       { 
....................          fprintf(COM2,"password:"); 
....................          //fprintf(COM2,"\n\r charac_timeout=%lu\n\r",charac_timeout); 
....................          USART_getstring(STAR_ECHO,20,buffer_uart); 
....................          //EEPROM_read(strobe_pass_addr,20,password); 
....................          /*fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",read_ext_eeprom(i)); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<5;i++) fprintf(COM2," %x",password[i]); 
....................          fprintf(COM2,"\n\r"); 
....................          for(i=0;i<20;i++) fprintf(COM2," %x",buffer_uart[i]);//*/ 
....................          //EEPROM_read(strobe_pass_addr,20,password); 
....................          if(!stringcomp(buffer_uart,password)) 
....................          { 
....................             mode=LOGON; 
....................             fprintf(COM2," OK\n\r"); 
....................          } 
....................          else fprintf(COM2," X\n\r"); 
....................       } 
....................          else if(mode==LOGON)adminmode();//*/ 
....................      #endif     
....................    } 
.................... } 
9946:  SLEEP 

Configuration Fuses:
   Word  1: F4A0   NOWDT STVREN NOXINST NODEBUG NOPROTECT
   Word  2: F7DA   INTRC_PLL_IO T1DIG NOLPT1OSC FCMEN IESO WDT128
   Word  3: F9FF   DSWDTOSC_INT RTCOSC_T1 DSBOR DSWDT DSWDT2147483648 IOL1WAY MSSPMSK7
   Word  4: F1FF   WPFP WPEND NOWPCFG WPDIS
